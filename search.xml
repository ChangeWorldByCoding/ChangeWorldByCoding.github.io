<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[函数式编程思维在三行代码情书中的应用]]></title>
      <url>/2018/05/30/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%80%9D%E7%BB%B4%E5%9C%A8%E4%B8%89%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%83%85%E4%B9%A6%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>如今主流的编程语言，函数式编程范式或多或少都融入其中成了“标配”，或者说主流语言都在进行函数式方面的扩充，这是一个大趋势。以Java为例，随着 Lambda块 和 Stream API 等这种高阶函数的加持，Java总算是装备了函数式这一利器；博大精深的C++也在2011版的语言标准里加入了Lambda块的支持；再比如前一段时间我初步体验了的 Groovy语言，虽然其运行于JVM之上，然而其对 动态语言、函数式编程范式 以及 元编程功能 的加持所带来的表现力和简洁性可以说甩了Java几条街，可以利用Groovy的所有动态功能构建高性能的JVM应用、将开发效率提高几个数量级。</p>
<a id="more"></a>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-02d2d950674eb868.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="42:9"></p>
<h2 id="—"><a href="#—" class="headerlink" title="—"></a>—</h2><h2 id="函数式编程概述"><a href="#函数式编程概述" class="headerlink" title="函数式编程概述"></a>函数式编程概述</h2><p>如今主流的编程语言，函数式编程范式或多或少都融入其中成了“标配”，或者说主流语言都在进行函数式方面的扩充，这是一个大趋势。以Java为例，随着 <strong>Lambda块</strong> 和 <strong>Stream API</strong> 等这种高阶函数的加持，Java总算是装备了函数式这一利器；博大精深的C++也在2011版的语言标准里加入了Lambda块的支持；再比如前一段时间我初步体验了的 <a href="https://www.jianshu.com/p/d9d15a2194ab" target="_blank" rel="noopener">Groovy语言</a>，虽然其运行于JVM之上，然而其对 <strong>动态语言</strong>、<strong>函数式编程范式</strong> 以及 <strong>元编程功能</strong> 的加持所带来的表现力和简洁性可以说甩了Java几条街，可以利用Groovy的所有动态功能构建高性能的JVM应用、将开发效率提高几个数量级。语言的例子有很多，我不一一枚举。</p>
<h2 id="—-1"><a href="#—-1" class="headerlink" title="—"></a>—</h2><h2 id="为什么要使用函数式编程范式"><a href="#为什么要使用函数式编程范式" class="headerlink" title="为什么要使用函数式编程范式"></a>为什么要使用函数式编程范式</h2><p>这里讲几个函数式编程的典型特点，区别的对象那就是传统的命令式编程</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-c84244e00d164ee0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="命令式编程 VS 函数式编程"></p>
<ul>
<li><strong>0x01. 更高层次的抽象（高阶函数）</strong></li>
</ul>
<blockquote>
<p>用高阶抽象来取代基本的控制结构本身就是一个全新的思考方式，这样可以让开发者聚焦精力于业务场景而无需费心复杂地层运作</p>
</blockquote>
<p>举个栗子：将一个字符串集合中的所有单词转为大写，我们用Java语言来实现</p>
<p>如果按照传统的命令式编程的解法，那接下来不出意外我们得来写循环、遍历这种迭代操作了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int i=0; i&lt;wordList.size(); i++) &#123;</span><br><span class="line">   wordList.get(i).toUpperCase();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但如果使用Java的函数式编程范式，一切都是那么的优雅，一句话搞定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wordList.stream.map( w -&gt; w.toUpperCase() )</span><br></pre></td></tr></table></figure>
<p>这里的map()函数就是所谓的高阶函数，我们用高阶函数代替了底层的迭代，因为我们并没有处理细节，我们仅仅定义了映射的逻辑，迭代由高阶函数来自动完成！</p>
<ul>
<li><strong>0x02. 提升代码信噪比（简洁性）</strong></li>
</ul>
<blockquote>
<p>区别于面向对象语言用抽象来封装不确定因素，函数式编程通过尽量减少不确定因素来使代码极度简洁</p>
</blockquote>
<p>上面的例子对于本条优点的展现我想应该也不必多说了</p>
<ul>
<li><strong>0x03. 控制权转交于运行时（动态性）</strong></li>
</ul>
<blockquote>
<p>区别于传统的编译形语言，配备函数式编程范式的动态语言更多的将控制权转交到语言运行时手里，获得的则是更高的灵活性、表现力和性能权衡。</p>
</blockquote>
<p>这三点优点将在接下来的例子中切实的感受并领会！</p>
<h2 id="—-2"><a href="#—-2" class="headerlink" title="—"></a>—</h2><h2 id="函数式编程例析"><a href="#函数式编程例析" class="headerlink" title="函数式编程例析"></a>函数式编程例析</h2><h3 id="举例1：词频统计"><a href="#举例1：词频统计" class="headerlink" title="举例1：词频统计"></a>举例1：词频统计</h3><p>做的事情很简单：给定一个单词集合，统计出集合中除了助词（如<code>of</code>、<code>on</code>、<code>the</code>等）之外的单词出现的频次，不区分大小写</p>
<p><strong>命令式解法：</strong> 至少分为以下几大步</p>
<ul>
<li>先进行循环迭代</li>
<li>然后统一将单词转为小写</li>
<li>然后判断单词是否是助词</li>
<li>最后进行词频统计</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCount</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个助词集合，这些单词不参与计数</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; auxiliaryWordSet = <span class="keyword">new</span> HashSet&lt;String&gt;() &#123;&#123;</span><br><span class="line">       add(<span class="string">"of"</span>); add(<span class="string">"the"</span>); add(<span class="string">"to"</span>); add(<span class="string">"and"</span>); add(<span class="string">"so"</span>); add(<span class="string">"are”);</span></span><br><span class="line"><span class="string">    &#125;&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // 传统命令式解法实现的词频统计函数</span></span><br><span class="line"><span class="string">    public Map doWordCount( List&lt;String&gt; context ) &#123;</span></span><br><span class="line"><span class="string">        Map&lt;String,Integer&gt; result = new HashMap&lt;String, Integer&gt;();</span></span><br><span class="line"><span class="string">        for ( String word:context ) &#123;  // 循环迭代</span></span><br><span class="line"><span class="string">            String lowerCaseWord = word.toLowerCase();  // 将单词统一转换为小写</span></span><br><span class="line"><span class="string">            if( !auxiliaryWordSet.contains(lowerCaseWord) ) &#123;</span></span><br><span class="line"><span class="string">                if( null == result.get(lowerCaseWord) )</span></span><br><span class="line"><span class="string">                    result.put( lowerCaseWord, 1 );</span></span><br><span class="line"><span class="string">                else</span></span><br><span class="line"><span class="string">                    result.put( lowerCaseWord, result.get(lowerCaseWord)+1 );</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        return result;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // main() 函数</span></span><br><span class="line"><span class="string">    public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="string">        List&lt;String&gt; wordList = new ArrayList&lt;String&gt;() &#123;&#123;</span></span><br><span class="line"><span class="string">            add("</span>The<span class="string">"); add("</span>Products<span class="string">"); add("</span>of<span class="string">"); add("</span>Samsung<span class="string">"); add("</span>and<span class="string">"); add("</span>Apple”);</span><br><span class="line">            add(<span class="string">"are"</span>); add(<span class="string">"so"</span>); add(<span class="string">"amazing"</span>); add(<span class="string">"especially"</span>); add(<span class="string">"Apple”);</span></span><br><span class="line"><span class="string">        &#125;&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        WordCount wordCount = new WordCount();</span></span><br><span class="line"><span class="string">        Map res = wordCount.doWordCount( wordList );</span></span><br><span class="line"><span class="string">        System.out.print(res); // 打印：&#123;apple=2, amazing=1, samsung=1, especially=1, products=1&#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<hr>
<p><strong>函数式解法：</strong></p>
<p>如果我们用Java的Stream API和Lambda块所构成的函数式范式来重写 <code>doWordCount()</code> 函数，一切都将如此简洁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public Map doWordCount2( List&lt;String&gt; context ) &#123;</span><br><span class="line">    Map&lt;String,Integer&gt; result = new HashMap&lt;String, Integer&gt;();</span><br><span class="line">    context.stream().map( w -&gt; w.toLowerCase() )</span><br><span class="line">            .filter( w -&gt; !auxiliaryWordSet.contains(w) )</span><br><span class="line">            .forEach( w -&gt; result.put( w, result.getOrDefault(w,0) + 1 ) );</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">&gt; 备注：这里的`getOrDefault`是Java的Map提供的一个便利函数，意思是：在Map中若没有找到给定的key时，返回一个“默认值”</span><br><span class="line"></span><br><span class="line">对比命令式解法，用户省去了很多繁琐的迭代和判断，我们只讲焦点聚焦在业务逻辑之上，代码信噪比提升不小吧！</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### 举例2：连词成句</span><br><span class="line"></span><br><span class="line">给定一个离散的单词集合，我们想将字母数大于1的单词的首字母大写后，用 短横线- 连接起来成为一个句子</span><br><span class="line"></span><br><span class="line">**命令式解法：**</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class WordConnect &#123;</span><br><span class="line"></span><br><span class="line">    // 将单词的首字母大写</span><br><span class="line">    public String capitalizeFirstLetter( String s ) &#123;</span><br><span class="line">        return s.substring(0,1).toUpperCase() + s.substring(1,s.length() );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 连词成句</span><br><span class="line">    public String connectWord( List&lt;String&gt; context ) &#123;</span><br><span class="line">        StringBuilder result = new StringBuilder();</span><br><span class="line">        for ( String word: context ) &#123;</span><br><span class="line">            if ( word.length() &gt; 1 ) &#123;</span><br><span class="line">                result.append( capitalizeFirstLetter(word) );</span><br><span class="line">                result.append(&quot;-“);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result.substring(0,result.length()-1).toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // main()函数</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;String&gt; wordList = new ArrayList&lt;String&gt;() &#123;&#123;</span><br><span class="line">            add(&quot;The&quot;); add(&quot;Products&quot;); add(&quot;of&quot;); add(&quot;Samsung&quot;); add(&quot;and&quot;); add(&quot;Apple”);</span><br><span class="line">            add(&quot;are&quot;); add(&quot;so&quot;); add(&quot;amazing&quot;); add(&quot;especially&quot;); add(&quot;Apple”);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line"></span><br><span class="line">        WordConnect wordConnect = new WordConnect();</span><br><span class="line">        String res = wordConnect.connectWord( wordList );</span><br><span class="line">        System.out.print(res); // 打印：The-Products-Of-Samsung-And-Apple-Are-So-Amazing-Especially-Apple</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>函数式解法1：</strong> Java Steam API 和 Lambda块实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public String connectWord( List&lt;String&gt; context ) &#123;</span><br><span class="line">    return context.stream().filter( w -&gt; w.length()&gt;1 )</span><br><span class="line">            .map( w -&gt; capitalizeFirstLetter(w) )</span><br><span class="line">            .collect( Collectors.joining(&quot;-&quot;) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我什么都不想说了，这不要太简洁好吧！</p>
<p><strong>函数式解法2：</strong> Groovy语言实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public String connectWord( context ) &#123;</span><br><span class="line">    context.findAll &#123; it.length() &gt;1 &#125;</span><br><span class="line">    .collect &#123; it.capitalize() &#125;</span><br><span class="line">    .join ‘-‘</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于Groovy语言的初体验，可以参考我的文章：<a href="https://www.jianshu.com/p/d9d15a2194ab" target="_blank" rel="noopener">Groovy初体验：构建高性能JVM应用</a></p>
<h2 id="—-3"><a href="#—-3" class="headerlink" title="—"></a>—</h2><h2 id="函数式最佳实践：高效编写三行情书"><a href="#函数式最佳实践：高效编写三行情书" class="headerlink" title="函数式最佳实践：高效编写三行情书"></a>函数式最佳实践：高效编写三行情书</h2><p>还记得去年的520，为了表达心中对于老婆无限的、无法表达的爱，我想写一封不超过三行的代码情书，我更想用尽可能短的代码来尽可能多地表达，于是我选择了函数式编程。</p>
<p>我的520三行代码情书在此：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public TimeRiver timeFlow( List&lt;DaysMeetYou&gt; days ) &#123;</span><br><span class="line">    return (TimeRiver)days.stream()</span><br><span class="line">        .filter( n-&gt;theDaysNotWithYou(n) )</span><br><span class="line">        .map( e-&gt;accompanyByMyLove(e) )</span><br><span class="line">        .collect( Collectors.joining(“”) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-44d2f961247eb8bd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="我的520三行代码情书"></p>
<h2 id="—-4"><a href="#—-4" class="headerlink" title="—"></a>—</h2><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>文中提到的Groovy动态编程语言，作者体验过一点，可以参考：<a href="https://www.jianshu.com/p/d9d15a2194ab" target="_blank" rel="noopener">Groovy初体验：构建高性能JVM应用</a></p>
<p>如果有兴趣，也来看看作者一些关于容器化、微服务化方面的文章：</p>
<ul>
<li><a href="https://www.jianshu.com/p/52fa63b222ac" target="_blank" rel="noopener">RPC框架实践之：Apache Thrift</a> </li>
<li><a href="https://www.jianshu.com/p/da80ea881424" target="_blank" rel="noopener">微服务调用链追踪中心搭建</a></li>
<li><a href="https://www.jianshu.com/p/9bc87b5380e8" target="_blank" rel="noopener">利用K8S技术栈打造个人私有云连载文章</a></li>
<li><a href="https://www.jianshu.com/p/9e47ffaf5e31" target="_blank" rel="noopener">Docker容器可视化监控中心搭建</a></li>
<li><a href="https://www.jianshu.com/p/a40c36beee63" target="_blank" rel="noopener">利用ELK搭建Docker容器化应用日志中心</a></li>
<li><a href="https://www.jianshu.com/p/e9ce05b44150" target="_blank" rel="noopener">Spring Boot应用监控实战</a></li>
</ul>
<p>作者更多的原创文章：<a href="https://www.jianshu.com/u/d19536b0189b" target="_blank" rel="noopener">在此</a></p>
<hr>
<hr>
<p>最后附上个人联系方式，欢迎大家交流学习：<br>个人博客：www.hansonwang99.com.cn<br>个人网站：<a href="http://113.209.119.170/" target="_blank" rel="noopener">http://113.209.119.170/</a> （捂脸的表情，很慢，1G 1M 1核的云主机上）<br>简    书：<a href="https://www.jianshu.com/u/d19536b0189b" target="_blank" rel="noopener">https://www.jianshu.com/u/d19536b0189b</a></p>
<p><img src="https://hansonwang99.github.io/img/wechat_qrcode.jpg" title="欢迎扫描我的二维码！"></p>
]]></content>
      
        <categories>
            
            <category> 函数式编程实践录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 函数式编程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Nginx服务器开箱体验]]></title>
      <url>/2018/05/25/Nginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E7%AE%B1%E4%BD%93%E9%AA%8C/</url>
      <content type="html"><![CDATA[<p>Nginx系列实践文章</p>
<a id="more"></a>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-c51f55d65a82fcb3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="profile"></p>
<hr>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Nginx是高性能的轻量级WEB服务器，由于其提供HTTP代理和反向代理、负载均衡、缓存等一系列重要特性，从而广泛应用于当今的WEB服务之中，学习其很有必要。笔者也是从一个初学者开始学习并记录，希望后续渐渐深入。</p>
<blockquote>
<p>对了，为什么不用Docker来启动Nginx呢？因为不想啊！</p>
</blockquote>
<hr>
<h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h1><ul>
<li>CentOS 7.4 64Bit</li>
<li>Nginx 1.14.0 稳定版</li>
</ul>
<hr>
<h1 id="下载Nginx"><a href="#下载Nginx" class="headerlink" title="下载Nginx"></a>下载Nginx</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.14.0.tar.gz</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h1><ul>
<li><strong>安装第三方库</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel</span><br><span class="line">yum -y install pcre-devel</span><br></pre></td></tr></table></figure>
<p>安装成功以后可以查看pcre版本： <code>pcre-config —version</code></p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-7f466ae3fe97a45f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查看pcre版本"></p>
<ul>
<li><strong>解压安装包</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf nginx-1.14.0.tar.gz</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>从configure脚本自动生成Makefile</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /root/nginx-1.14.0</span><br><span class="line">./configure --prefix=/usr/local/webserver/nginx</span><br></pre></td></tr></table></figure>
<p>这里的 <code>—prefix</code> 选项是指定Nginx的安装路径，这里我是指定安装到路径：<code>/usr/local/webserver/nginx</code></p>
<ul>
<li><strong>编译安装</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /root/nginx-1.14.0</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p>编译安装过程如下，直到完成</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-6c4b48ead25e3fb1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编译安装过程如下"></p>
<ul>
<li><strong>查看Nginx版本</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/webserver/nginx/sbin/nginx -v</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-85872da7f4ed3cfe.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查看Nginx版本"></p>
<ul>
<li><strong>查看安装后的目录</strong></li>
</ul>
<p>总共四个目录：<code>conf</code>、<code>html</code>、<code>logs</code>、<code>sbin</code></p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-54bb7f63e3067821.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查看安装后的目录"></p>
<hr>
<h1 id="启动Nginx"><a href="#启动Nginx" class="headerlink" title="启动Nginx"></a>启动Nginx</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/webserver/nginx/sbin/nginx</span><br></pre></td></tr></table></figure>
<p>浏览器访问Nginx成功（注意：由于我的机子上80端口被占用了，因此我将Nginx起在81端口上了）：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-32e1b2d96634d3e0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="浏览器访问成功"></p>
<hr>
<h1 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h1><ul>
<li>测试nginx测试文件是否正确</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/webserver/nginx/sbin/nginx -t</span><br></pre></td></tr></table></figure>
<ul>
<li>指定配置文件启动</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/webserver/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure>
<ul>
<li>重启nginx</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/webserver/nginx/sbin/nginx -s reload            # 重新载入配置文件</span><br><span class="line">/usr/local/webserver/nginx/sbin/nginx -s reopen          #重启 Nginx</span><br></pre></td></tr></table></figure>
<ul>
<li>停止nginx</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/webserver/nginx/sbin/nginx -s stop              # 停止 Nginx</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Nginx服务器配置实例与实验"><a href="#Nginx服务器配置实例与实验" class="headerlink" title="Nginx服务器配置实例与实验"></a>Nginx服务器配置实例与实验</h1><p>准备配置文件 <code>nginx.conf</code> 如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">// 全局配置</span><br><span class="line">user  nobody  nobody;</span><br><span class="line">worker_processes  3;</span><br><span class="line">error_log  logs/error.log;</span><br><span class="line">pid  logs/nginx.pid;</span><br><span class="line"></span><br><span class="line">// events块配置</span><br><span class="line">events &#123;</span><br><span class="line">    use epoll;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// http块配置</span><br><span class="line">http &#123;</span><br><span class="line">    include  mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request” &apos;</span><br><span class="line">                      &apos;$status $body_bytes_sent &quot;$http_referer” &apos;</span><br><span class="line">                      &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for”’;</span><br><span class="line"></span><br><span class="line">    access_log  logs/access.log  main;</span><br><span class="line">    sendfile  on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    // 虚拟主机1：基于域名codesheep.com</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       8088;</span><br><span class="line">        server_name  codesheep;</span><br><span class="line"></span><br><span class="line">        access_log  /codesheep/webserver/server1/log/access.log;</span><br><span class="line">        error_page  404  /404.html;</span><br><span class="line"></span><br><span class="line">        location /server1/location1 &#123;</span><br><span class="line">            root   /codesheep/webserver;</span><br><span class="line">            index  index.server1-location1.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location /server1/location2 &#123;</span><br><span class="line">            root   /codesheep/webserver;</span><br><span class="line">            index  index.server1-location2.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 虚拟主机2：基于IP地址：192.168.31.177</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       8089;</span><br><span class="line">        server_name  192.168.31.177;</span><br><span class="line"></span><br><span class="line">        access_log  /codesheep/webserver/server2/log/access.log;</span><br><span class="line">        error_page  404  /404.html;</span><br><span class="line"></span><br><span class="line">        location /server2/location1 &#123;</span><br><span class="line">            root   /codesheep/webserver;</span><br><span class="line">            index  index.server2-location1.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location /srv2/loc2 &#123;</span><br><span class="line">            alias   /codesheep/webserver/server2/location2/;</span><br><span class="line">            index  index.server2-location2.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location = /404.html &#123;</span><br><span class="line">            root /codesheep/webserver/;</span><br><span class="line">            index 404.html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显，在上述配置文件中配置了两个虚拟主机：一个 <strong>基于域名</strong> 、 <strong>一个基于IP地址</strong> </p>
<p>为了验证该配置的正确性，我们对照此配置，构建一个与其对应的静态站点，其目录结构如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-32235a73aa70a450.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="站点结构"></p>
<p>现在可以启动Nginx服务器，并在浏览器中进行测试</p>
<ul>
<li><strong>测试站点server1的访问</strong></li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-70a851c2d58d0867.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="server1/location1"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-7817c56896b7d87b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="server1/location2"></p>
<p>这就说明配置文件中虚拟主机1配置生效！</p>
<blockquote>
<p>注意：这里域名www.codesheep.com之所以能被解析识别，是因为本地配置了DNS服务器！</p>
</blockquote>
<ul>
<li><strong>测试站点server2的访问</strong></li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-b16494d0afb6a78f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="server2/location1"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-092eb255136f259e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="srv2/loc2"></p>
<p>这就说明配置文件中虚拟主机2配置生效！</p>
<hr>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>如果有兴趣，可以看看作者一些关于容器化、微服务化方面的文章：</p>
<ul>
<li><a href="https://www.jianshu.com/p/52fa63b222ac" target="_blank" rel="noopener">RPC框架实践之：Apache Thrift</a> </li>
<li><a href="https://www.jianshu.com/p/da80ea881424" target="_blank" rel="noopener">微服务调用链追踪中心搭建</a></li>
<li><a href="https://www.jianshu.com/p/9bc87b5380e8" target="_blank" rel="noopener">利用K8S技术栈打造个人私有云连载文章</a></li>
<li><a href="https://www.jianshu.com/p/9e47ffaf5e31" target="_blank" rel="noopener">Docker容器可视化监控中心搭建</a></li>
<li><a href="https://www.jianshu.com/p/a40c36beee63" target="_blank" rel="noopener">利用ELK搭建Docker容器化应用日志中心</a></li>
<li><a href="https://www.jianshu.com/p/e9ce05b44150" target="_blank" rel="noopener">Spring Boot应用监控实战</a></li>
</ul>
<p>作者更多的原创文章：<a href="https://www.jianshu.com/u/d19536b0189b" target="_blank" rel="noopener">在此</a></p>
<hr>
<hr>
<p>最后附上个人联系方式，欢迎大家交流学习：<br>个人博客：www.hansonwang99.com.cn<br>个人网站：<a href="http://113.209.119.170/" target="_blank" rel="noopener">http://113.209.119.170/</a> （捂脸的表情，很慢，1G 1M 1核的云主机上）<br>简    书：<a href="https://www.jianshu.com/u/d19536b0189b" target="_blank" rel="noopener">https://www.jianshu.com/u/d19536b0189b</a></p>
<p><img src="https://hansonwang99.github.io/img/wechat_qrcode.jpg" title="欢迎扫描我的二维码！"></p>
]]></content>
      
        <categories>
            
            <category> Nginx实践录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RPC框架实践之：Google_gRPC]]></title>
      <url>/2018/05/21/RPC%E6%A1%86%E6%9E%B6%E5%AE%9E%E8%B7%B5%E4%B9%8B%EF%BC%9AGoogle-gRPC/</url>
      <content type="html"><![CDATA[<p>gRPC是Google开源的通用高性能RPC框架，它支持的是使用Protocol Buffers来编写Service定义，支持较多语言扩平台并且拥有强大的二进制序列化工具集。与文章《RPC框架实践之：Apache Thrift》 一文中实践的另一种通用RPC框架 Thrift 能通过Generator自动生成对应语言的Service接口类似，gRPC也能 自动地生成 Server和Client的 Service存根（Stub），我们只需要 一个命令 就能快速搭建起RPC运行环境。</p>
<a id="more"></a>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-87bc1d746154471c.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="My Desktop"></p>
<hr>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>gRPC是Google开源的通用高性能RPC框架，它支持的是使用<strong>Protocol Buffers</strong>来编写Service定义，支持较多语言扩平台并且拥有强大的二进制序列化工具集。与文章<a href="https://www.jianshu.com/p/52fa63b222ac" target="_blank" rel="noopener">《RPC框架实践之：Apache Thrift》</a> 一文中实践的另一种通用RPC框架 <strong>Thrift</strong> 能通过Generator自动生成对应语言的Service接口类似，gRPC也能 <strong>自动地生成</strong> Server和Client的 <strong>Service存根（Stub）</strong>，我们只需要 <strong>一个命令</strong> 就能快速搭建起RPC运行环境。</p>
<p>下面实践一下gRPC框架，做的事情就是：Client端通过远程RPC调用Server的获取时间的接口，从而将服务器时间获取到本地并显示。</p>
<p>类似于之前对于 <a href="https://www.jianshu.com/p/52fa63b222ac" target="_blank" rel="noopener">RPC框架: Thrift</a> 的实践步骤，下面一一阐述。</p>
<hr>
<h2 id="开发gRPC-API"><a href="#开发gRPC-API" class="headerlink" title="开发gRPC-API"></a>开发gRPC-API</h2><ul>
<li><p><strong>首先创建一个基于Maven的项目：  GrpcAPI</strong></p>
</li>
<li><p><strong>pom中加入grpc相关的依赖</strong></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.grpc&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;grpc-all&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.12.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>这个grpc-all包含了很多grpc相关的组件：<strong>grpc-netty 、 grpc-protobuf 、grpc-stub</strong> 等等</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-fe58ffbf79553f60.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="与grpc相关的包"></p>
<ul>
<li><strong>pom中加入grpc相关的 build插件</strong></li>
</ul>
<p>这里添加两个Maven插件，目的是后面需要用这些插件来执行Protocol Buffers命令，从而自动生成相关的Stub代码：</p>
<p><code>os-maven-plugin</code>：生成平台无关的属性<br><code>protobuf-maven-plugin</code>：执行Protocol Buffers命令并生成Stub代码库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;extensions&gt;</span><br><span class="line">        &lt;extension&gt;</span><br><span class="line">            &lt;groupId&gt;kr.motd.maven&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;os-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.4.1.Final&lt;/version&gt;</span><br><span class="line">        &lt;/extension&gt;</span><br><span class="line">    &lt;/extensions&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.xolstice.maven.plugins&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;protobuf-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;0.5.0&lt;/version&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;pluginId&gt;grpc-java&lt;/pluginId&gt;</span><br><span class="line">                &lt;protocArtifact&gt;com.google.protobuf:protoc:3.0.2:exe:$&#123;os.detected.classifier&#125;&lt;/protocArtifact&gt;</span><br><span class="line">                &lt;pluginArtifact&gt;io.grpc:protoc-gen-grpc-java:1.2.0:exe:$&#123;os.detected.classifier&#125;&lt;/pluginArtifact&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">            &lt;executions&gt;</span><br><span class="line">                &lt;execution&gt;</span><br><span class="line">                    &lt;goals&gt;</span><br><span class="line">                        &lt;goal&gt;compile&lt;/goal&gt;</span><br><span class="line">                        &lt;goal&gt;compile-custom&lt;/goal&gt;</span><br><span class="line">                    &lt;/goals&gt;</span><br><span class="line">                &lt;/execution&gt;</span><br><span class="line">            &lt;/executions&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>编写.proto的服务定义文件</strong></li>
</ul>
<p>这里.proto文件的作用和写法就和我的前一篇文章<a href="https://www.jianshu.com/p/52fa63b222ac" target="_blank" rel="noopener">《RPC框架实践之：Apache Thrift》</a> 一文中Thrift所要求的.thrift文件编写一样，是有其自己的语法要求的！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3”;   // 语法版本</span><br><span class="line"></span><br><span class="line">// stub选项</span><br><span class="line">option java_package = &quot;com.hansonwang99.grpc.api”;</span><br><span class="line">option java_outer_classname = “RPCDateServiceApi”;</span><br><span class="line">option java_multiple_files = true;</span><br><span class="line"></span><br><span class="line">// 定义包名，类似于我的文章《RPC框架实践之：Apache Thrift》中的Thrift的namespace</span><br><span class="line">package com.hansonwang99.grpc.api;</span><br><span class="line"></span><br><span class="line">// 服务接口定义，服务端和客户端都要遵守该接口进行通信</span><br><span class="line">service RPCDateService &#123;</span><br><span class="line">  rpc getDate (RPCDateRequest) returns (RPCDateResponse) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义消息（请求）</span><br><span class="line">message RPCDateRequest &#123;</span><br><span class="line">  string userName = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义消息（响应）</span><br><span class="line">message RPCDateResponse &#123;</span><br><span class="line">  string serverDate = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>执行<code>mvn compile</code>命令来自动生成代码Stub</strong></li>
</ul>
<p>mvn编译完成以后，在<code>target/generated-sources</code>目录下就能看到根据上面<code>.proto</code>文件自动转化生成的<code>Java代码Stub</code></p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-3aaac1437d7ca63b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="mvn编译"></p>
<p>代码生成结果如下所示</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-815a2ade15135e85.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="代码生成结果"></p>
<p>好了，既然gRPC-API已经有了，下面可以分别编写服务端和客户端</p>
<hr>
<h2 id="开发gRPC服务端"><a href="#开发gRPC服务端" class="headerlink" title="开发gRPC服务端"></a>开发gRPC服务端</h2><ul>
<li><p><strong>创建基于Maven的项目：Server</strong></p>
</li>
<li><p><strong>pom中添加 GrpcAPI 依赖</strong></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.hansonwang99&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;GrpcAPI&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>接下来一步比较关键</p>
<ul>
<li><strong>实现gRPC服务接口</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class RPCDateServiceImpl extends RPCDateServiceGrpc.RPCDateServiceImplBase&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void getDate(RPCDateRequest request, StreamObserver&lt;RPCDateResponse&gt; responseObserver) &#123;</span><br><span class="line">        RPCDateResponse rpcDateResponse = null;</span><br><span class="line">        Date now=new Date();</span><br><span class="line">        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;今天是&quot;+&quot;yyyy年MM月dd日 E kk点mm分”);</span><br><span class="line">        String nowTime = simpleDateFormat.format( now );</span><br><span class="line">        try &#123;</span><br><span class="line">            rpcDateResponse = RPCDateResponse</span><br><span class="line">                    .newBuilder()</span><br><span class="line">                    .setServerDate( &quot;Welcome &quot; + request.getUserName()  + &quot;, &quot; + nowTime )</span><br><span class="line">                    .build();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            responseObserver.onError(e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            responseObserver.onNext( rpcDateResponse );</span><br><span class="line">        &#125;</span><br><span class="line">        responseObserver.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我想此处重写的<code>getDate()</code>方法并不陌生吧，这正是上文 <strong>.proto</strong> 文件中定义的Service接口。<br>此处逻辑比较简单：获取当前时间，并且将其与请求<code>RPCDateRequest</code>中提取出的<code>userName</code>字段进行拼接，然后返回给调用端！形成一个闭环</p>
<ul>
<li><strong>创建gRPC服务端启动类</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class GRPCServer &#123;</span><br><span class="line">    private static final int port = 9999;</span><br><span class="line">    public static void main( String[] args ) throws Exception &#123;</span><br><span class="line">        Server server = ServerBuilder.</span><br><span class="line">                forPort(port)</span><br><span class="line">                .addService( new RPCDateServiceImpl() )</span><br><span class="line">                .build().start();</span><br><span class="line">        System.out.println( &quot;grpc服务端启动成功, 端口=&quot; + port );</span><br><span class="line">        server.awaitTermination();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>端口自定义的9999，也就是在该端口监听。现在可以立即运行GRPCServer，来启动服务端</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-dcf4f8212b0b6d9e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="启动服务端"></p>
<hr>
<h2 id="开发gRPC客户端"><a href="#开发gRPC客户端" class="headerlink" title="开发gRPC客户端"></a>开发gRPC客户端</h2><ul>
<li><p><strong>创建基于Maven的项目：Client</strong></p>
</li>
<li><p><strong>pom中依然需要添加 GrpcAPI 依赖</strong></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.hansonwang99&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;GrpcAPI&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>创建gRPC客户端启动类</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class GRPCClient &#123;</span><br><span class="line">    private static final String host = “localhost”;</span><br><span class="line">    private static final int serverPort = 9999;</span><br><span class="line"></span><br><span class="line">    public static void main( String[] args ) throws Exception &#123;</span><br><span class="line">        ManagedChannel managedChannel = ManagedChannelBuilder.forAddress( host, serverPort ).usePlaintext().build();</span><br><span class="line">        try &#123;</span><br><span class="line">            RPCDateServiceGrpc.RPCDateServiceBlockingStub rpcDateService = RPCDateServiceGrpc.newBlockingStub( managedChannel );</span><br><span class="line">            RPCDateRequest  rpcDateRequest = RPCDateRequest</span><br><span class="line">                    .newBuilder()</span><br><span class="line">                    .setUserName(“hansonwang99”)</span><br><span class="line">                    .build();</span><br><span class="line">            RPCDateResponse rpcDateResponse = rpcDateService.getDate( rpcDateRequest );</span><br><span class="line">            System.out.println( rpcDateResponse.getServerDate() );</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            managedChannel.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在立即启动 GRPCClient！</p>
<hr>
<h2 id="C-S通信实验"><a href="#C-S通信实验" class="headerlink" title="C-S通信实验"></a>C-S通信实验</h2><p>还记得我们的目标吗？</p>
<p>RPC完成的即是远程的过程调用，在本实验中那就是客户端可以远程调用服务端的getDate()过程，并将结果取到客户端来显示！</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-c1d581b8008f73ea.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RPC调用成功"></p>
<hr>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>本文实验代码在此 → <a href="https://gitee.com/hansonwang99/Maven_gRPC" target="_blank" rel="noopener">需要自取</a></p>
<p>作者其他一些RPC框架的实践如下：</p>
<ul>
<li><a href="https://www.jianshu.com/p/52fa63b222ac" target="_blank" rel="noopener">RPC框架实践之：Apache Thrift</a> </li>
</ul>
<p>作者一些关于容器化、微服务化方面的文章如下：</p>
<ul>
<li><a href="https://www.jianshu.com/p/da80ea881424" target="_blank" rel="noopener">微服务调用链追踪中心搭建</a></li>
<li><a href="https://www.jianshu.com/p/9bc87b5380e8" target="_blank" rel="noopener">利用K8S技术栈打造个人私有云连载文章</a></li>
<li><a href="https://www.jianshu.com/p/9e47ffaf5e31" target="_blank" rel="noopener">Docker容器可视化监控中心搭建</a></li>
<li><a href="https://www.jianshu.com/p/a40c36beee63" target="_blank" rel="noopener">利用ELK搭建Docker容器化应用日志中心</a></li>
<li><p><a href="https://www.jianshu.com/p/e9ce05b44150" target="_blank" rel="noopener">Spring Boot应用监控实战</a></p>
<p>作者更多的原创文章：<a href="https://www.jianshu.com/u/d19536b0189b" target="_blank" rel="noopener">在此</a></p>
</li>
</ul>
<hr>
<hr>
<p>最后附上个人联系方式，欢迎大家交流学习：<br>个人博客：www.hansonwang99.com.cn<br>个人网站：<a href="http://113.209.119.170/" target="_blank" rel="noopener">http://113.209.119.170/</a> （捂脸的表情，很慢，1G 1M 1核的云主机上）<br>简    书：<a href="https://www.jianshu.com/u/d19536b0189b" target="_blank" rel="noopener">https://www.jianshu.com/u/d19536b0189b</a></p>
<p><img src="https://hansonwang99.github.io/img/wechat_qrcode.jpg" title="欢迎扫描我的二维码！"></p>
<hr>
]]></content>
      
        <categories>
            
            <category> RPC实践录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> RPC </tag>
            
            <tag> gRPC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RPC框架实践之：Apache_Thrift]]></title>
      <url>/2018/05/14/RPC%E6%A1%86%E6%9E%B6%E5%AE%9E%E8%B7%B5%E4%B9%8B%EF%BC%9AApache-Thrift/</url>
      <content type="html"><![CDATA[<p>RPC（Remote Procedure Call）即 远程过程调用，说的这么抽象，其实简化理解就是一个节点如何请求另一节点所提供的服务。在文章 微服务调用链追踪中心搭建 一文中模拟出来的调用链：ServiceA —&gt; ServiceB —&gt; ServiceC 就是一个远程调用的例子，只不过这篇文章里是通过RestTemplate这种 同步调用方式，利用的是HTTP协议在应用层完成的，这种方法虽然奏效，但有时效率并不高。而RPC可以不依赖于应用层协议，可以直接基于TCP进行远程调用，在传输层中即可完成通信，因此更适于某些对效率要求更高的场景。由于RPC调用方式依赖于客户端与服务端之间建立Socket连接来实现二进制数据通信，底层会比较复杂，所以一些RPC框架应运而生来封装这种复杂性，让开发者将精力聚焦于业务之上。常见的RPC框架包括：Thrift、gRPC、Finagle、Dubbo等等，从本文开始作者将选一些实践一下，本文主要记录作者对于Thrift框架的实践过程。</p>
<a id="more"></a>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-c3876396b1aec866.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="我的桌面"></p>
<hr>
<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>RPC（Remote Procedure Call）即  <strong>远程过程调用</strong>，说的这么抽象，其实简化理解就是一个节点如何请求另一节点所提供的服务。在文章 <a href="https://www.jianshu.com/p/da80ea881424" target="_blank" rel="noopener">微服务调用链追踪中心搭建</a> 一文中模拟出来的调用链：<strong>ServiceA —&gt; ServiceB —&gt; ServiceC</strong> 就是一个远程调用的例子，只不过这篇文章里是通过<code>RestTemplate</code>这种 <strong>同步调用方式</strong>，利用的是HTTP协议在应用层完成的，这种方法虽然奏效，但有时效率并不高。而RPC可以不依赖于应用层协议，可以直接基于TCP进行远程调用，在传输层中即可完成通信，因此更适于某些对效率要求更高的场景。由于RPC调用方式依赖于客户端与服务端之间建立Socket连接来实现二进制数据通信，底层会比较复杂，所以一些RPC框架应运而生来封装这种复杂性，让开发者将精力聚焦于业务之上。常见的RPC框架包括：Thrift、gRPC、Finagle、Dubbo等等，从本文开始作者将选一些实践一下，本文主要记录作者对于Thrift框架的实践过程。</p>
<p>Thrift是Apache的项目，它结合了功能强大的软件堆栈和代码生成引擎，可以在诸多语言之间提供无缝支持。</p>
<p>心动不如行动吧！</p>
<hr>
<h2 id="二、实验环境"><a href="#二、实验环境" class="headerlink" title="二、实验环境"></a>二、实验环境</h2><ul>
<li>Mac OS X 10.13.2</li>
<li>SpringBoot 2.0.1</li>
<li>Thrift 0.11.0</li>
<li>IDE：IntelliJ IDEA 2018.01</li>
</ul>
<hr>
<p><strong>为了便于读者理解，我先将下文内容总结一下，包含7点：</strong></p>
<blockquote>
<ul>
<li>Thrift环境搭建</li>
<li>IDEA中Thrift插件配置</li>
<li>创建 Thrift 项目并编译（目的：定义RPC接口）</li>
<li>开发Thrift API接口</li>
<li>开发RPC服务端</li>
<li>开发RPC客户端</li>
<li>RPC通信实际实验</li>
</ul>
</blockquote>
<hr>
<h2 id="三、Thrift环境搭建"><a href="#三、Thrift环境搭建" class="headerlink" title="三、Thrift环境搭建"></a>三、Thrift环境搭建</h2><ul>
<li><strong>方法一：</strong>原生安装方式，通过官方提供的步骤一步一步来安装</li>
</ul>
<p>参考这里：<a href="http://thrift.apache.org/docs/install/os_x" target="_blank" rel="noopener">Mac上Thrift官方安装教程</a></p>
<ul>
<li><strong>方法二：</strong>使用 brew 工具（<strong>推荐</strong>）</li>
</ul>
<p><code>brew install thrift</code></p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-7a2526fdf3af4954.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="brew install thrift"></p>
<hr>
<h2 id="四、IDEA中Thrift插件配置"><a href="#四、IDEA中Thrift插件配置" class="headerlink" title="四、IDEA中Thrift插件配置"></a>四、IDEA中Thrift插件配置</h2><p><strong>方法一：直接在IDEA界面中配置</strong></p>
<p>打开IDEA的插件中心，搜索 <strong>Thrift</strong> 即可安装</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-8048dd55dc8c2a96.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="利用插件中心安装Thrift"></p>
<p><strong>方法二：手动下载Thrift插件安装</strong></p>
<p>就像文章 <a href="https://www.jianshu.com/p/c88b0f17f62a" target="_blank" rel="noopener">SpringBoot优雅编码之：Lombok加持</a> 一文中在IDEA中安装Lombok插件一样，有时由于网络原因，方法一不奏效时插件装不上，此时可以手动下载插件并安装。</p>
<p>可以去如下地址下载Thrift插件：<a href="http://plugins.jetbrains.com/plugin/7331-thrift-support" target="_blank" rel="noopener">http://plugins.jetbrains.com/plugin/7331-thrift-support</a></p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-ebeac88308851820.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="手动下载Thrift插件"></p>
<p>然后去IDEA中 <strong>Install plugin from disk…</strong>  选择下载的zip包安装，然后重启IDE即可</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-71c395fa4c674654?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Install plugin from disk"></p>
<p>安装完成的成功标志是 <strong>Compiler</strong> 中出现了 <strong>Thrift编译器</strong>！如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-2dc5a3d36e12f389.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="成功安装Thrift插件"></p>
<hr>
<h2 id="五、创建-Thrift-项目并编译（定义RPC接口）"><a href="#五、创建-Thrift-项目并编译（定义RPC接口）" class="headerlink" title="五、创建 Thrift 项目并编译（定义RPC接口）"></a>五、创建 Thrift 项目并编译（定义RPC接口）</h2><ul>
<li><strong>第一步：创建Thrift项目并配置</strong></li>
</ul>
<p>IDE 很智能地在 <strong>New Project</strong> 时提供 Thrift项目创建选项：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-5ec83affe4c4c951.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Thrift项目创建选项"></p>
<p>项目创建完成以后，在 <strong>Project Settings</strong> 中设置好 <strong>Facets</strong> 的 Thrift配置，如下图所示，这里我们添加一个 <strong>Java的Generator</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-68155ce0a833497f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加一个Java的Generator"></p>
<p>在弹出的对话框中配置好 <strong>Output folder</strong> 路径，该路径用于存放由 <strong>thrift文件</strong> 转化而成的 <strong>java源文件</strong>：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-2adf27bcd8776a20.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配置好Output folder"></p>
<p>OK，Thrift项目就绪了！</p>
<ul>
<li><strong>第二步：创建thrift接口文件</strong></li>
</ul>
<p>这里创建一个thrift接口文件：<code>RPCDateService.thrift</code></p>
<p>thrift文件的写法我不赘述，跟gRPC一样有其自己的语法，namespace是最后生成的接口文件的包名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">namespace java com.hansonwang99.thrift.interface</span><br><span class="line">service RPCDateService&#123;</span><br><span class="line">    string getDate(1:string userName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该接口文件中，我们定义了一个 <strong>提供日期的Service</strong>，让客户端能通过该接口查询到服务器当前的时间</p>
<ul>
<li><strong>第三步：编译Thrift源文件生成Java接口类</strong></li>
</ul>
<p>右击.thrift源文件，点击 <strong>Recompile ‘xxx.thrift’</strong> 即可完成 <strong>thrift接口文件 —&gt; java接口文件</strong> 的转换</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-b86c05032774f37e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Recompile &#39;xxx.thrift&#39;"></p>
<p>输出的Java接口文件生成于上文中配置的 <strong>output</strong> 中，其 <strong>包结构=上文.thrift文件中的namespace</strong> ，其包结构如下图所示，该Java接口十分重要，后续会用于实现Client和Server之间的RPC调用。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-d382d50717c34cab.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="输出的.java文件"></p>
<hr>
<h2 id="六、开发Thrift-API接口"><a href="#六、开发Thrift-API接口" class="headerlink" title="六、开发Thrift API接口"></a>六、开发Thrift API接口</h2><p>我们创建一个Maven项目：<strong>ThriftAPI</strong>，其包含的的就是上文由自定义Thrift接口生成的Java接口：<code>RPCDateService.java</code> 文件，该文件将用于后面的RPC服务端和RPC客户端的代码实现！</p>
<ul>
<li><strong>pom.xml中添加thrift依赖</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.thrift&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;libthrift&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;0.11.0&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>添加RPCDateService.java</strong></li>
</ul>
<p>将上文 <strong>第五步</strong> 由 <strong>RPCDateService.thrift</strong> 生成的 <strong>RPCDateService.java</strong> 原样拷贝到该Maven项目中即可，代码结构如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-d032c0f285a4204c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ThriftAPI代码结构"></p>
<p>再次强调，该 <strong>ThriftAPI项目</strong> 会服务于下文即将要创建的RPC服务端和RPC客户端</p>
<hr>
<h2 id="七、开发RPC服务端"><a href="#七、开发RPC服务端" class="headerlink" title="七、开发RPC服务端"></a>七、开发RPC服务端</h2><p>我们是利用SpringBoot来实现RPC服务端</p>
<ul>
<li><strong>pom.xml中添加依赖</strong></li>
</ul>
<p>这里除了自动添加好的SpringBoot依赖外，需要额外添加的就是上文的 <strong>ThriftAPI依赖</strong> 了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.hansonwang99&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;ThriftAPI&lt;/artifactId&gt;</span><br><span class="line">         &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>创建Controller并实现RPC接口</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class RPCDateServiceImpl implements RPCDateService.Iface &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String getDate(String userName) throws TException &#123;</span><br><span class="line">        Date now=new Date();</span><br><span class="line">        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;今天是&quot;+&quot;yyyy年MM月dd日 E kk点mm分&quot;);</span><br><span class="line">        String nowTime = simpleDateFormat.format( now );</span><br><span class="line">        return &quot;Hello &quot; + userName + &quot;\n&quot; + nowTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里将服务器当前时间以字符串形式返回给调用端！</p>
<ul>
<li><strong>编写RPCThriftServer：用于启动RPC服务器</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class RPCThriftServer &#123;</span><br><span class="line">    protected final Logger logger = LoggerFactory.getLogger(this.getClass());</span><br><span class="line">    @Value(&quot;$&#123;thrift.port&#125;&quot;)</span><br><span class="line">    private int port;</span><br><span class="line">    @Value(&quot;$&#123;thrift.minWorkerThreads&#125;&quot;)</span><br><span class="line">    private int minThreads;</span><br><span class="line">    @Value(&quot;$&#123;thrift.maxWorkerThreads&#125;&quot;)</span><br><span class="line">    private int maxThreads;</span><br><span class="line"></span><br><span class="line">    private TBinaryProtocol.Factory protocolFactory;</span><br><span class="line">    private TTransportFactory transportFactory;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RPCDateServiceImpl rpcDateService;</span><br><span class="line"></span><br><span class="line">    public void init() &#123;</span><br><span class="line">        protocolFactory = new TBinaryProtocol.Factory();</span><br><span class="line">        transportFactory = new TTransportFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void start() &#123;</span><br><span class="line">        RPCDateService.Processor processor = new RPCDateService.Processor&lt;RPCDateService.Iface&gt;( rpcDateService );</span><br><span class="line">        init();</span><br><span class="line">        try &#123;</span><br><span class="line">            TServerTransport transport = new TServerSocket(port);</span><br><span class="line">            TThreadPoolServer.Args tArgs = new TThreadPoolServer.Args(transport);</span><br><span class="line">            tArgs.processor(processor);</span><br><span class="line">            tArgs.protocolFactory(protocolFactory);</span><br><span class="line">            tArgs.transportFactory(transportFactory);</span><br><span class="line">            tArgs.minWorkerThreads(minThreads);</span><br><span class="line">            tArgs.maxWorkerThreads(maxThreads);</span><br><span class="line">            TServer server = new TThreadPoolServer(tArgs);</span><br><span class="line">            logger.info(&quot;thrift服务启动成功, 端口=&#123;&#125;&quot;, port);</span><br><span class="line">            server.serve();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.error(&quot;thrift服务启动失败&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>创建SpringBootApplication</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class RPCThriftServerApplication &#123;</span><br><span class="line">    private static RPCThriftServer rpcThriftServer;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext context = SpringApplication.run(RPCThriftServerApplication.class, args);</span><br><span class="line">        try &#123;</span><br><span class="line">            rpcThriftServer = context.getBean(RPCThriftServer.class);</span><br><span class="line">            rpcThriftServer.start();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>添加配置文件application.properties</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thrift.port=6666</span><br><span class="line">thrift.minWorkerThreads=10</span><br><span class="line">thrift.maxWorkerThreads=100</span><br></pre></td></tr></table></figure>
<p>我们让thrift服务起在6666端口！</p>
<ul>
<li><strong>启动RPC服务端服务</strong></li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-17d1ee8ef49c2ab7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RPC服务端启动成功"></p>
<hr>
<h2 id="八、开发RPC客户端"><a href="#八、开发RPC客户端" class="headerlink" title="八、开发RPC客户端"></a>八、开发RPC客户端</h2><p>这里同样用SpringBoot来实现RPC客户端！</p>
<ul>
<li><p><strong>pom.xml中添加依赖</strong></p>
<p>   此处同RPC服务端依赖，不赘述</p>
</li>
<li><p><strong>编写RPCThriftClient：用于发出RPC调用</strong></p>
</li>
</ul>
<p>这里包含两个文件：<code>RPCThriftClient.java</code> 和 <code>RPCThriftClientConfig.java</code></p>
<p><code>RPCThriftClient.java</code>如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class RPCThriftClient &#123;</span><br><span class="line">    private RPCDateService.Client client;</span><br><span class="line">    private TBinaryProtocol protocol;</span><br><span class="line">    private TSocket transport;</span><br><span class="line">    private String host;</span><br><span class="line">    private int port;</span><br><span class="line"></span><br><span class="line">    public String getHost() &#123;</span><br><span class="line">        return host;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setHost(String host) &#123;</span><br><span class="line">        this.host = host;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getPort() &#123;</span><br><span class="line">        return port;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setPort(int port) &#123;</span><br><span class="line">        this.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void init() &#123;</span><br><span class="line">        transport = new TSocket(host, port);</span><br><span class="line">        protocol = new TBinaryProtocol(transport);</span><br><span class="line">        client = new RPCDateService.Client(protocol);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public RPCDateService.Client getRPCThriftService() &#123;</span><br><span class="line">        return client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void open() throws TTransportException &#123;</span><br><span class="line">        transport.open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void close() &#123;</span><br><span class="line">        transport.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而<code>RPCThriftClientConfig.java</code>是利用config生成bean</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class RPCThriftClientConfig &#123;</span><br><span class="line">    @Value(&quot;$&#123;thrift.host&#125;&quot;)</span><br><span class="line">    private String host;</span><br><span class="line">    @Value(&quot;$&#123;thrift.port&#125;&quot;)</span><br><span class="line">    private int port;</span><br><span class="line"></span><br><span class="line">    @Bean(initMethod = &quot;init&quot;)</span><br><span class="line">    public RPCThriftClient rpcThriftClient() &#123;</span><br><span class="line">        RPCThriftClient rpcThriftClient = new RPCThriftClient();</span><br><span class="line">        rpcThriftClient.setHost(host);</span><br><span class="line">        rpcThriftClient.setPort(port);</span><br><span class="line">        return rpcThriftClient;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>编写Restful的Controller作为调用入口</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/hansonwang99&quot;)</span><br><span class="line">public class RPCThriftContoller &#123;</span><br><span class="line">    protected final Logger logger = LoggerFactory.getLogger(this.getClass());</span><br><span class="line">    @Autowired</span><br><span class="line">    private RPCThriftClient rpcThriftClient;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value = &quot;/thrift&quot;, method = RequestMethod.GET)</span><br><span class="line">    public String thriftTest(HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            rpcThriftClient.open();</span><br><span class="line">            return rpcThriftClient.getRPCThriftService().getDate(&quot;hansonwang99&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.error(&quot;RPC调用失败&quot;, e);</span><br><span class="line">            return &quot;error&quot;;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            rpcThriftClient.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>创建SpringBootApplication</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class RPCThriftClientApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(RPCThriftClientApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>添加配置文件application.properties</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thrift.host=localhost</span><br><span class="line">thrift.port=6666</span><br><span class="line">server.port=9999</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>启动RPC客户端服务</strong></li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-03732d576a8721e5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RPC客户端启动成功"></p>
<hr>
<h2 id="九、RPC通信实验"><a href="#九、RPC通信实验" class="headerlink" title="九、RPC通信实验"></a>九、RPC通信实验</h2><p>我们浏览器输入：<code>localhost:9999/hansonwang99/thrift</code> 即可查看客户端从服务端取回的服务器当前时间，说明RPC通信过程打通！</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-df362d61134d628e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="客户端成功从服务端取回结果"></p>
<hr>
<h2 id="十、后记"><a href="#十、后记" class="headerlink" title="十、后记"></a>十、后记</h2><p>本文实验代码已开源，<a href="https://gitee.com/hansonwang99/SpringBoot_RPC_Thrift" target="_blank" rel="noopener">点击获取</a></p>
<p>作者一些其他容器化、微服务化方面的文章：</p>
<ul>
<li><a href="https://www.jianshu.com/p/da80ea881424" target="_blank" rel="noopener">微服务调用链追踪中心搭建</a></li>
<li><a href="https://www.jianshu.com/p/9bc87b5380e8" target="_blank" rel="noopener">利用K8S技术栈打造个人私有云连载文章</a></li>
<li><a href="https://www.jianshu.com/p/9e47ffaf5e31" target="_blank" rel="noopener">Docker容器可视化监控中心搭建</a></li>
<li><a href="https://www.jianshu.com/p/a40c36beee63" target="_blank" rel="noopener">利用ELK搭建Docker容器化应用日志中心</a></li>
<li><p><a href="https://www.jianshu.com/p/e9ce05b44150" target="_blank" rel="noopener">Spring Boot应用监控实战</a></p>
<p>作者更多的原创文章：<a href="https://www.jianshu.com/u/d19536b0189b" target="_blank" rel="noopener">在此</a></p>
</li>
</ul>
<hr>
<hr>
<p>最后附上个人联系方式，欢迎大家交流学习：<br>个人博客：www.hansonwang99.com.cn<br>个人网站：<a href="http://113.209.119.170/" target="_blank" rel="noopener">http://113.209.119.170/</a> （捂脸的表情，很慢，1G 1M 1核的云主机上）<br>简    书：<a href="https://www.jianshu.com/u/d19536b0189b" target="_blank" rel="noopener">https://www.jianshu.com/u/d19536b0189b</a></p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://hansonwang99.github.io/img/wechat_qrcode.jpg" title="欢迎扫描我的二维码！"></h2>]]></content>
      
        <categories>
            
            <category> RPC实践录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SpringBt </tag>
            
            <tag> RPC </tag>
            
            <tag> Thrift </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[利用Zipkin追踪Mysql数据库调用链]]></title>
      <url>/2018/05/07/%E5%88%A9%E7%94%A8Zipkin%E8%BF%BD%E8%B8%AAMysql%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B0%83%E7%94%A8%E9%93%BE/</url>
      <content type="html"><![CDATA[<p>在前面：微服务调用链追踪中心搭建 一文中我们利用Zipkin搭建了一个微服务调用链的追踪中心，并且模拟了微服务调用的实验场景。利用Zipkin的库Brave，我们可以收集一个客户端请求从发出到被响应 经历了哪些组件、哪些微服务、请求总时长、每个组件所花时长 等信息。本文将讲述如何利用Zipkin对Mysql数据库的调用进行追踪，这里同样借助OpenZipkin库Brave来完成。</p>
<a id="more"></a>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-2f04485338ca6443.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Profile"></p>
<hr>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在前面：<a href="https://www.jianshu.com/p/da80ea881424" target="_blank" rel="noopener">微服务调用链追踪中心搭建</a> 一文中我们利用Zipkin搭建了一个微服务调用链的追踪中心，并且模拟了微服务调用的实验场景。利用Zipkin的库Brave，我们可以收集一个客户端请求从发出到被响应 <strong>经历了哪些组件</strong>、<strong>哪些微服务</strong>、<strong>请求总时长</strong>、<strong>每个组件所花时长</strong> 等信息。</p>
<p>本文将讲述如何利用Zipkin对Mysql数据库的调用进行追踪，这里同样借助OpenZipkin库Brave来完成。</p>
<hr>
<h2 id="扩展ZipkinTool组件"><a href="#扩展ZipkinTool组件" class="headerlink" title="扩展ZipkinTool组件"></a>扩展ZipkinTool组件</h2><p>ZipkinTool是在<a href="https://www.jianshu.com/p/da80ea881424" target="_blank" rel="noopener">《微服务调用链追踪中心搭建》</a>一文中编写的与Zipkin通信的工具组件，利用其追踪微服务调用链的，现在我们想追踪Mysql数据库调用链的话，可以扩展一下其功能。</p>
<ul>
<li>pom.xml添加依赖：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;io.zipkin.brave&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;brave-mysql&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;4.0.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>在ZipkinConfiguration类中添加MySQLStatementInterceptorManagementBean</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public MySQLStatementInterceptorManagementBean mySQLStatementInterceptorManagementBean() &#123;</span><br><span class="line">    return new MySQLStatementInterceptorManagementBean(brave().clientTracer());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="添加Mysql数据库访问的微服务"><a href="#添加Mysql数据库访问的微服务" class="headerlink" title="添加Mysql数据库访问的微服务"></a>添加Mysql数据库访问的微服务</h2><p>依然继承前文：<a href="https://www.jianshu.com/p/da80ea881424" target="_blank" rel="noopener">《微服务调用链追踪中心搭建》</a>，我们改造一下文中的ServiceC这个微服务，在其中添加与Mysql数据库的交互。</p>
<ul>
<li>pom.xml中添加JDBC和Mysql依赖</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>application.properties中添加Mysql连接的配置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">spring.datasource.url=jdbc:mysql://你的Mysql服务所在IP:3307/test?useSSL=false\</span><br><span class="line">  &amp;statementInterceptors=com.github.kristofa.brave.mysql.MySQLStatementInterceptor\</span><br><span class="line">  &amp;zipkinServiceName=mysqlService</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=XXXXXX</span><br></pre></td></tr></table></figure>
<ul>
<li>Controller中添加JdbcTemplate访问数据库的代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;/mysqltest”)</span><br><span class="line">public String mysqlTest() &#123;</span><br><span class="line">    String name = jdbcTemplate.queryForObject( &quot;SELECT name FROM user WHERE id = 1&quot;, String.class );</span><br><span class="line">    return &quot;Welcome &quot; + name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="启动Mysql数据库服务"><a href="#启动Mysql数据库服务" class="headerlink" title="启动Mysql数据库服务"></a>启动Mysql数据库服务</h2><p><strong>1. 启动Mysql容器</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3307:3306 \</span><br><span class="line">-v ~/mysql/data:/var/lib/mysql \</span><br><span class="line">-v ~/mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=XXXXXX \</span><br><span class="line">--name mysql mysql</span><br></pre></td></tr></table></figure>
<p><strong>2. 再启动一个Mysql容器，接入其中做一些设置</strong></p>
<ul>
<li>首先进入mysql命令行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm \</span><br><span class="line">--link mysql:mysql mysql \</span><br><span class="line">mysql -hmysql -u root -p</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-4d7ab5149e4e365e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="进入Mysql的命令行"></p>
<ul>
<li>接下来创建数据库zipkin： 用于存放Zipkin所收集的数据</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="string">`zipkin`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> zipkin_spans (</span><br><span class="line">  <span class="string">`trace_id_high`</span> <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'If non zero, this means the trace uses 128 bit traceIds instead of 64 bit’,</span></span><br><span class="line"><span class="string">  `trace_id` BIGINT NOT NULL,</span></span><br><span class="line"><span class="string">  `id` BIGINT NOT NULL,</span></span><br><span class="line"><span class="string">  `name` VARCHAR(255) NOT NULL,</span></span><br><span class="line"><span class="string">  `parent_id` BIGINT,</span></span><br><span class="line"><span class="string">  `debug` BIT(1),</span></span><br><span class="line"><span class="string">  `start_ts` BIGINT COMMENT '</span>Span.timestamp(): epoch micros used <span class="keyword">for</span> endTs <span class="keyword">query</span> <span class="keyword">and</span> <span class="keyword">to</span> implement TTL’,</span><br><span class="line">  <span class="string">`duration`</span> <span class="built_in">BIGINT</span> <span class="keyword">COMMENT</span> <span class="string">'Span.duration(): micros used for minDuration and maxDuration query’</span></span><br><span class="line"><span class="string">) ENGINE=InnoDB ROW_FORMAT=COMPRESSED CHARACTER SET=utf8 COLLATE utf8_general_ci;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ALTER TABLE zipkin_spans ADD UNIQUE KEY(`trace_id_high`, `trace_id`, `id`) COMMENT '</span><span class="keyword">ignore</span> <span class="keyword">insert</span> <span class="keyword">on</span> <span class="keyword">duplicate</span>’;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> zipkin_spans <span class="keyword">ADD</span> <span class="keyword">INDEX</span>(<span class="string">`trace_id_high`</span>, <span class="string">`trace_id`</span>, <span class="string">`id`</span>) <span class="keyword">COMMENT</span> <span class="string">'for joining with zipkin_annotations’;</span></span><br><span class="line"><span class="string">ALTER TABLE zipkin_spans ADD INDEX(`trace_id_high`, `trace_id`) COMMENT '</span><span class="keyword">for</span> getTracesByIds’;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> zipkin_spans <span class="keyword">ADD</span> <span class="keyword">INDEX</span>(<span class="string">`name`</span>) <span class="keyword">COMMENT</span> <span class="string">'for getTraces and getSpanNames’;</span></span><br><span class="line"><span class="string">ALTER TABLE zipkin_spans ADD INDEX(`start_ts`) COMMENT '</span><span class="keyword">for</span> getTraces ordering <span class="keyword">and</span> <span class="keyword">range</span>’;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> zipkin_annotations (</span><br><span class="line">  <span class="string">`trace_id_high`</span> <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'If non zero, this means the trace uses 128 bit traceIds instead of 64 bit’,</span></span><br><span class="line"><span class="string">  `trace_id` BIGINT NOT NULL COMMENT '</span>coincides <span class="keyword">with</span> zipkin_spans.trace_id’,</span><br><span class="line">  <span class="string">`span_id`</span> <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'coincides with zipkin_spans.id’,</span></span><br><span class="line"><span class="string">  `a_key` VARCHAR(255) NOT NULL COMMENT '</span>BinaryAnnotation.key <span class="keyword">or</span> Annotation.value <span class="keyword">if</span> <span class="keyword">type</span> == <span class="number">-1</span>’,</span><br><span class="line">  <span class="string">`a_value`</span> <span class="built_in">BLOB</span> <span class="keyword">COMMENT</span> <span class="string">'BinaryAnnotation.value(), which must be smaller than 64KB’,</span></span><br><span class="line"><span class="string">  `a_type` INT NOT NULL COMMENT '</span>BinaryAnnotation.type() <span class="keyword">or</span> <span class="number">-1</span> <span class="keyword">if</span> Annotation’,</span><br><span class="line">  <span class="string">`a_timestamp`</span> <span class="built_in">BIGINT</span> <span class="keyword">COMMENT</span> <span class="string">'Used to implement TTL; Annotation.timestamp or zipkin_spans.timestamp’,</span></span><br><span class="line"><span class="string">  `endpoint_ipv4` INT COMMENT '</span><span class="literal">Null</span> <span class="keyword">when</span> <span class="built_in">Binary</span>/Annotation.endpoint <span class="keyword">is</span> <span class="literal">null</span>’,</span><br><span class="line">  <span class="string">`endpoint_ipv6`</span> <span class="built_in">BINARY</span>(<span class="number">16</span>) <span class="keyword">COMMENT</span> <span class="string">'Null when Binary/Annotation.endpoint is null, or no IPv6 address’,</span></span><br><span class="line"><span class="string">  `endpoint_port` SMALLINT COMMENT '</span><span class="literal">Null</span> <span class="keyword">when</span> <span class="built_in">Binary</span>/Annotation.endpoint <span class="keyword">is</span> <span class="literal">null</span>’,</span><br><span class="line">  <span class="string">`endpoint_service_name`</span> <span class="built_in">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">COMMENT</span> <span class="string">'Null when Binary/Annotation.endpoint is null’</span></span><br><span class="line"><span class="string">) ENGINE=InnoDB ROW_FORMAT=COMPRESSED CHARACTER SET=utf8 COLLATE utf8_general_ci;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ALTER TABLE zipkin_annotations ADD UNIQUE KEY(`trace_id_high`, `trace_id`, `span_id`, `a_key`, `a_timestamp`) COMMENT '</span><span class="keyword">Ignore</span> <span class="keyword">insert</span> <span class="keyword">on</span> <span class="keyword">duplicate</span>’;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> zipkin_annotations <span class="keyword">ADD</span> <span class="keyword">INDEX</span>(<span class="string">`trace_id_high`</span>, <span class="string">`trace_id`</span>, <span class="string">`span_id`</span>) <span class="keyword">COMMENT</span> <span class="string">'for joining with zipkin_spans’;</span></span><br><span class="line"><span class="string">ALTER TABLE zipkin_annotations ADD INDEX(`trace_id_high`, `trace_id`) COMMENT '</span><span class="keyword">for</span> getTraces/ByIds’;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> zipkin_annotations <span class="keyword">ADD</span> <span class="keyword">INDEX</span>(<span class="string">`endpoint_service_name`</span>) <span class="keyword">COMMENT</span> <span class="string">'for getTraces and getServiceNames’;</span></span><br><span class="line"><span class="string">ALTER TABLE zipkin_annotations ADD INDEX(`a_type`) COMMENT '</span><span class="keyword">for</span> getTraces’;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> zipkin_annotations <span class="keyword">ADD</span> <span class="keyword">INDEX</span>(<span class="string">`a_key`</span>) <span class="keyword">COMMENT</span> <span class="string">'for getTraces’;</span></span><br><span class="line"><span class="string">ALTER TABLE zipkin_annotations ADD INDEX(`trace_id`, `span_id`, `a_key`) COMMENT '</span><span class="keyword">for</span> dependencies job’;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> zipkin_dependencies (</span><br><span class="line">  <span class="string">`day`</span> <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`parent`</span> <span class="built_in">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`child`</span> <span class="built_in">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`call_count`</span> <span class="built_in">BIGINT</span>,</span><br><span class="line">  <span class="string">`error_count`</span> <span class="built_in">BIGINT</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> ROW_FORMAT=COMPRESSED <span class="built_in">CHARACTER</span> <span class="keyword">SET</span>=utf8 <span class="keyword">COLLATE</span> utf8_general_ci;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> zipkin_dependencies <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span>(<span class="string">`day`</span>, <span class="string">`parent`</span>, <span class="string">`child`</span>);</span><br></pre></td></tr></table></figure>
<p>这里创建了三个数据表。</p>
<blockquote>
<p>该Sql文件可以从以下链接获得：<a href="https://github.com/openzipkin/zipkin/blob/master/zipkin-storage/mysql/src/main/resources/mysql.sql" target="_blank" rel="noopener">https://github.com/openzipkin/zipkin/blob/master/zipkin-storage/mysql/src/main/resources/mysql.sql</a></p>
</blockquote>
<p>Sql脚本执行完成后，可以看到zipkin相关的三个表已经建成：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-9b0702bbcfd1a5c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Zipkin相关的三个表"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-2bd8efa03d4206da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Zipkin相关的三个表"></p>
<ul>
<li>创建数据库test：用作测试数据库</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="string">`test`</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> auto_increment,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> ,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> <span class="keyword">values</span> (<span class="number">1</span>,”hansonwang99”)</span><br></pre></td></tr></table></figure>
<p>这里插入了一条数据用于实验。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-c896eb097e06c40d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建test数据库并插入一条数据"></p>
<hr>
<h2 id="启动zipkin服务"><a href="#启动zipkin服务" class="headerlink" title="启动zipkin服务"></a>启动zipkin服务</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 9411:9411 \</span><br><span class="line">--link mysql:mysql \</span><br><span class="line">-e STORAGE_TYPE=mysql \</span><br><span class="line">-e MYSQL_HOST=mysql \</span><br><span class="line">-e MYSQL_TCP_PORT=3306 \</span><br><span class="line">-e MYSQL_DB=zipkin \</span><br><span class="line">-e MYSQL_USER=root \</span><br><span class="line">-e MYSQL_PASS=XXXXXX \</span><br><span class="line"> --name zipkin openzipkin/zipkin</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="启动Mysql数据库访问的微服务（即ServiceC）"><a href="#启动Mysql数据库访问的微服务（即ServiceC）" class="headerlink" title="启动Mysql数据库访问的微服务（即ServiceC）"></a>启动Mysql数据库访问的微服务（即ServiceC）</h2><p>在浏览器中输入：localhost:8883/mysqltest，如果看到以下输出，就可以证明数据库调用操作已经成功了！</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-7c74e3da2f1a3a8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数据库调用操作已经成功"></p>
<hr>
<h2 id="Zipkin追踪数据库调用实际实验"><a href="#Zipkin追踪数据库调用实际实验" class="headerlink" title="Zipkin追踪数据库调用实际实验"></a>Zipkin追踪数据库调用实际实验</h2><ul>
<li><strong>浏览器输入：</strong><a href="http://localhost:9411/zipkin/" target="_blank" rel="noopener">http://localhost:9411/zipkin/</a>  </li>
</ul>
<p>打开Zipkin Web UI，点击服务名下拉列表能看见已经成功识别了Mysql数据库调用服务</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-8db64319719f616f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="成功识别Mysql数据库调用服务"></p>
<ul>
<li><strong>选中mysqlservice后，点击Find Traces</strong></li>
</ul>
<p>可以看到 <strong>首次查询</strong> Mysql的调用链追踪信息，有很多</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-e8a153a9f7f29715.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="首次查询Mysql所产生的Traces信息"></p>
<p>随便点开某一个查看：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-f2b446b9dbf0b1a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="随机查看某一个具体的Trace信息"></p>
<ul>
<li><strong>接下来浏览器中再次输入：</strong>localhost:8883/mysqltest </li>
</ul>
<p>目的是再次触发Mysql的调用，然后再次Find Traces，可以看到追踪数据类似下图：包含两次Mysql的query动作：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-d0def2c28cc0c543.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="两次Mysql的query动作"></p>
<p>点开第一个query查看，其实际上是在 <strong>尝试连接Mysql数据库</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-42e267adf303970d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第一个query详情"></p>
<p>点开第二个query查看，发现这里才是 <strong>实际查询业务</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-4180659ae5fda3e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第二个query详情"></p>
<p>从图形化界面上可以清楚地知道每个阶段的详细步骤与耗时，因此可以用来分析哪个SQL语句执行相对较慢。</p>
<hr>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>本文实验所用源码已经开源，需要的话请 <a href="https://github.com/hansonwang99/Zipkin_Traces" target="_blank" rel="noopener">自取</a>。</p>
<p>作者一些其他容器化、微服务化方面的文章：</p>
<ul>
<li><a href="https://www.jianshu.com/p/da80ea881424" target="_blank" rel="noopener">微服务调用链追踪中心搭建</a></li>
<li><a href="https://www.jianshu.com/p/9bc87b5380e8" target="_blank" rel="noopener">利用K8S技术栈打造个人私有云连载文章</a></li>
<li><a href="https://www.jianshu.com/p/9e47ffaf5e31" target="_blank" rel="noopener">Docker容器可视化监控中心搭建</a></li>
<li><a href="https://www.jianshu.com/p/a40c36beee63" target="_blank" rel="noopener">利用ELK搭建Docker容器化应用日志中心</a></li>
<li><p><a href="https://www.jianshu.com/p/e9ce05b44150" target="_blank" rel="noopener">Spring Boot应用监控实战</a></p>
<p>作者更多的原创文章：<a href="https://www.jianshu.com/u/d19536b0189b" target="_blank" rel="noopener">在此</a></p>
</li>
</ul>
<hr>
<hr>
<p>最后附上个人联系方式，欢迎大家交流学习：<br>简    书：<a href="https://www.jianshu.com/u/d19536b0189b" target="_blank" rel="noopener">https://www.jianshu.com/u/d19536b0189b</a><br>个人博客：www.hansonwang99.com.cn<br>个人网站：<a href="http://113.209.119.170/" target="_blank" rel="noopener">http://113.209.119.170/</a> （捂脸的表情，很慢，1G 1M 1核的云主机上）</p>
<p><img src="https://hansonwang99.github.io/img/wechat_qrcode.jpg" title="欢迎扫描我的二维码！"></p>
]]></content>
      
        <categories>
            
            <category> MSA </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Docker </tag>
            
            <tag> MSA </tag>
            
            <tag> Zipkin </tag>
            
            <tag> Mysql </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringBoot应用监控实战]]></title>
      <url>/2018/05/02/SpringBoot%E5%BA%94%E7%94%A8%E7%9B%91%E6%8E%A7%E5%AE%9E%E6%88%98/</url>
      <content type="html"><![CDATA[<p>利用SpringBoot作为微服务单元的实例化技术选型时，我们不可避免的要面对的一个问题就是如何实时监控应用的运行状况数据，比如：健康度、运行指标、日志信息、线程状况等等。本文就该问题做一点探索并记录试验过程。</p>
<a id="more"></a>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-348d76f5cc3271b7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Profile"></p>
<hr>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>之前讲过<a href="https://www.jianshu.com/p/9e47ffaf5e31" target="_blank" rel="noopener">Docker容器的可视化监控</a>，即监控容器的运行情况，包括 CPU使用率、内存占用、网络状况以及磁盘空间等等一系列信息。同样利用SpringBoot作为微服务单元的实例化技术选型时，我们不可避免的要面对的一个问题就是如何实时监控应用的运行状况数据，比如：健康度、运行指标、日志信息、线程状况等等。本文就该问题做一点探索并记录试验过程。</p>
<hr>
<h2 id="入门使用：Actuator插件"><a href="#入门使用：Actuator插件" class="headerlink" title="入门使用：Actuator插件"></a>入门使用：Actuator插件</h2><p>Actuator插件是SpringBoot原生提供的一个服务，可以通过暴露端点路由，用来输出应用中的诸多 <strong>端点信息</strong>。实战一下！</p>
<ul>
<li>pom.xml中添加依赖：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>启动Spring Boot应用程序之后，只要在浏览器中输入端点信息就能获得应用的一些状态信息。</p>
<p>常用端点列举如下，可以一个个详细试一下：</p>
<ul>
<li>/info           　　　　　　　应用基本信息</li>
<li>/health       　　　　　　健康度信息</li>
<li>/metrics     　　　　　运行指标</li>
<li>/env           　　　　　　　环境变量信息</li>
<li>/loggers    　　　　　日志相关</li>
<li>/dump       　　　　　　线程相关信息</li>
<li>/trace      　　　　　　请求调用轨迹</li>
</ul>
<p>当然此时只能使用<code>/health</code> 和 <code>/info</code>端点，其他因为权限问题无法访问。想访问指定端点的话可以在yml配置中添加相关的配置项，比如<code>/metrics</code>端点则需要配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">endpoints:</span><br><span class="line">  metrics:</span><br><span class="line">    sensitive: false</span><br></pre></td></tr></table></figure>
<p>此时浏览器访问/metrics端点就能得到诸如下面所示的信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;mem&quot;: 71529,</span><br><span class="line">	&quot;mem.free&quot;: 15073,</span><br><span class="line">	&quot;processors&quot;: 4,</span><br><span class="line">	&quot;instance.uptime&quot;: 6376,</span><br><span class="line">	&quot;uptime&quot;: 9447,</span><br><span class="line">	&quot;systemload.average&quot;: -1.0,</span><br><span class="line">	&quot;heap.committed&quot;: 48024,</span><br><span class="line">	&quot;heap.init&quot;: 16384,</span><br><span class="line">	&quot;heap.used&quot;: 32950,</span><br><span class="line">	&quot;heap&quot;: 506816,</span><br><span class="line">	&quot;nonheap.committed&quot;: 23840,</span><br><span class="line">	&quot;nonheap.init&quot;: 160,</span><br><span class="line">	&quot;nonheap.used&quot;: 23506,</span><br><span class="line">	&quot;nonheap&quot;: 0,</span><br><span class="line">	&quot;threads.peak&quot;: 25,</span><br><span class="line">	&quot;threads.daemon&quot;: 23,</span><br><span class="line">	&quot;threads.totalStarted&quot;: 28,</span><br><span class="line">	&quot;threads&quot;: 25,</span><br><span class="line">	&quot;classes&quot;: 6129,</span><br><span class="line">	&quot;classes.loaded&quot;: 6129,</span><br><span class="line">	&quot;classes.unloaded&quot;: 0,</span><br><span class="line">	&quot;gc.copy.count&quot;: 74,</span><br><span class="line">	&quot;gc.copy.time&quot;: 173,</span><br><span class="line">	&quot;gc.marksweepcompact.count&quot;: 3,</span><br><span class="line">	&quot;gc.marksweepcompact.time&quot;: 88,</span><br><span class="line">	&quot;httpsessions.max&quot;: -1,</span><br><span class="line">	&quot;httpsessions.active&quot;: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然也可以开启全部端点权限，只需如下配置即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">endpoints:</span><br><span class="line">  sensitive: false</span><br></pre></td></tr></table></figure>
<p>由于Actuator插件提供的监控能力毕竟有限，而且UI比较简陋，因此需要一个更加成熟一点的工具</p>
<hr>
<h2 id="Spring-Boot-Admin监控系统"><a href="#Spring-Boot-Admin监控系统" class="headerlink" title="Spring Boot Admin监控系统"></a>Spring Boot Admin监控系统</h2><p>SBA则是基于Actuator更加进化了一步，其是一个针对Actuator接口进行UI美化封装的监控工具。我们来实验一下。</p>
<ul>
<li>首先来创建一个Spring Boot Admin Server工程作为服务端</li>
</ul>
<p>pom.xml中加入如下依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;de.codecentric&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-admin-server&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;1.5.7&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;de.codecentric&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-admin-server-ui&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;1.5.7&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>然后在应用主类上通过加注解来启用Spring Boot Admin</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@EnableAdminServer</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringbtAdminServerApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(SpringbtAdminServerApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动程序，浏览器打开 <code>localhost:8081</code> 查看Spring Boot Admin主页面：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-47e70841db255449.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Spring Boot Admin主页面"></p>
<p>此时Application一栏空空如也，等待待监控的应用加入</p>
<ul>
<li>创建要监控的Spring Boot应用</li>
</ul>
<p>pom.xml中加入以下依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;de.codecentric&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-admin-starter-client&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;1.5.7&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>然后在yml配置中添加如下配置，将应用注册到Admin服务端去：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  boot:</span><br><span class="line">    admin:</span><br><span class="line">      url: http://localhost:8081</span><br><span class="line">      client:</span><br><span class="line">        name: AdminTest</span><br></pre></td></tr></table></figure>
<p>Client应用一启动，Admin服务立马推送来了消息，告诉你AdminTest上线了：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-acfd45ffe9c94676.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="应用上线推送消息"></p>
<p>此时去Admin主界面上查看，发现Client应用确实已经注册上来了：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-28f8817ac21e4ea4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Client应用已注册上来"></p>
<ul>
<li>查看Detail</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-c2dcddd5b96c79e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Detail信息"></p>
<ul>
<li>查看 Metrics</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-be0cc63e4a60d61e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Metrics信息"></p>
<ul>
<li>查看 Enviroment</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-476b042bce07cbe6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Enviroment信息"></p>
<ul>
<li>查看JMX</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-de237fa0450c7818.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="JMX信息"></p>
<ul>
<li>查看Threads</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-e7e5f254a8642d48.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Threads信息"></p>
<ul>
<li>查看Trace与详情</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-1a4f1fe47603045c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Trace信息"></p>
<p>点击最上方JOURNAL，会看到被监控应用程序的事件变化：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-ff6097407f42d281.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="应用程序的事件变化信息"></p>
<p>图中可以清晰地看到，应用从 <strong>REGISTRATION → UNKNOWN → UP</strong> 的状态跳转。</p>
<p>这样就将Actuator插件提供的所有端点信息在SBA中全部尝试了一遍。</p>
<hr>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="http://codecentric.github.io/spring-boot-admin/1.5.7/" target="_blank" rel="noopener">http://codecentric.github.io/spring-boot-admin/1.5.7/</a></li>
</ul>
<hr>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>作者一些其他容器化应用方面的文章：</p>
<ul>
<li><a href="https://www.jianshu.com/p/9bc87b5380e8" target="_blank" rel="noopener">利用K8S技术栈打造个人私有云连载文章</a></li>
<li><a href="https://www.jianshu.com/p/9e47ffaf5e31" target="_blank" rel="noopener">Docker容器可视化监控中心搭建</a></li>
<li><a href="https://www.jianshu.com/p/da80ea881424" target="_blank" rel="noopener">微服务调用链追踪中心搭建</a></li>
<li><a href="https://www.jianshu.com/p/a40c36beee63" target="_blank" rel="noopener">利用ELK搭建Docker容器化应用日志中心</a></li>
</ul>
<p>作者更多的原创文章：<a href="https://www.jianshu.com/u/d19536b0189b" target="_blank" rel="noopener">在此</a></p>
<hr>
<hr>
<p>最后附上个人联系方式，欢迎大家交流学习：<br>个人博客：www.hansonwang99.com.cn<br>个人网站：<a href="http://113.209.119.170/" target="_blank" rel="noopener">http://113.209.119.170/</a> （捂脸的表情，很慢，1G1C1M，你懂的）<br>简    书：<a href="https://www.jianshu.com/u/d19536b0189b" target="_blank" rel="noopener">https://www.jianshu.com/u/d19536b0189b</a></p>
<p><img src="https://hansonwang99.github.io/img/wechat_qrcode.jpg" title="欢迎扫描我的二维码！"></p>
]]></content>
      
        <categories>
            
            <category> SpringBt学习录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SpringBt </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[微服务调用链追踪中心搭建]]></title>
      <url>/2018/04/24/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E9%93%BE%E8%BF%BD%E8%B8%AA%E4%B8%AD%E5%BF%83%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<p>一个完整的微服务系统包含多个微服务单元，各个微服务子系统存在互相调用的情况，形成一个 <strong>调用链</strong>。一个客户端请求从发出到被响应 <strong>经历了哪些组件</strong>、<strong>哪些微服务</strong>、<strong>请求总时长</strong>、<strong>每个组件所花时长</strong> 等信息我们有必要了解和收集，以帮助我们定位性能瓶颈、进行性能调优，因此监控整个微服务架构的调用链十分有必要，本文将阐述如何使用 <strong>Zipkin</strong> 搭建微服务调用链追踪中心。</p>
<a id="more"></a>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-70f210451be4b08a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="封面图片"></p>
<hr>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一个完整的微服务系统包含多个微服务单元，各个微服务子系统存在互相调用的情况，形成一个 <strong>调用链</strong>。一个客户端请求从发出到被响应 <strong>经历了哪些组件</strong>、<strong>哪些微服务</strong>、<strong>请求总时长</strong>、<strong>每个组件所花时长</strong> 等信息我们有必要了解和收集，以帮助我们定位性能瓶颈、进行性能调优，因此监控整个微服务架构的调用链十分有必要，本文将阐述如何使用 <strong>Zipkin</strong> 搭建微服务调用链追踪中心。</p>
<hr>
<h2 id="Zipkin初摸"><a href="#Zipkin初摸" class="headerlink" title="Zipkin初摸"></a>Zipkin初摸</h2><p>正如 <a href="https://zipkin.io/" target="_blank" rel="noopener">Ziplin官网</a> 所描述，Zipkin是一款分布式的追踪系统，其可以帮助我们收集微服务架构中用于解决延时问题的时序数据，更直白地讲就是可以帮我们追踪调用的轨迹。</p>
<p>Zipkin的设计架构如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-d30c7c39fedac161.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Zipkin设计架构"></p>
<p>要理解这张图，需要了解一下Zipkin的几个核心概念：</p>
<ul>
<li>Reporter</li>
</ul>
<p>在某个应用中安插的用于发送数据给Zipkin的组件称为Report，目的就是用于追踪数据收集</p>
<ul>
<li>Span</li>
</ul>
<p>微服务中调用一个组件时，从发出请求开始到被响应的过程会持续一段时间，将这段跨度称为Span</p>
<ul>
<li>Trace</li>
</ul>
<p>从Client发出请求到完成请求处理，中间会经历一个调用链，将这一个整个过程称为一个追踪（Trace）。一个Trace可能包含多个Span，反之每个Span都有一个上级的Trace。</p>
<ul>
<li>Transport</li>
</ul>
<p>一种数据传输的方式，比如最简单的HTTP方式，当然在高并发时可以换成Kafka等消息队列</p>
<hr>
<p>看了一下基本概念后，再结合上面的架构图，可以试着理解一下，只有装配有Report组件的Client才能通过Transport来向Zipkin发送追踪数据。追踪数据由Collector收集器进行手机然后持久化到Storage之中。最后需要数据的一方，可以通过UI界面调用API接口，从而最终取到Storage中的数据。可见整体流程不复杂。</p>
<p>Zipkin官网给出了各种常见语言支持的OpenZipkin libraries：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-2293db1655e54057.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="OpenZipkin libraries"></p>
<p>本文接下来将 <strong>构造微服务追踪的实验场景</strong> 并使用 <strong>Brave</strong> 来辅助完成微服务调用链追踪中心搭建！</p>
<hr>
<h2 id="部署Zipkin服务"><a href="#部署Zipkin服务" class="headerlink" title="部署Zipkin服务"></a>部署Zipkin服务</h2><p>利用Docker来部署Zipkin服务再简单不过了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 9411:9411 \</span><br><span class="line">--name zipkin \</span><br><span class="line">docker.io/openzipkin/zipkin</span><br></pre></td></tr></table></figure>
<p>完成之后浏览器打开：<code>localhost:9411</code>可以看到Zipkin的可视化界面：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-46f2092bf3e778a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Zipkin可视化界面"></p>
<hr>
<h2 id="模拟微服务调用链"><a href="#模拟微服务调用链" class="headerlink" title="模拟微服务调用链"></a>模拟微服务调用链</h2><p>我们来构造一个如下图所示的调用链：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-cbe641612c6f3d67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微服务调用链"></p>
<p>图中包含 <strong>一个客户端</strong> + <strong>三个微服务</strong>：</p>
<ul>
<li><p>Client：使用/servicea接口消费ServiceA提供的服务</p>
</li>
<li><p>ServiceA：使用/serviceb接口消费ServiceB提供的服务，端口8881</p>
</li>
<li><p>ServiceB：使用/servicec接口消费ServiceC提供的服务，端口8882</p>
</li>
<li><p>ServiceC：提供终极服务，端口8883</p>
</li>
</ul>
<p>为了模拟明显的延时效果，准备在每个接口的响应中用代码加入3s的延时。</p>
<p>简单起见，我们用SpringBt来实现三个微服务。</p>
<p>ServiceA的控制器代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class ServiceAContorller &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/servicea”)</span><br><span class="line">    public String servicea() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep( 3000 );</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return restTemplate.getForObject(&quot;http://localhost:8882/serviceb&quot;, String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ServiceB的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class ServiceBContorller &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/serviceb”)</span><br><span class="line">    public String serviceb() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep( 3000 );</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return restTemplate.getForObject(&quot;http://localhost:8883/servicec&quot;, String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ServiceC的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class ServiceCContorller &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/servicec”)</span><br><span class="line">    public String servicec() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep( 3000 );</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;Now, we reach the terminal call: servicec !”;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将三个微服务都启动起来，然后浏览器中输入<code>localhost:8881/servicea</code>来发出请求，过了9s之后，将取到ServiceC中提供的微服务接口所返回的内容，如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-52dc25e9cf102e9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微服务链式调用结果"></p>
<p>很明显，调用链可以正常work了！</p>
<p>那么接下来我们就要引入Zipkin来追踪这个调用链的信息！</p>
<h2 id="编写与Zipkin通信的工具组件"><a href="#编写与Zipkin通信的工具组件" class="headerlink" title="编写与Zipkin通信的工具组件"></a>编写与Zipkin通信的工具组件</h2><p>从Zipkin官网我们可以知道，借助OpenZipkin库Brave，我们可以开发一个封装Brave的公共组件，让其能十分方便地嵌入到ServiceA，ServiceB，ServiceC服务之中，完成与Zipkin的通信。</p>
<p>为此我们需要建立一个新的基于Maven的Java项目：<code>ZipkinTool</code></p>
<ul>
<li>pom.xml中加入如下依赖：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.hansonwang99&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;ZipkinTool&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;source&gt;6&lt;/source&gt;</span><br><span class="line">                    &lt;target&gt;6&lt;/target&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">    &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.zipkin.brave&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;brave-spring-web-servlet-interceptor&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.0.6&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.zipkin.brave&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;brave-spring-resttemplate-interceptors&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.0.6&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.zipkin.reporter&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;zipkin-sender-okhttp3&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;0.6.12&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;RELEASE&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>编写ZipkinProperties类</li>
</ul>
<p>其包含endpoint和service两个属性，我们最后是需要将该两个参数提供给ServiceA、ServiceB、ServiceC微服务作为其application.properties中的Zipkin配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">@Component</span><br><span class="line">@ConfigurationProperties(&quot;zipkin&quot;)</span><br><span class="line">public class ZipkinProperties &#123;</span><br><span class="line">    private String endpoint;</span><br><span class="line">    private String service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用了lombok之后，这个类异常简单！</p>
<blockquote>
<p>【注意：关于lombok的用法，<a href="https://www.jianshu.com/p/c88b0f17f62a" target="_blank" rel="noopener">可以看这里</a>】</p>
</blockquote>
<ul>
<li>编写ZipkinConfiguration类</li>
</ul>
<p>这个类很重要，在里面我们将Brave的BraveClientHttpRequestInterceptor拦截器注册到RestTemplate的拦截器调用链中来收集请求数据到Zipkin中；同时还将Brave的ServletHandlerInterceptor拦截器注册到调用链中来收集响应数据到Zipkin中</p>
<p>上代码吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@Import(&#123;RestTemplate.class, BraveClientHttpRequestInterceptor.class, ServletHandlerInterceptor.class&#125;)</span><br><span class="line">public class ZipkinConfiguration extends WebMvcConfigurerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ZipkinProperties zipkinProperties;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private BraveClientHttpRequestInterceptor clientInterceptor;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ServletHandlerInterceptor serverInterceptor;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Sender sender() &#123;</span><br><span class="line">        return OkHttpSender.create( zipkinProperties.getEndpoint() );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Reporter&lt;Span&gt; reporter() &#123;</span><br><span class="line">        return AsyncReporter.builder(sender()).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Brave brave() &#123;</span><br><span class="line">        return new Brave.Builder(zipkinProperties.getService()).reporter(reporter()).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public SpanNameProvider spanNameProvider() &#123;</span><br><span class="line">        return new SpanNameProvider() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public String spanName(HttpRequest httpRequest) &#123;</span><br><span class="line">                return String.format(</span><br><span class="line">                        &quot;%s %s&quot;,</span><br><span class="line">                        httpRequest.getHttpMethod(),</span><br><span class="line">                        httpRequest.getUri().getPath()</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void init() &#123;</span><br><span class="line">        List&lt;ClientHttpRequestInterceptor&gt; interceptors = restTemplate.getInterceptors();</span><br><span class="line">        interceptors.add(clientInterceptor);</span><br><span class="line">        restTemplate.setInterceptors(interceptors);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">        registry.addInterceptor(serverInterceptor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ZipkinTool完成以后，我们需要在ServiceA、ServiceB、ServiceC三个SpringBt项目的application.properties中加入Zipkin的配置：</p>
<p>以ServiceA为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.port=8881</span><br><span class="line">zipkin.endpoint=http://你Zipkin服务所在机器的IP:9411/api/v1/spans</span><br><span class="line">zipkin.service=servicea</span><br></pre></td></tr></table></figure>
<p>我们最后依次启动ServiceA、ServiceB、和ServiceC三个微服务，并开始实验来收集链路追踪数据 ！</p>
<hr>
<p>##　实际实验</p>
<h3 id="1-依赖分析"><a href="#1-依赖分析" class="headerlink" title="1. 依赖分析"></a>1. 依赖分析</h3><p>浏览器打开Zipkin的UI界面，可以查看 <strong>依赖分析</strong>：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-f4c8e812b81803ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="点击依赖分析"></p>
<p>图中十分清晰地展示了ServiceA、ServiceB和ServiceC三个服务之间的调用关系！<br>注意，该图可缩放，并且每一个元素均可以点击，例如点击 ServiceB这个微服务，可以看到其调用链的上下游！</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-28513209ce372354.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="点击ServiceB微服务"></p>
<hr>
<h3 id="2-查找调用链"><a href="#2-查找调用链" class="headerlink" title="2. 查找调用链"></a>2. 查找调用链</h3><p>接下来我们看一下调用链相关，点击 <strong>服务名</strong>，可以看到Zipkin监控到个所有服务：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-f2419dbff8b12ba9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查找调用链"></p>
<p>同时可以查看Span，如以ServiceA为例，其所有REST接口都再下拉列表中：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-ade7af5bf79440a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查看Span"></p>
<p>以ServiceA为例，点击 <strong>Find Traces</strong>，可以看到其所有追踪信息：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-854a97130fc62fb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Find Traces"></p>
<p>点击某个具体Trace，还能看到详细的每个Span的信息，如下图中，可以看到 A → B → C 调用过程中每个REST接口的详细时间戳：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-bb9909ab085c8281.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="某一个具体Trace"></p>
<p>点击某一个REST接口进去还能看到更详细的信息，如查看/servicec这个REST接口，可以看到从发送请求到收到响应信息的所有详细步骤：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-fc67e7e8ffde1b35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="某一个具体Span详细信息"></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>作者一些其他容器化应用方面的文章：</p>
<ul>
<li><a href="https://www.jianshu.com/p/9e47ffaf5e31" target="_blank" rel="noopener">Docker容器可视化监控中心搭建</a></li>
<li><a href="https://www.jianshu.com/p/9bc87b5380e8" target="_blank" rel="noopener">利用K8S技术栈打造个人私有云连载文章</a></li>
<li><a href="https://www.jianshu.com/p/a40c36beee63" target="_blank" rel="noopener">利用ELK搭建Docker容器化应用日志中心</a></li>
</ul>
<p> 作者更多的原创文章：<a href="https://www.jianshu.com/u/d19536b0189b" target="_blank" rel="noopener">在此</a></p>
<hr>
<hr>
<p>最后附上个人联系方式，欢迎大家交流学习：<br>简    书：<a href="https://www.jianshu.com/u/d19536b0189b" target="_blank" rel="noopener">https://www.jianshu.com/u/d19536b0189b</a><br>个人博客：www.hansonwang99.com.cn<br>个人网站：<a href="http://113.209.119.170/" target="_blank" rel="noopener">http://113.209.119.170/</a> （捂脸的表情，很慢，1G 1M 1核的云主机上）</p>
<p><img src="https://hansonwang99.github.io/img/wechat_qrcode.jpg" title="欢迎扫描我的二维码！"></p>
]]></content>
      
        <categories>
            
            <category> MSA </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Docker </tag>
            
            <tag> MSA </tag>
            
            <tag> Zipkin </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Docker容器可视化监控中心搭建]]></title>
      <url>/2018/04/17/Docker%E5%AE%B9%E5%99%A8%E5%8F%AF%E8%A7%86%E5%8C%96%E7%9B%91%E6%8E%A7%E4%B8%AD%E5%BF%83%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<p>一个宿主机上可以运行多个容器化应用，容器化应用运行于宿主机上，我们需要知道该容器的运行情况，包括 CPU使用率、内存占用、网络状况以及磁盘空间等等一系列信息，而且这些信息随时间变化，我们称其为时序数据，本文将实操 <strong>如何搭建一个可视化的监控中心</strong> 来收集这些承载着具体应用的容器的时序信息并可视化分析与展示！</p>
<a id="more"></a>
<hr>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-4c1b8345dccd0827.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="封面图片"></p>
<hr>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一个宿主机上可以运行多个容器化应用，容器化应用运行于宿主机上，我们需要知道该容器的运行情况，包括 CPU使用率、内存占用、网络状况以及磁盘空间等等一系列信息，而且这些信息随时间变化，我们称其为时序数据，本文将实操 <strong>如何搭建一个可视化的监控中心</strong> 来收集这些承载着具体应用的容器的时序信息并可视化分析与展示！</p>
<p>动手了，动手了…</p>
<hr>
<h2 id="准备镜像"><a href="#准备镜像" class="headerlink" title="准备镜像"></a>准备镜像</h2><ul>
<li><p>adviser：负责收集容器的随时间变化的数据</p>
</li>
<li><p>influxdb：负责存储时序数据</p>
</li>
<li><p>grafana：负责分析和展示时序数据</p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-448e57dd4e3f90aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="镜像准备"></p>
<hr>
<h2 id="部署Influxdb服务"><a href="#部署Influxdb服务" class="headerlink" title="部署Influxdb服务"></a>部署Influxdb服务</h2><p>可以将其视为一个数据库服务，其确实用于存储数据。之所以选用该数据库，原因正如官网所说：</p>
<blockquote>
<p>Open Source Time Series DB Platform for Metrics &amp; Events (Time Series Data)</p>
</blockquote>
<p>下面我们将该服务部署起来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8086:8086 \</span><br><span class="line">-v ~/influxdb:/var/lib/influxdb \</span><br><span class="line">--name influxdb tutum/influxdb</span><br></pre></td></tr></table></figure>
<ul>
<li>进入influxdb容器内部，并执行influx命令：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it influxdb influx</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-275e229dbb8d5503.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="进入influxdb的shell命令行"></p>
<ul>
<li>创建数据库test和root用户用于本次试验测试</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE &quot;test&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &quot;root&quot; WITH PASSWORD &apos;root&apos; WITH ALL PRIVILEGES</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-bd026c0d74a7bd22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建测试数据库并查看"></p>
<hr>
<h2 id="部署cAdvisor服务"><a href="#部署cAdvisor服务" class="headerlink" title="部署cAdvisor服务"></a>部署cAdvisor服务</h2><p>谷歌的cadvisor可以用于收集Docker容器的时序信息，包括容器运行过程中的资源使用情况和性能数据。</p>
<ul>
<li>运行cadvisor服务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">-v /:/rootfs -v /var/run:/var/run -v /sys:/sys \</span><br><span class="line">-v /var/lib/docker:/var/lib/docker \</span><br><span class="line">--link=influxdb:influxdb --name cadvisor google/cadvisor:v0.27.3 \</span><br><span class="line">--storage_driver=influxdb \</span><br><span class="line">--storage_driver_host=influxdb:8086 \</span><br><span class="line">--storage_driver_db=test \</span><br><span class="line">--storage_driver_user=root \</span><br><span class="line">--storage_driver_password=root</span><br></pre></td></tr></table></figure>
<p><strong>特别注意项：</strong></p>
<p>在运行上述docker时，这里有可能两个其他配置项需要添加（CentOS, RHEL需要）：</p>
<ul>
<li><strong>–privileged=true</strong></li>
</ul>
<p>设置为true之后，容器内的root才拥有真正的root权限，可以看到host上的设备，并且可以执行mount；否者容器内的root只是外部的一个普通用户权限。由于cadvisor需要通过socket访问docker守护进程，在CentOs和RHEL系统中需要这个这个选项。</p>
<ul>
<li><strong>–volume=/cgroup:/cgroup:ro</strong> </li>
</ul>
<p>对于CentOS和RHEL系统的某些版本（比如CentOS6），cgroup的层级挂在/cgroup目录，所以运行cadvisor时需要额外添加–volume=/cgroup:/cgroup:ro选项。</p>
<hr>
<h2 id="部署Grafana服务"><a href="#部署Grafana服务" class="headerlink" title="部署Grafana服务"></a>部署Grafana服务</h2><p>grafana则是一款开源的时序数据分析工具，而且界面专业易用，等下等部署好了，大家就能感受到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:3000 \</span><br><span class="line">-v ~/grafana:/var/lib/grafana \</span><br><span class="line">--link=influxdb:influxdb \</span><br><span class="line">--name grafana grafana/grafana</span><br></pre></td></tr></table></figure>
<p>至此3个容器都已经启动了：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-989116d49bf0c5c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3个容器均已启动完成"></p>
<p>下面开始具体实验了</p>
<hr>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><ul>
<li>访问grafana服务</li>
</ul>
<p>打开localhost:5000来访问grafana的web服务，此时提示你需要登录，注意用户名和密码都是<code>admin</code></p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-6a1658a26d2454c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="grafana登陆界面"></p>
<p>登录后可以看到grafana的主页面：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-13da546053cbed47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="grafana的主页面"></p>
<p>看的很明显，在Grafana上有好几个步骤需要做，这里<code>Install Grafana</code>已经完成了，接下来我们需要：</p>
<ul>
<li>Add data source</li>
<li>Create dashboard</li>
<li>……</li>
</ul>
<hr>
<ul>
<li><h3 id="Add-Data-Source"><a href="#Add-Data-Source" class="headerlink" title="Add Data Source"></a>Add Data Source</h3></li>
</ul>
<p>点击Add data source进入</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-cbcebb27c1185297.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Add Data Source"></p>
<p>然后主要是Setting选项卡设置</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-32c833d52058c9ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Setting"></p>
<p>我们需要根据实际情况来填写各项内容：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-a972b561b2cfc835.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="填写Setting中的内容"></p>
<p>Data source添加成功会予以提示</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-74a0e9a0f6a42122.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Data source添加成功"></p>
<p>数据源添加完成以后，我们需要添加仪表盘（Dashboard）</p>
<hr>
<ul>
<li><h3 id="Add-Dashboard"><a href="#Add-Dashboard" class="headerlink" title="Add Dashboard"></a>Add Dashboard</h3></li>
</ul>
<p>点击Add dashboard进入</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-1a7c7f0882e9603f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Add dashboard"></p>
<p>这里有很多类型的仪表盘供选择，我们选用最常用的Graph就好</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-e80c68155d668497.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Graph"></p>
<p>进入之后，点击Panel Title下拉列表，再选择Edit进行编辑即可</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-5254a98e834cfcf6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Panel Title → Edit"></p>
<p>在Edit里面主要的就是需要添加查询的条件，继续看下文</p>
<hr>
<ul>
<li><h3 id="Add-Query-Editor"><a href="#Add-Query-Editor" class="headerlink" title="Add Query Editor"></a>Add Query Editor</h3></li>
</ul>
<p>查询条件中我们可以选择要监控的指标：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-d362839a21a34f1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Add Query Editor"></p>
<p>这里选一个memory usage好了，然后要监控的容器选择grafana自身好了。</p>
<blockquote>
<p>当然这里不止可以监控一个指标，也不止可以监控一个容器，更多组合我们只需要在下面并列着一个一个添加query条目就好！</p>
</blockquote>
<p>最后我添加了三个监控条件，分别用于监控grafana、influxdb和cadvisor三个容器的memory usage指标，并将其同时显示于图中，怎么样是不是很直观！</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-944ad570f4aa1642.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="监测三个容器的memory usage指标"></p>
<blockquote>
<p>这里可以摸索的设置项还有很多，比如一些坐标自定义、显示策略自定义，甚至我们还可以自定义报警策略等等</p>
</blockquote>
<hr>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>作者一些其他容器化应用方面的文章：</p>
<ul>
<li><a href="https://www.jianshu.com/p/9bc87b5380e8" target="_blank" rel="noopener">利用K8S技术栈打造个人私有云系列连载文章</a></li>
<li><a href="https://www.jianshu.com/p/a40c36beee63" target="_blank" rel="noopener">利用ELK搭建Docker容器化应用日志中心</a></li>
</ul>
<ul>
<li><a href="https://www.jianshu.com/u/d19536b0189b" target="_blank" rel="noopener">作者更多的原创文章在此</a></li>
</ul>
<hr>
<p>最后附上个人联系方式，欢迎大家交流学习：<br>简    书：<a href="https://www.jianshu.com/u/d19536b0189b" target="_blank" rel="noopener">https://www.jianshu.com/u/d19536b0189b</a><br>个人博客：www.hansonwang99.com.cn<br>个人网站：<a href="http://113.209.119.170/" target="_blank" rel="noopener">http://113.209.119.170/</a> （捂脸的表情，很慢，1G 1M 1核的云主机上）</p>
<p><img src="https://hansonwang99.github.io/img/wechat_qrcode.jpg" title="欢迎扫描我的二维码！"></p>
]]></content>
      
        <categories>
            
            <category> Docker </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringBoot应用Docker化]]></title>
      <url>/2018/04/12/SpringBoot%E5%BA%94%E7%94%A8Docker%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>SpringBoot应用Docker化</p>
<a id="more"></a>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-c07a2c83706122c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Surface Studio"></p>
<hr>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>当下web服务端开发中最火的名词中绝对有<strong>微服务</strong>的一席之地，其也成为当下互联网后端服务架构演进历程中最闪亮的技术之一。微服务的基本思想在于考虑围绕着业务领域组件来创建应用，这些应用可独立地进行开发、管理和加速。在分散的组件中使用微服务云架构和平台，使部署、管理和服务功能交付变得更加简单。既然服务被分割和微小化了，我们很容易想到如果将其和docker结合，让docker承载着一个个的微服务运行，如此一来将会让服务间耦合度降低，部署简洁，同时系统的架构也更加清晰，便于长期演进，基于此想法有了这篇文章的入门实践！</p>
</blockquote>
<hr>
<h2 id="创建基于maven的spring-bt项目"><a href="#创建基于maven的spring-bt项目" class="headerlink" title="创建基于maven的spring bt项目"></a>创建基于maven的spring bt项目</h2><ul>
<li>pom.xml中加依赖：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.0.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line"></span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>我们只需要在启动类中添加一个简单的restful接口就行了，为了后续浏览器能验证一下，访问/hello接口，能向浏览器返回一个 <code>Hello Docker！</code>的问好！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class DockerDemoSpringApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(DockerDemoSpringApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/hello&quot;)</span><br><span class="line">    public String hello()&#123;</span><br><span class="line">        return &quot;Hello! Docker!”;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="编写Dockerfile"><a href="#编写Dockerfile" class="headerlink" title="编写Dockerfile"></a>编写Dockerfile</h2><p>我们在Spring Bt项目的根目录下建立Dockerfile，用起来完成Docker镜像构建的编排：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">FROM maven:3.3.3</span><br><span class="line"></span><br><span class="line">ADD pom.xml /tmp/build/</span><br><span class="line"></span><br><span class="line">RUN cd /tmp/build &amp;&amp; mvn -q dependency:resolve</span><br><span class="line"></span><br><span class="line">ADD src /tmp/build/src</span><br><span class="line">        #构建应用</span><br><span class="line"></span><br><span class="line">RUN cd /tmp/build &amp;&amp; mvn -q -DskipTests=true package \</span><br><span class="line">        #拷贝编译结果到指定目录</span><br><span class="line">        &amp;&amp; mv target/*.jar /app.jar \</span><br><span class="line">        #清理编译痕迹</span><br><span class="line">        &amp;&amp; cd / &amp;&amp; rm -rf /tmp/build</span><br><span class="line"></span><br><span class="line">VOLUME /tmp</span><br><span class="line">EXPOSE 8080</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd=file:/dev/./urandom&quot;,&quot;-jar&quot;,&quot;/app.jar”]</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="进入Docker的世界"><a href="#进入Docker的世界" class="headerlink" title="进入Docker的世界"></a>进入Docker的世界</h2><ul>
<li><p>0x01. 在Spring项目根目录下根据Dockerfile来生成docker镜像</p>
<pre><code>`docker build -t springindocker .`
</code></pre></li>
<li><p>0x02. 从刚创建的镜像来启动容器</p>
<pre><code>`docker run -d -p 8080:8080 springindocker`
</code></pre></li>
<li><p>0x03. 打开浏览器，或者使用 curl 访问<code>http://127.0.0.1:8080</code>就可以看到web服务器里返回的<code>Hello Docker!!!</code>问好的字符了</p>
</li>
</ul>
<p>至此就说明你成功将一个基于 Spring Boot 的应用 Docker 化了。</p>
<blockquote>
<p>本文虽然只是以一个Demo，但一个大型的web项目无非也就是由诸多这种Rest服务，外加各种基础设施、数据库、通信、中间件以及调度来构成，每个子元素的开发也依然遵循这里的基本流程。</p>
</blockquote>
<hr>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><ul>
<li><a href="https://www.jianshu.com/u/d19536b0189b" target="_blank" rel="noopener">作者更多的原创文章在此</a></li>
</ul>
<p>作者更多的SpringBt实践文章在此：</p>
<ul>
<li><p><a href="https://www.jianshu.com/p/8f226206ca30" target="_blank" rel="noopener">ElasticSearch搜索引擎在SpringBoot中的实践</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/761b7538592e" target="_blank" rel="noopener">初探Kotlin+SpringBoot联合编程</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/780a1bf46a1f" target="_blank" rel="noopener">Spring Boot日志框架实践</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/c88b0f17f62a" target="_blank" rel="noopener">SpringBoot优雅编码之：Lombok加持</a></p>
</li>
</ul>
<hr>
<hr>
<p>最后附上个人联系方式，欢迎大家交流学习：<br>简    书：<a href="https://www.jianshu.com/u/d19536b0189b" target="_blank" rel="noopener">https://www.jianshu.com/u/d19536b0189b</a><br>个人博客：www.hansonwang99.com.cn<br>个人网站：<a href="http://113.209.119.170/" target="_blank" rel="noopener">http://113.209.119.170/</a> （捂脸的表情，很慢，1G 1M 1核的云主机上）</p>
<p><img src="https://hansonwang99.github.io/img/wechat_qrcode.jpg" title="欢迎扫描我的二维码！"></p>
]]></content>
      
        <categories>
            
            <category> SpringBt实践录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SpringBt </tag>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringBoot优雅编码之：Lombok加持]]></title>
      <url>/2018/04/09/SpringBoot%E4%BC%98%E9%9B%85%E7%BC%96%E7%A0%81%E4%B9%8B%EF%BC%9ALombok%E5%8A%A0%E6%8C%81/</url>
      <content type="html"><![CDATA[<p>Lombok 通过提供简单的语法注解形式来帮助简化消除一些必须有但显得很臃肿的 java 代码。典型的是对于 POJO对象的简化（如自动帮我们生成Setter和Gett…</p>
<a id="more"></a>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-c42324ac6d3dea9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="小米游戏本"></p>
<hr>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Lombok 通过提供简单的语法注解形式来帮助简化消除一些必须有但显得很臃肿的 java 代码。典型的是对于 POJO对象的简化（如自动帮我们生成Setter和Getter等），有了Lombok的加持，开发人员可以免去很多重复且臃肿的操作，<strong>极大地提高java代码的信噪比</strong>，因此我们必须尝试并应用起来！</p>
<hr>
<h2 id="IntelliJ-IDEA上配置"><a href="#IntelliJ-IDEA上配置" class="headerlink" title="IntelliJ IDEA上配置"></a>IntelliJ IDEA上配置</h2><p><strong>方法一：直接在IDEA界面中配置</strong></p>
<ul>
<li>首先进入Plugins界面：</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-ce4c31b0a27f14b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="进入Plugins界面"></p>
<ul>
<li>然后搜索并安装Lombok插件：</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-058a5957203d6903.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="安装Lombok插件"></p>
<ul>
<li>最后不要忘了开启Annotation Processors的Enable选项：</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-50078c29c55e51d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Enable Annotation Processors"></p>
<p>上述安装完成以后需要重启IDEA生效！</p>
<hr>
<p><strong>方法二：手动下载Lombok插件安装</strong></p>
<p>有时由于网络原因，上面方法一这种方式安装失败，因此只能手动下载安装</p>
<ul>
<li><p>下载lombok插件：<br><a href="https://github.com/mplushnikov/lombok-intellij-plugin/releases" target="_blank" rel="noopener">https://github.com/mplushnikov/lombok-intellij-plugin/releases</a></p>
</li>
<li><p>Plugins -&gt; Install plugin from disk… 选择下载的zip包安装</p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-069cd051b5acf50e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="选择lombok的zip包来安装"></p>
<ul>
<li>重启idea即可</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-3069589f39fcbb1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="重启IDEA生效"></p>
<p>IDE中设置完成以后需要在pom.xml中添加如下所示的lombok依赖才能使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;1.16.16&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Lombok主要注解"><a href="#Lombok主要注解" class="headerlink" title="Lombok主要注解"></a>Lombok主要注解</h2><ul>
<li><code>@Getter and @Setter</code> / 自动为属性提供 Set和Get 方法</li>
<li><code>@ToString</code> / 该注解的作用是为类自动生成toString()方法</li>
<li><code>@EqualsAndHashCode</code> / 为对象字段自动生成hashCode和equals实现</li>
<li><code>@AllArgsConstructor, @RequiredArgsConstructor and @NoArgsConstructor</code> / 顾名思义，为类自动生成对应参数的constructor</li>
<li><code>@Log, @Log4j, @Log4j2, @Slf4j, @XSlf4j, @CommonsLog, @JBossLog</code> / 自动为类添加对应的log支持</li>
<li><code>@Data</code> / 自动为所有字段添加@ToString, @EqualsAndHashCode, @Getter，为非final字段添加@Setter,和@RequiredArgsConstructor，本质上相当于几个注解的综合效果</li>
<li><code>@NonNull</code> / 自动帮助我们避免空指针。作用在方法参数上的注解，用于自动生成空值参数检查</li>
<li><code>@Cleanup</code> / 自动帮我们调用close()方法。作用在局部变量上，在作用域结束时会自动调用close方法释放资源</li>
</ul>
<p>下文就Lombok中用的最为频繁的<code>@Data</code>和<code>@Log</code>注解进行代码实战！</p>
<hr>
<h2 id="Data注解使用"><a href="#Data注解使用" class="headerlink" title="@Data注解使用"></a>@Data注解使用</h2><p>官网关于@Data注解的解释如下：</p>
<blockquote>
<p>All together now: A shortcut for @ToString, @EqualsAndHashCode, @Getter on all fields, @Setter on all non-final fields, and @RequiredArgsConstructor!</p>
</blockquote>
<p>不难理解，其可以看成是多个Lombok注解的集成，因此使用很方便！</p>
<ul>
<li>先来创建一个POJO实体UserLombok，普通的写法如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">public class UserLombok &#123;</span><br><span class="line">  private final String name;</span><br><span class="line">  private int age;</span><br><span class="line">  private double score;</span><br><span class="line">  private String[] tags;</span><br><span class="line">  </span><br><span class="line">  public UserLombok(String name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public String getName() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  void setAge(int age) &#123;</span><br><span class="line">    this.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public int getAge() &#123;</span><br><span class="line">    return this.age;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void setScore(double score) &#123;</span><br><span class="line">    this.score = score;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public double getScore() &#123;</span><br><span class="line">    return this.score;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public String[] getTags() &#123;</span><br><span class="line">    return this.tags;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void setTags(String[] tags) &#123;</span><br><span class="line">    this.tags = tags;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Override public String toString() &#123;</span><br><span class="line">    return &quot;DataExample(&quot; + this.getName() + &quot;, &quot; + this.getAge() + &quot;, &quot; + this.getScore() + &quot;, &quot; + Arrays.deepToString(this.getTags()) + “)”;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  protected boolean canEqual(Object other) &#123;</span><br><span class="line">    return other instanceof DataExample;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Override public boolean equals(Object o) &#123;</span><br><span class="line">    if (o == this) return true;</span><br><span class="line">    if (!(o instanceof DataExample)) return false;</span><br><span class="line">    DataExample other = (DataExample) o;</span><br><span class="line">    if (!other.canEqual((Object)this)) return false;</span><br><span class="line">    if (this.getName() == null ? other.getName() != null : !this.getName().equals(other.getName())) return false;</span><br><span class="line">    if (this.getAge() != other.getAge()) return false;</span><br><span class="line">    if (Double.compare(this.getScore(), other.getScore()) != 0) return false;</span><br><span class="line">    if (!Arrays.deepEquals(this.getTags(), other.getTags())) return false;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Override public int hashCode() &#123;</span><br><span class="line">    final int PRIME = 59;</span><br><span class="line">    int result = 1;</span><br><span class="line">    final long temp1 = Double.doubleToLongBits(this.getScore());</span><br><span class="line">    result = (result*PRIME) + (this.getName() == null ? 43 : this.getName().hashCode());</span><br><span class="line">    result = (result*PRIME) + this.getAge();</span><br><span class="line">    result = (result*PRIME) + (int)(temp1 ^ (temp1 &gt;&gt;&gt; 32));</span><br><span class="line">    result = (result*PRIME) + Arrays.deepHashCode(this.getTags());</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Lombok加持后，写法可简化为：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class UserLombok &#123;</span><br><span class="line">    private final String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private double score;</span><br><span class="line">    private String[] tags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在IDEA中使用时，Lombok的注解会自动补全，如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-ba5cc7dd3ba9db4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Lombok注解自动补全"></p>
<ul>
<li>我们来写POJO的测试代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main( String[] args ) &#123;</span><br><span class="line">    UserLombok userLombok = new UserLombok(&quot;hansonwang99”);</span><br><span class="line">    userLombok.setAge(18);</span><br><span class="line">    String[] array = new String[]&#123;&quot;apple&quot;,&quot;juice”&#125;;</span><br><span class="line">    userLombok.setTags( array );</span><br><span class="line">    userLombok.setScore( 99.0 );</span><br><span class="line">    System.out.println(userLombok);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由下图我们可以看到IDEA依然可以自动为我们补全由Lombok自动生成的代码：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-dcef011e78acfc02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="自动生成的代码"></p>
<ul>
<li>结果打印</li>
</ul>
<p>由于Lombok为我们自动生成了toString方法，因此对象的打印结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UserLombok(name=hansonwang99, age=18, score=99.0, tags=[apple, juice])</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Log注解实战"><a href="#Log注解实战" class="headerlink" title="@Log注解实战"></a>@Log注解实战</h2><p>在我的文章 <a href="https://www.jianshu.com/p/780a1bf46a1f" target="_blank" rel="noopener">Spring Boot日志框架实践</a> 一文中，我们使用Log4j2来作为日志对象，其写法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/testlogging”)</span><br><span class="line">public class LoggingTestController &#123;</span><br><span class="line"></span><br><span class="line">    private final Logger logger = LogManager.getLogger(this.getClass());</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/hello”)</span><br><span class="line">    public String hello() &#123;</span><br><span class="line">        for(int i=0;i&lt;10_0000;i++)&#123;</span><br><span class="line">            logger.info(&quot;info execute index method”);</span><br><span class="line">            logger.warn(&quot;warn execute index method”);</span><br><span class="line">            logger.error(&quot;error execute index method”);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return &quot;My First SpringBoot Application”;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若改用Lombok后，写法变得更加简洁，我们只需要引入对应的@Log注解即可完成log对象的生成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/testloggingwithlombok”)</span><br><span class="line">@Log4j2</span><br><span class="line">public class LoggingTestControllerLombok &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/hello”)</span><br><span class="line">    public String hello() &#123;</span><br><span class="line">        for(int i=0;i&lt;10_0000;i++)&#123;</span><br><span class="line">            log.info(&quot;info execute index method”);</span><br><span class="line">            log.warn(&quot;warn execute index method”);</span><br><span class="line">            log.error(&quot;error execute index method”);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return &quot;My First SpringBoot Application”;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>怎么样，是不是一切都是那么地优雅！</p>
<hr>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><ul>
<li><a href="https://www.jianshu.com/u/d19536b0189b" target="_blank" rel="noopener">作者更多的原创文章在此</a></li>
</ul>
<p>作者更多的SpringBt实践文章在此：</p>
<ul>
<li><a href="https://www.jianshu.com/p/8f226206ca30" target="_blank" rel="noopener">ElasticSearch搜索引擎在SpringBoot中的实践</a></li>
<li><a href="https://www.jianshu.com/p/761b7538592e" target="_blank" rel="noopener">初探Kotlin+SpringBoot联合编程</a></li>
</ul>
<hr>
<hr>
<p>最后附上个人联系方式，欢迎大家交流学习：<br>简    书：<a href="https://www.jianshu.com/u/d19536b0189b" target="_blank" rel="noopener">https://www.jianshu.com/u/d19536b0189b</a><br>个人博客：www.hansonwang99.com.cn<br>个人网站：<a href="http://113.209.119.170/" target="_blank" rel="noopener">http://113.209.119.170/</a> （捂脸的表情，很慢，1G 1M 1核的云主机上）</p>
<p><img src="https://hansonwang99.github.io/img/wechat_qrcode.jpg" title="欢迎扫描我的二维码！"></p>
<p>备注：<br>我的博客即将搬运同步至腾讯云+社区，邀请大家一同入驻：<a href="https://cloud.tencent.com/developer/support-plan?invite_code=mktjl93qouow" target="_blank" rel="noopener">https://cloud.tencent.com/developer/support-plan?invite_code=mktjl93qouow</a></p>
]]></content>
      
        <categories>
            
            <category> SpringBt实践录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SpringBt </tag>
            
            <tag> Lombok </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[利用ELK搭建Docker容器化应用日志中心]]></title>
      <url>/2018/04/03/%E5%88%A9%E7%94%A8ELK%E6%90%AD%E5%BB%BADocker%E5%AE%B9%E5%99%A8%E5%8C%96%E5%BA%94%E7%94%A8%E6%97%A5%E5%BF%97%E4%B8%AD%E5%BF%83/</url>
      <content type="html"><![CDATA[<p>ELK系列实践文章</p>
<a id="more"></a>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-058fccf603399a1a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="封面图片"></p>
<hr>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>应用一旦容器化以后，需要考虑的就是如何采集位于Docker容器中的应用程序的打印日志供运维分析。典型的比如 <a href="https://www.jianshu.com/p/780a1bf46a1f" target="_blank" rel="noopener">SpringBoot应用的日志</a> 收集。本文即将阐述如何利用ELK日志中心来收集容器化应用程序所产生的日志，并且可以用可视化的方式对日志进行查询与分析，其架构如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-35ef53cd1f337c14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="架构图"></p>
<hr>
<h2 id="镜像准备"><a href="#镜像准备" class="headerlink" title="镜像准备"></a>镜像准备</h2><p><img src="https://upload-images.jianshu.io/upload_images/9824247-5f31f9ee71f7ba5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="镜像准备"></p>
<ul>
<li>ElasticSearch镜像</li>
<li>Logstash镜像</li>
<li>Kibana镜像</li>
<li>Nginx镜像（作为容器化应用来生产日志）</li>
</ul>
<hr>
<h2 id="开启Linux系统Rsyslog服务"><a href="#开启Linux系统Rsyslog服务" class="headerlink" title="开启Linux系统Rsyslog服务"></a>开启Linux系统Rsyslog服务</h2><p>修改Rsyslog服务配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/rsyslog.conf</span><br></pre></td></tr></table></figure>
<p>开启下面三个参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ModLoad imtcp</span><br><span class="line">$InputTCPServerRun 514</span><br><span class="line"></span><br><span class="line">*.* @@localhost:4560</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-9e803d8736017db4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="开启3个参数"></p>
<p>意图很简单：让Rsyslog加载imtcp模块并监听514端口，然后将Rsyslog中收集的数据转发到本地4560端口！</p>
<p>然后重启Rsyslog服务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart rsyslog</span><br></pre></td></tr></table></figure>
<p>查看rsyslog启动状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tnl</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-09013bdf2495704f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="netstat -tnl"></p>
<hr>
<h2 id="部署ElasticSearch服务"><a href="#部署ElasticSearch服务" class="headerlink" title="部署ElasticSearch服务"></a>部署ElasticSearch服务</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -d  -p 9200:9200 \</span><br><span class="line"> -v ~/elasticsearch/data:/usr/share/elasticsearch/data \</span><br><span class="line"> --name elasticsearch elasticsearch</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-8701c462e99e614a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ES启动成功效果"></p>
<hr>
<h2 id="部署Logstash服务"><a href="#部署Logstash服务" class="headerlink" title="部署Logstash服务"></a>部署Logstash服务</h2><p>添加 <code>~/logstash/logstash.conf</code> 配置文件如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  syslog &#123;</span><br><span class="line">    type =&gt; &quot;rsyslog&quot;</span><br><span class="line">    port =&gt; 4560</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    hosts =&gt; [ &quot;elasticsearch:9200&quot; ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置中我们让Logstash从本地的Rsyslog服务中取出应用日志数据，然后转发到ElasticSearch数据库中！</p>
<p>配置完成以后，可以通过如下命令来启动Logstash容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 4560:4560 \</span><br><span class="line">-v ~/logstash/logstash.conf:/etc/logstash.conf \</span><br><span class="line">--link elasticsearch:elasticsearch \</span><br><span class="line">--name logstash logstash \</span><br><span class="line">logstash -f /etc/logstash.conf</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-c1a3b1ca89e4c7df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<hr>
<h2 id="部署Kibana服务"><a href="#部署Kibana服务" class="headerlink" title="部署Kibana服务"></a>部署Kibana服务</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5601:5601 \</span><br><span class="line">--link elasticsearch:elasticsearch \</span><br><span class="line">-e ELASTICSEARCH_URL=http://elasticsearch:9200 \</span><br><span class="line">--name kibana kibana</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-688bcd5bf95e7da5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<hr>
<h2 id="启动nginx容器来生产日志"><a href="#启动nginx容器来生产日志" class="headerlink" title="启动nginx容器来生产日志"></a>启动nginx容器来生产日志</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 90:80 --log-driver syslog --log-opt \</span><br><span class="line">syslog-address=tcp://localhost:514 \</span><br><span class="line">--log-opt tag=&quot;nginx&quot; --name nginx nginx</span><br></pre></td></tr></table></figure>
<p>很明显Docker容器中的Nginx应用日志转发到本地syslog服务中，然后由syslog服务将数据转给Logstash进行收集。</p>
<p>至此，日志中心搭建完毕，目前一共四个容器在工作：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-0ae9a1be2fb9f86b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="实验验证"><a href="#实验验证" class="headerlink" title="实验验证"></a>实验验证</h2><ul>
<li><p>浏览器打开<code>localhost:90</code>来打开Nginx界面，并刷新几次，让后台产生GET请求的日志</p>
</li>
<li><p>打开Kibana可视化界面：<code>localhost:5601</code></p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-6cda91b21f1c0b50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="localhost:5601"></p>
<ul>
<li>收集Nginx应用日志</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-86fe3ba2c9e9889a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="收集Nginx应用日志"></p>
<ul>
<li>查询应用日志</li>
</ul>
<p>在查询框中输入<code>program=nginx</code>可查询出特定日志</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-2870e77bbc2cf67b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查询应用日志"></p>
<hr>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><ul>
<li><p><a href="https://www.jianshu.com/p/04f4d7b4a1d3" target="_blank" rel="noopener">CentOS7上ElasticSearch安装填坑记</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/8f226206ca30" target="_blank" rel="noopener">ElasticSearch搜索引擎在SpringBoot中的实践</a></p>
</li>
</ul>
<ul>
<li>[作者更多的原创文章在此](<a href="https://www.jianshu.com/u/d19536b0189nsonwang99.com.cn" target="_blank" rel="noopener">https://www.jianshu.com/u/d19536b0189nsonwang99.com.cn</a></li>
</ul>
<hr>
<hr>
<p>最后附上个人联系方式，欢迎大家交流学习：<br>简    书：<a href="https://www.jianshu.com/u/d19536b0189b" target="_blank" rel="noopener">https://www.jianshu.com/u/d19536b0189b</a><br>个人博客：www.hansonwang99.com.cn<br>个人网站：<a href="http://113.209.119.170/" target="_blank" rel="noopener">http://113.209.119.170/</a> （捂脸的表情，很慢，1G 1M 1核的云主机上）</p>
<p><img src="https://hansonwang99.github.io/img/wechat_qrcode.jpg" title="欢迎扫描我的二维码！"></p>
]]></content>
      
        <categories>
            
            <category> ELK </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Docker </tag>
            
            <tag> ELK </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring Boot日志框架实践]]></title>
      <url>/2018/03/29/Boot%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%AE%9E%E8%B7%B5/</url>
      <content type="html"><![CDATA[<p>Spring Boot使用Apache的Commons Logging作为内部的日志框架，其仅仅是一个日志接口，在实际应用中需要为该接口来指定相应的日志实现。</p>
<p>SpringBt默认的日志实现是Java Util Logging，是JDK自带的日志包，此外SpringBt当然也支持Log4J、Logback这类很流行的日志实现。</p>
<a id="more"></a>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-1da5cd24b2cf0ada.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CASIO G-SHOCK"></p>
<hr>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java应用中，日志一般分为以下5个级别：</p>
<ul>
<li>ERROR 错误信息</li>
<li>WARN 警告信息</li>
<li>INFO 一般信息</li>
<li>DEBUG 调试信息</li>
<li>TRACE 跟踪信息</li>
</ul>
<p>Spring Boot使用Apache的Commons Logging作为内部的日志框架，其仅仅是一个日志接口，在实际应用中需要为该接口来指定相应的日志实现。</p>
<p>SpringBt默认的日志实现是Java Util Logging，是JDK自带的日志包，此外SpringBt当然也支持Log4J、Logback这类很流行的日志实现。</p>
<p>统一将上面这些<strong>日志实现</strong>统称为<strong>日志框架</strong></p>
<p>下面我们来实践一下！</p>
<hr>
<h2 id="使用Spring-Boot-Logging插件"><a href="#使用Spring-Boot-Logging插件" class="headerlink" title="使用Spring Boot Logging插件"></a>使用Spring Boot Logging插件</h2><ul>
<li>首先application.properties文件中加配置：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.level.root=INFO</span><br></pre></td></tr></table></figure>
<ul>
<li>控制器部分代码如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.hansonwang99.controller;</span><br><span class="line"></span><br><span class="line">import com.hansonwang99.K8sresctrlApplication;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/testlogging&quot;)</span><br><span class="line">public class LoggingTestController &#123;</span><br><span class="line">    private static Logger logger = LoggerFactory.getLogger(K8sresctrlApplication.class);</span><br><span class="line">    @GetMapping(&quot;/hello&quot;)</span><br><span class="line">    public String hello() &#123;</span><br><span class="line">        logger.info(&quot;test logging...&quot;);</span><br><span class="line">        return &quot;hello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>运行结果</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-bd4b067de60cdd0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行结果"></p>
<p>由于将日志等级设置为INFO，因此包含INFO及以上级别的日志信息都会打印出来</p>
<p>这里可以看出，很多大部分的INFO日志均来自于SpringBt框架本身，如果我们想屏蔽它们，可以将日志级别统一先全部设置为ERROR，这样框架自身的INFO信息不会被打印。然后再将应用中特定的包设置为DEBUG级别的日志，这样就可以只看到所关心的包中的DEBUG及以上级别的日志了。</p>
<ul>
<li>控制特定包的日志级别</li>
</ul>
<p>application.yml中改配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    root: error</span><br><span class="line">    com.hansonwang99.controller: debug</span><br></pre></td></tr></table></figure>
<p>很明显，将root日志级别设置为ERROR，然后再将<code>com.hansonwang99.controller</code>包的日志级别设为DEBUG，此即：即先禁止所有再允许个别的 设置方法</p>
<ul>
<li>控制器代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.hansonwang99.controller;</span><br><span class="line"></span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/testlogging&quot;)</span><br><span class="line">public class LoggingTestController &#123;</span><br><span class="line">    private Logger logger = LoggerFactory.getLogger(this.getClass());</span><br><span class="line">    @GetMapping(&quot;/hello&quot;)</span><br><span class="line">    public String hello() &#123;</span><br><span class="line">        logger.info(&quot;test logging...&quot;);</span><br><span class="line">        return &quot;hello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>运行结果</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-816b9c37ed438f23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行结果"></p>
<p>可见框架自身的INFO级别日志全部藏匿，而指定包中的日志按级别顺利地打印出来</p>
<ul>
<li>将日志输出到某个文件中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    root: error</span><br><span class="line">    com.hansonwang99.controller: debug</span><br><span class="line">  file: $&#123;user.home&#125;/logs/hello.log</span><br></pre></td></tr></table></figure>
<ul>
<li>运行结果</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-262f588ab4e1ae3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行结果"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-b363ec7f55e6bde8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行结果"></p>
<p>使用Spring Boot Logging，我们发现虽然日志已输出到文件中，但控制台中依然会打印一份，发现用<code>org.slf4j.Logger</code>是无法解决这个问题的</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-6705397ef2f47fbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="v运行结果"></p>
<hr>
<h2 id="集成Log4J日志框架"><a href="#集成Log4J日志框架" class="headerlink" title="集成Log4J日志框架"></a>集成Log4J日志框架</h2><ul>
<li>pom.xml中添加依赖</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">     &lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">	&lt;exclusions&gt;</span><br><span class="line">		&lt;exclusion&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;</span><br><span class="line">		&lt;/exclusion&gt;</span><br><span class="line">	&lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>在resources目录下添加<code>log4j2.xml</code>文件，内容如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line"></span><br><span class="line">    &lt;appenders&gt;</span><br><span class="line">        &lt;File name=&quot;file&quot; fileName=&quot;$&#123;sys:user.home&#125;/logs/hello2.log&quot;&gt;</span><br><span class="line">            &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss,SSS&#125; %p %c (%L) - %m%n&quot;/&gt;</span><br><span class="line">        &lt;/File&gt;</span><br><span class="line">    &lt;/appenders&gt;</span><br><span class="line"></span><br><span class="line">    &lt;loggers&gt;</span><br><span class="line"></span><br><span class="line">        &lt;root level=&quot;ERROR&quot;&gt;</span><br><span class="line">            &lt;appender-ref ref=&quot;file&quot;/&gt;</span><br><span class="line">        &lt;/root&gt;</span><br><span class="line">        &lt;logger name=&quot;com.hansonwang99.controller&quot; level=&quot;DEBUG&quot; /&gt;</span><br><span class="line">    &lt;/loggers&gt;</span><br><span class="line"></span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>其他代码都保持不变</li>
</ul>
<p>运行程序发现控制台没有日志输出，而hello2.log文件中有内容，这符合我们的预期：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-9343bfb13a72496d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行结果"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-42154fe6a48575b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行结果"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-230ac6c751ff8967.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行结果"></p>
<p>而且日志格式和<code>pattern=&quot;%d{HH:mm:ss,SSS} %p %c (%L) - %m%n&quot;</code>格式中定义的相匹配</p>
<hr>
<h2 id="Log4J更进一步实践"><a href="#Log4J更进一步实践" class="headerlink" title="Log4J更进一步实践"></a>Log4J更进一步实践</h2><ul>
<li>pom.xml配置：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">	&lt;exclusions&gt;</span><br><span class="line">		&lt;exclusion&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;</span><br><span class="line">		&lt;/exclusion&gt;</span><br><span class="line">	&lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>log4j2.xml配置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;configuration status=&quot;warn&quot;&gt;</span><br><span class="line">    &lt;properties&gt;</span><br><span class="line"></span><br><span class="line">        &lt;Property name=&quot;app_name&quot;&gt;springboot-web&lt;/Property&gt;</span><br><span class="line">        &lt;Property name=&quot;log_path&quot;&gt;logs/$&#123;app_name&#125;&lt;/Property&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line">    &lt;appenders&gt;</span><br><span class="line">        &lt;console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;</span><br><span class="line">            &lt;PatternLayout pattern=&quot;[%d][%t][%p][%l] %m%n&quot; /&gt;</span><br><span class="line">        &lt;/console&gt;</span><br><span class="line"></span><br><span class="line">        &lt;RollingFile name=&quot;RollingFileInfo&quot; fileName=&quot;$&#123;log_path&#125;/info.log&quot;</span><br><span class="line">                     filePattern=&quot;$&#123;log_path&#125;/$$&#123;date:yyyy-MM&#125;/info-%d&#123;yyyy-MM-dd&#125;-%i.log.gz&quot;&gt;</span><br><span class="line">            &lt;Filters&gt;</span><br><span class="line">                &lt;ThresholdFilter level=&quot;INFO&quot; /&gt;</span><br><span class="line">                &lt;ThresholdFilter level=&quot;WARN&quot; onMatch=&quot;DENY&quot;</span><br><span class="line">                                 onMismatch=&quot;NEUTRAL&quot; /&gt;</span><br><span class="line">            &lt;/Filters&gt;</span><br><span class="line">            &lt;PatternLayout pattern=&quot;[%d][%t][%p][%c:%L] %m%n&quot; /&gt;</span><br><span class="line">            &lt;Policies&gt;</span><br><span class="line">                &lt;!-- 归档每天的文件 --&gt;</span><br><span class="line">                &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; modulate=&quot;true&quot; /&gt;</span><br><span class="line">                &lt;!-- 限制单个文件大小 --&gt;</span><br><span class="line">                &lt;SizeBasedTriggeringPolicy size=&quot;2 MB&quot; /&gt;</span><br><span class="line">            &lt;/Policies&gt;</span><br><span class="line">            &lt;!-- 限制每天文件个数 --&gt;</span><br><span class="line">            &lt;DefaultRolloverStrategy compressionLevel=&quot;0&quot; max=&quot;10&quot;/&gt;</span><br><span class="line">        &lt;/RollingFile&gt;</span><br><span class="line"></span><br><span class="line">        &lt;RollingFile name=&quot;RollingFileWarn&quot; fileName=&quot;$&#123;log_path&#125;/warn.log&quot;</span><br><span class="line">                     filePattern=&quot;$&#123;log_path&#125;/$$&#123;date:yyyy-MM&#125;/warn-%d&#123;yyyy-MM-dd&#125;-%i.log.gz&quot;&gt;</span><br><span class="line">            &lt;Filters&gt;</span><br><span class="line">                &lt;ThresholdFilter level=&quot;WARN&quot; /&gt;</span><br><span class="line">                &lt;ThresholdFilter level=&quot;ERROR&quot; onMatch=&quot;DENY&quot;</span><br><span class="line">                                 onMismatch=&quot;NEUTRAL&quot; /&gt;</span><br><span class="line">            &lt;/Filters&gt;</span><br><span class="line">            &lt;PatternLayout pattern=&quot;[%d][%t][%p][%c:%L] %m%n&quot; /&gt;</span><br><span class="line">            &lt;Policies&gt;</span><br><span class="line">                &lt;!-- 归档每天的文件 --&gt;</span><br><span class="line">                &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; modulate=&quot;true&quot; /&gt;</span><br><span class="line">                &lt;!-- 限制单个文件大小 --&gt;</span><br><span class="line">                &lt;SizeBasedTriggeringPolicy size=&quot;2 MB&quot; /&gt;</span><br><span class="line">            &lt;/Policies&gt;</span><br><span class="line">            &lt;!-- 限制每天文件个数 --&gt;</span><br><span class="line">            &lt;DefaultRolloverStrategy compressionLevel=&quot;0&quot; max=&quot;10&quot;/&gt;</span><br><span class="line">        &lt;/RollingFile&gt;</span><br><span class="line"></span><br><span class="line">        &lt;RollingFile name=&quot;RollingFileError&quot; fileName=&quot;$&#123;log_path&#125;/error.log&quot;</span><br><span class="line">                     filePattern=&quot;$&#123;log_path&#125;/$$&#123;date:yyyy-MM&#125;/error-%d&#123;yyyy-MM-dd&#125;-%i.log.gz&quot;&gt;</span><br><span class="line">            &lt;ThresholdFilter level=&quot;ERROR&quot; /&gt;</span><br><span class="line">            &lt;PatternLayout pattern=&quot;[%d][%t][%p][%c:%L] %m%n&quot; /&gt;</span><br><span class="line">            &lt;Policies&gt;</span><br><span class="line">                &lt;!-- 归档每天的文件 --&gt;</span><br><span class="line">                &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; modulate=&quot;true&quot; /&gt;</span><br><span class="line">                &lt;!-- 限制单个文件大小 --&gt;</span><br><span class="line">                &lt;SizeBasedTriggeringPolicy size=&quot;2 MB&quot; /&gt;</span><br><span class="line">            &lt;/Policies&gt;</span><br><span class="line">            &lt;!-- 限制每天文件个数 --&gt;</span><br><span class="line">            &lt;DefaultRolloverStrategy compressionLevel=&quot;0&quot; max=&quot;10&quot;/&gt;</span><br><span class="line">        &lt;/RollingFile&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/appenders&gt;</span><br><span class="line"></span><br><span class="line">    &lt;loggers&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &lt;root level=&quot;info&quot;&gt;</span><br><span class="line">            &lt;appender-ref ref=&quot;Console&quot; /&gt;</span><br><span class="line">            &lt;appender-ref ref=&quot;RollingFileInfo&quot; /&gt;</span><br><span class="line">            &lt;appender-ref ref=&quot;RollingFileWarn&quot; /&gt;</span><br><span class="line">            &lt;appender-ref ref=&quot;RollingFileError&quot; /&gt;</span><br><span class="line">        &lt;/root&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/loggers&gt;</span><br><span class="line"></span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>控制器代码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.hansonwang99.controller;</span><br><span class="line"></span><br><span class="line">import org.apache.logging.log4j.LogManager;</span><br><span class="line">import org.apache.logging.log4j.Logger;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/testlogging&quot;)</span><br><span class="line">public class LoggingTestController &#123;</span><br><span class="line">    private final Logger logger = LogManager.getLogger(this.getClass());</span><br><span class="line">    @GetMapping(&quot;/hello&quot;)</span><br><span class="line">    public String hello() &#123;</span><br><span class="line">        for(int i=0;i&lt;10_0000;i++)&#123;</span><br><span class="line">            logger.info(&quot;info execute index method&quot;);</span><br><span class="line">            logger.warn(&quot;warn execute index method&quot;);</span><br><span class="line">            logger.error(&quot;error execute index method&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;My First SpringBoot Application&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>运行结果</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-c1979e6e49478356.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行结果"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-6f12823583256be7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行结果"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-3ac4e1fa54e0d1c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行结果"></p>
<p>日志会根据不同的级别存储在不同的文件，当日志文件大小超过2M以后会分多个文件压缩存储，生产环境的日志文件大小建议调整为20-50MB。</p>
<hr>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>作者更多的SpringBt实践文章在此：</p>
<ul>
<li><a href="https://www.jianshu.com/p/8f226206ca30" target="_blank" rel="noopener">ElasticSearch搜索引擎在SpringBoot中的实践</a></li>
<li><a href="https://www.jianshu.com/p/761b7538592e" target="_blank" rel="noopener">初探Kotlin+SpringBoot联合编程</a></li>
</ul>
<p><a href="https://www.jianshu.com/u/d19536b0189b" target="_blank" rel="noopener">作者更多的原创文章在此</a></p>
<hr>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-21478b8324889b8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CodeSheep"></p>
<hr>
<p>最后附上个人联系方式，欢迎大家交流学习：<br>个人博客：www.hansonwang99.com.cn<br>个人网站：<a href="http://113.209.119.170/" target="_blank" rel="noopener">http://113.209.119.170/</a> （捂脸的表情，很慢，1G1C1M，你懂的）<br>简    书：<a href="https://www.jianshu.com/u/d19536b0189b" target="_blank" rel="noopener">https://www.jianshu.com/u/d19536b0189b</a></p>
<p><img src="https://hansonwang99.github.io/img/wechat_qrcode.jpg" title="欢迎扫描我的二维码！"></p>
<hr>
]]></content>
      
        <categories>
            
            <category> SpringBt学习录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SpringBt </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[利用K8S技术栈打造个人私有云（连载之：私有云客户端打造）]]></title>
      <url>/2018/03/23/%E5%88%A9%E7%94%A8K8S%E6%8A%80%E6%9C%AF%E6%A0%88%E6%89%93%E9%80%A0%E4%B8%AA%E4%BA%BA%E7%A7%81%E6%9C%89%E4%BA%91%EF%BC%88%E8%BF%9E%E8%BD%BD%E4%B9%8B%EF%BC%9A%E7%A7%81%E6%9C%89%E4%BA%91%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%89%93%E9%80%A0%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>利用K8S技术栈打造个人私有云连载文章</p>
<a id="more"></a>
<hr>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-e9d1c4b88ced1491.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="封面图片"></p>
<hr>
<p>【利用K8S技术栈打造个人私有云系列文章目录】</p>
<ul>
<li><a href="https://www.jianshu.com/p/9bc87b5380e8" target="_blank" rel="noopener">利用K8S技术栈打造个人私有云（连载之：初章） </a></li>
<li><a href="https://www.jianshu.com/p/7d1fb03b8925" target="_blank" rel="noopener">利用K8S技术栈打造个人私有云（连载之：K8S集群搭建）</a></li>
<li><a href="https://www.jianshu.com/p/5b0cd99e0332" target="_blank" rel="noopener">利用K8S技术栈打造个人私有云（连载之：K8S环境理解和练手）</a></li>
<li><a href="https://www.jianshu.com/p/e38c05cf076a" target="_blank" rel="noopener">利用K8S技术栈打造个人私有云（连载之：基础镜像制作与实验）</a></li>
<li><a href="https://www.jianshu.com/p/58a98e65074c" target="_blank" rel="noopener">利用K8S技术栈打造个人私有云（连载之：资源控制研究）</a></li>
<li><a href="https://www.jianshu.com/p/a7cdb3ab4e11" target="_blank" rel="noopener">利用K8S技术栈打造个人私有云（连载之：私有云客户端打造）</a></li>
<li>利用K8S技术栈打造个人私有云（连载之：总结）（Coming Soon…）</li>
</ul>
<hr>
<h2 id="Vue-js初摸"><a href="#Vue-js初摸" class="headerlink" title="Vue.js初摸"></a>Vue.js初摸</h2><p>本人对前端其实不是很熟悉，也是最近才接触。前端技术栈还是非常庞大的，为了能够借助已经存在的轮子来造出一辆车，所以我选择了Vue.js进行实践。</p>
<p>我觉得初学Vue.js，掌握以下四个点应该基本就能上手干活了：</p>
<ul>
<li><p><strong>声明式地渲染</strong><br>我所理解的Vue.js就是和jQuery一样是一个前端框架，它的中心思想就是数据驱动，像远古时代的老前辈jQuery是结构驱动，什么意思呢，以前我们写代码时常用<code>$(&#39;.dom&#39;).text(&#39;我把值改变了&#39;)</code>，这种写法先要获得结构，然后再修改数据更新结构，而Vue的做法直接就是<code>this.msg=&quot;我改变了&quot;</code>，然后msg就会同步到某个结构上，视图管理抽象为数据管理，而不是管理dom结构了。</p>
</li>
<li><p><strong>组件化的系统</strong></p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-0fb39298f9a2cb2d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="组件树结构"></p>
<p>基本可以理解为一个大的页面都是由一个个小的组件所堆积起来了，Vue可以对每个小组件进行很好的描述，并写成.vue格式的文件，正如上图所示。</p>
<ul>
<li><p><strong>客户端的路由</strong><br>传统意义上的路由是由服务器端根据一定的URL规则匹配来返回给前端不同的页面代码，而实际上前端也可以根据锚点的方式实现路由切换，因此在Vue.js里面，只需我们去配置路由表实现锚点路由即可，与后端无关。</p>
</li>
<li><p><strong>状态的管理</strong><br>Vue的状态管理依靠Vuex完成， 用其来管理Vue的所有组件状态。<br>所谓的状态可以是诸如：</p>
<ul>
<li>sidebar的打开与关闭</li>
<li>theme主题的切换</li>
<li>cookie的内容切换</li>
<li>当前登录的用户切换</li>
<li>…</li>
</ul>
</li>
</ul>
<p>开发大型单页应用（SPA），会出现多个视图组件去维护多个状态，而且有交叉。遇到以上情况时候，你就应该考虑使用Vuex了，它能把组件的共享状态抽取出来，当做一个全局单例模式进行管理。这样不管你在何处改变状态，都会通知使用该状态的组件做出相应修改。</p>
<p>理论部分就讲这些了，初学者不BB太多，下面说说客户端页面打造的情况吧。</p>
<hr>
<h2 id="私有云客户端打造"><a href="#私有云客户端打造" class="headerlink" title="私有云客户端打造"></a>私有云客户端打造</h2><ul>
<li>主页面</li>
</ul>
<p>首先是主页面，可以打开任何一个云主机系统的页面看，基本类似。目前左边Sidebar就<strong>实例</strong>菜单是有用的。</p>
<p>页面中心的主要内容是当前系统中创建的一些主机实例的情况预览，一行一个，计划可以对其进行删除和重启操作</p>
<p>页面右上角点击 <strong>“创建”</strong> 按钮即可以实例化一个主机</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-483698297137eabb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="私有云主页面"></p>
<ul>
<li>创建云主机页面</li>
</ul>
<p>这里计划可以向XXX云一样可以自行选购配置，然后实例化，包括系统规格、CPU、内存、硬盘等等</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-e919b47f3957f454.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建云主机页面"></p>
<ul>
<li>云主机配置选择页面</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-f98376c076bdc3e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="云主机配置选择页面"></p>
<ul>
<li>云主机配置浏览页面</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-6a38d7bc09431cfd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="云主机配置浏览页面"></p>
<p>目前选择好配置以后点击创建所得到的云主机规格还是默认的，这些所选规格参数还未和实际实例化后的主机参数对应起来，里面还有很多东西要研究。</p>
<hr>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p><a href="https://www.jianshu.com/u/d19536b0189b" target="_blank" rel="noopener">作者更多的原创文章在此</a></p>
<hr>
<p>最后附上个人联系方式，欢迎大家交流学习：<br>个人博客：www.hansonwang99.com.cn<br>个人网站：<a href="http://113.209.119.170/" target="_blank" rel="noopener">http://113.209.119.170/</a> （捂脸的表情，很慢，1G 1M 1核的云主机上）<br>简    书：<a href="https://www.jianshu.com/u/d19536b0189b" target="_blank" rel="noopener">https://www.jianshu.com/u/d19536b0189b</a></p>
<p><img src="https://hansonwang99.github.io/img/wechat_qrcode.jpg" title="欢迎扫描我的二维码！"></p>
]]></content>
      
        <categories>
            
            <category> K8s沉思录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Pipeline As Code With Jenkins2.0]]></title>
      <url>/2018/03/20/Pipeline-As-Code-With-Jenkins2.0/</url>
      <content type="html"><![CDATA[<p>Jenkins系列实践文章</p>
<a id="more"></a>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-dbd6b84206381f8e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="封面图片：MBP With Touch Bar（Space Gray）"></p>
<hr>
<h2 id="Jenkins2-0-Pipeline导入"><a href="#Jenkins2-0-Pipeline导入" class="headerlink" title="Jenkins2.0  Pipeline导入"></a>Jenkins2.0  Pipeline导入</h2><p>Pipeline as Code是Jenkins 2.0版本的精华所在，是帮助Jenkins实现从CI到CD华丽转身的关键工具。</p>
<p>所谓Pipeline，简单来说，就是一套运行于Jenkins上的工作流框架，将原本独立运行于单个或者多个节点的任务连接起来，实现单个任务难以完成的复杂发布流程</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-f544566a758e8902.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Pipeline实现复杂发布流程"></p>
<p>Pipeline的实现方式是一套Groovy DSL(类似Gradle)，任何发布流程都可以表述为一段Groovy脚本，并且Jenkins支持从代码库直接读取脚本，从而实现了Pipeline as Code的理念。</p>
<hr>
<h2 id="为什么要使用Jenkins2-0-Pipeline"><a href="#为什么要使用Jenkins2-0-Pipeline" class="headerlink" title="为什么要使用Jenkins2.0 Pipeline"></a>为什么要使用Jenkins2.0 Pipeline</h2><p>这里主要结合我自己对传统Jenkins Job使用的一些痛点来说：</p>
<ul>
<li><p>传统的Jenkins Job难以灵活高效地并行（Job间、节点间、任务间、甚至任务内四个维度的并行）</p>
</li>
<li><p>传统的Jenkins Job日益失控的趋势让我们措手不及，Job太多，CI脚本太离散，维护成本实在太高了，而且很危险，一单Jenkins Server挂了，一切都Game Over了</p>
</li>
<li><p>新拉分支的分支代码CI部署太麻烦了</p>
</li>
<li><p>传统的Jenkins Job显示真的是不太直观啊</p>
</li>
</ul>
<blockquote>
<p>我想这些理由应该足以让我们把目光转向Jenkins2.0的Pipeline！</p>
</blockquote>
<p><strong>Pipeline的功能和优点：</strong></p>
<ol>
<li><strong>持久性</strong>：在jenkins的master按计划和非计划的重启后，pipeline的job仍然能够工作，不受影响。其实理解起来也很简单，jenkins的master和agent通过ssh连接，如果你知道nohup或disown的话，就可以理解为啥master的重启不会影响agent上的job继续运行。</li>
<li><strong>可暂停性</strong>：pipeline基于groovy可以实现job的暂停和等待用户的输入或批准然后继续执行。</li>
<li><strong>更灵活的并行执行，更强的依赖控制</strong>，通过groovy脚本可以实现step，stage间的并行执行，和更复杂的相互依赖关系。</li>
<li><strong>可扩展性</strong>：通过groovy的编程更容易的扩展插件。</li>
<li><strong>设计Pipeline = 设计代码</strong>，很优雅</li>
<li><strong>As Code</strong>：集中管理CI脚本、用代码库来管理脚本、从代码库直接读取脚本，从而可以将项目CI迅速拉起来！</li>
</ol>
<hr>
<h2 id="Pipeline原理与流程"><a href="#Pipeline原理与流程" class="headerlink" title="Pipeline原理与流程"></a>Pipeline原理与流程</h2><p>Pipeline为用户设计了三个最最基本的概念：</p>
<ul>
<li><strong>Stage</strong>：一个Pipeline可以划分为若干个Stage，每个Stage代表一组操作。注意，Stage是一个逻辑分组的概念，可以跨多个Node。</li>
<li><strong>Node</strong>：一个Node就是一个Jenkins节点，或者是Master，或者是Agent，是执行Step的具体运行期环境。</li>
<li><strong>Step</strong>：Step是最基本的操作单元，小到创建一个目录，大到构建一个Docker镜像，由各类Jenkins Plugin提供。</li>
</ul>
<p>一个典型的Stage View如下图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-46f22a19f0780f1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="典型的Stage View"></p>
<p>从图中可以十分方便地看到哪些Stage通过，哪些Stage失败，以及构建的时间。</p>
<p>Jenkins2.0的Pipeline搭建使用的是Groovy脚本，通过Groovy脚本实现工作流管理的步骤如下：</p>
<ul>
<li>去Jenkins主界面建立Pipeline任务</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-ec813fc77ee5e081.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="建立PipeLine任务 "></p>
<p>实际上更常用的是MultiBranch Pipeline，上面的图中截图没有包含，但与普通Pipeline基本类似。</p>
<ul>
<li>使用Groovy脚本自定义工作流</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-b74e22e32c762fa5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用Groovy自定义工作流"></p>
<p>上图的实例脚本如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">node &#123; </span><br><span class="line">    stage(&apos;Checkout Code&apos;) &#123; // for display purposes </span><br><span class="line">        // Get some code from a GitHub repository </span><br><span class="line">        git &apos;https://github.com/jglick/simple-maven-project-with-tests.git&apos; </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    stage(&apos;Build&apos;) &#123; </span><br><span class="line">        // Run the maven build </span><br><span class="line">        if (isUnix()) &#123; </span><br><span class="line">            sh &quot;&apos;$&#123;MAVEN_HOME&#125;/bin/mvn&apos; -Dmaven.test.failure.ignore clean package&quot; </span><br><span class="line">        &#125; else &#123; </span><br><span class="line">            bat(/&quot;$&#123;MAVEN_HOME&#125;\bin\mvn&quot; -Dmaven.test.failure.ignore clean package/) </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    stage(&apos;Unit test&apos;) &#123; </span><br><span class="line">        junit &apos;**/target/surefire-reports/TEST-UT.xml&apos; </span><br><span class="line">        archive &apos;target/*.jar&apos; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>开始执行Pipeline</li>
</ul>
<p>构建过程的stage View如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-24339d9c5f5ff1a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="stage View"></p>
<p>很明显可以看出，这里显示的和Groovy脚本中格式化的代码是一致的，会实时显示各个工作流的执行进度和结果，直观易懂。鼠标移上去，能看到日志信息的缩略图，单击可以调到对应stage的console中。</p>
<p>总而言之，一切都是那么地优雅！</p>
<hr>
<h2 id="Jenkins2-0-Pipeline关键DSL语法及示例"><a href="#Jenkins2-0-Pipeline关键DSL语法及示例" class="headerlink" title="Jenkins2.0 Pipeline关键DSL语法及示例"></a>Jenkins2.0 Pipeline关键DSL语法及示例</h2><p>在这里总结一下Pipeline中的关键DSL语法，利用Groovy对其进行组合可以完成任何一项复杂的CI/CD流程，熟悉它们大有裨益。</p>
<ul>
<li><strong>archiveArtifacts</strong>     </li>
</ul>
<p>归档文件，举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">archiveArtifacts &apos;target/*.jar&apos;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>bat</strong>   </li>
</ul>
<p>执行windows平台下的批处理文件，如 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bat &quot;call example.bat&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>build</strong>   </li>
</ul>
<p>触发构建一个jenkins job，如 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build &apos;TEST_JOB&apos;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>checkout</strong>   </li>
</ul>
<p>从SCM系统中checkout repo，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">checkout([$class: &apos;SubversionSCM&apos;, additionalCredentials: [], excludedCommitMessages: &apos;&apos;, excludedRegions: &apos;&apos;, excludedRevprop: &apos;&apos;, excludedUsers: &apos;&apos;, filterChangelog: false, ignoreDirPropChanges: false, includedRegions: &apos;&apos;, locations: [[credentialsId: &apos;30e6c1e5-1035-4bdd-8a44-05ba8f885158&apos;, depthOption: &apos;infinity&apos;, ignoreExternalsOption: true, local: &apos;.&apos;, remote: &apos;svn://xxxxxx&apos;]], workspaceUpdater: [$class: &apos;UpdateUpdater&apos;]])</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>deleteDir()</strong>    </li>
</ul>
<p>从workspace中删除当前目录</p>
<ul>
<li><strong>dir</strong>    </li>
</ul>
<p>切换目录，如</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dir(&apos;/home/jenkins&apos;) &#123; // 切换到/home/jenkins目录中做一些事情</span><br><span class="line">    // some block</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>echo</strong>    </li>
</ul>
<p>打印信息，如 echo ‘hello world’</p>
<ul>
<li><strong>emailtext</strong>   </li>
</ul>
<p>利用Jenkins发送邮件，内容、主题全都可以自定义，如</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">emailext body: &apos;Subject_test&apos;, subject: &apos;Subject_test&apos;, to: &apos;hansonwang99@163.com.cn&apos;</span><br><span class="line">// 邮件的正文body，主题subject，收件人to等可以进行自定义</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>error</strong>    </li>
</ul>
<p>抛出一个错误信号，可以自行在代码里抛出，如 error ‘read_error’</p>
<ul>
<li><strong>fileExists</strong>   </li>
</ul>
<p>检查工作空间某个路径里是否存在某个file，举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fileExists &apos;/home/test.txt&apos;  // 检查是否存在test.txt</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>input</strong>     </li>
</ul>
<p>等待外界用户的交互输入，举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input message: &apos;&apos;, parameters: [string(defaultValue: &apos;默认值&apos;, description: &apos;版本号&apos;, name: &apos;version&apos;)] // 在某一步骤，等待用户输入version参数才能往下执行</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>isUnix</strong>      </li>
</ul>
<p>用于判断当前任务是否运行于Unix-like节点上，举例：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def flag = isUnix()</span><br><span class="line">if( flag == false ) &#123; // 可以据此进行判断</span><br><span class="line">	echo &quot;not run on a unix node !&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>load</strong>      </li>
</ul>
<p>调用一个外部groovy脚本，举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load &apos;D:\\jenkins\\workspace\\test.groovy&apos;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>node</strong>     </li>
</ul>
<p>分配节点给某个任务运行，举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node(&apos;节点标签&apos;) &#123; // 在对应标签的节点上运行某项任务</span><br><span class="line">	Task()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>parallel</strong>     </li>
</ul>
<p>并行地执行任务，可以说是最实用高效的工具了，举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">parallel(   //并行地执行android unit tests和android e2e tests两个任务</span><br><span class="line">	&apos;android unit tests&apos;: &#123;</span><br><span class="line">		runCmdOnDockerImage(androidImageName, &apos;bash /app/ContainerShip/scripts/run-android-docker-unit-tests.sh&apos;, &apos;--privileged --rm&apos;)</span><br><span class="line">	&#125;,</span><br><span class="line">	&apos;android e2e tests&apos;: &#123;</span><br><span class="line">	runCmdOnDockerImage(androidImageName, &apos;bash /app/ContainerShip/scripts/run-ci-e2e-tests.sh --android --js&apos;, &apos;--rm&apos;)</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>properties</strong>：   </li>
</ul>
<p>设置Job的属性，举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">properties([parameters([string(defaultValue: &apos;1.0.0&apos;, description: &apos;版本号&apos;, name: &apos;VERSION&apos;)]), pipelineTriggers([])]) // 为job设置了一个VERSION参数</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>pwd</strong>     显示当前目录</p>
</li>
<li><p><strong>readFile</strong>      </p>
</li>
</ul>
<p>从工作空间中读取文件，举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def editionName = readFile &apos;/home/Test/exam.txt&apos;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>retry</strong>    </li>
</ul>
<p>重复body内代码N次，举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">retry(10) &#123;</span><br><span class="line">    // some block</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>sh</strong>   </li>
</ul>
<p>执行shell脚本，如：sh “sh test.sh”</p>
<ul>
<li><strong>sleep</strong>  </li>
</ul>
<p>延时，如延时2小时：sleep time: 2, unit: ‘HOURS’</p>
<ul>
<li><strong>stage</strong>    </li>
</ul>
<p>创建任务的stage，举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stage(&apos;stage name&apos;) &#123;</span><br><span class="line">    // some block</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>stash</strong>      </li>
</ul>
<p>存放文件为后续构建使用，举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dir(&apos;target&apos;) &#123;</span><br><span class="line">	stash name: &apos;war&apos;, includes: &apos;x.war&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>unstash</strong>    </li>
</ul>
<p>将stash步骤中存放的文件在当前工作空间中重建，举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def deploy(id) &#123;</span><br><span class="line">    unstash &apos;war&apos;</span><br><span class="line">    sh &quot;cp x.war /tmp/$&#123;id&#125;.war&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>timeout</strong>     </li>
</ul>
<p>时间限制，举例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">timeout(time: 4, unit: &apos;SECONDS&apos;) &#123;</span><br><span class="line">    // some block</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>timestamps</strong>    </p>
<p>用于在控制台加时间戳，举例：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">timestamps &#123;</span><br><span class="line">    // some block</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>touch</strong>    </li>
</ul>
<p>创建文件，举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch file: &apos;TEST.txt&apos;, timestamp: 0</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>unzip</strong>    </p>
<p>解压文件，举例：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip dir: &apos;/home/workspace&apos;, glob: &apos;&apos;, zipFile: &apos;TEST.zip&apos;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>validateDeclarativePipeline</strong>  </li>
</ul>
<p>检查给定的文件是否包含一个有效的Declarative Pipeline，返回T或者F</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">validateDeclarativePipeline &apos;/home/wospace&apos;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>waitUntil</strong>     </li>
</ul>
<p>等待，直到条件满足</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">waitUntil &#123;</span><br><span class="line">    // some block</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>withCredentials</strong>     </li>
</ul>
<p>使用凭据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">withCredentials([usernameColonPassword(credentialsId: &apos;mylogin&apos;, variable: &apos;USERPASS&apos;)]) &#123;</span><br><span class="line">    sh &apos;&apos;&apos;</span><br><span class="line">      set +x</span><br><span class="line">      curl -u $USERPASS https://private.server/ &gt; output</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>withEnv</strong>    </li>
</ul>
<p>设置环境变量，注意近本次运行有效!</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">withEnv([&apos;MYTOOL_HOME=/usr/local/mytool&apos;]) &#123;</span><br><span class="line">    sh &apos;$MYTOOL_HOME/bin/start&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>writeFile</strong>    </li>
</ul>
<p>写文件到某个路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">writeFile file: &apos;/home/workspace&apos;, text: &apos;hello world&apos;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>writeJSON</strong>    </li>
</ul>
<p>写JSON文件，用法基本同上</p>
<ul>
<li><strong>zip</strong>    </li>
</ul>
<p>创建zip文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip dir: &apos;/home/workspace&apos;, glob: &apos;&apos;, zipFile: &apos;TEST.zip&apos;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>ws</strong>  </li>
</ul>
<p>自定义工作空间，在其中做一些工作，效果类似于Dir命令，举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws(&apos;/home/jenkins_workspace&apos;) &#123;</span><br><span class="line">    // some block</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>作者关于<a href="https://www.jianshu.com/p/d9d15a2194ab" target="_blank" rel="noopener">Groovy的实践在此</a></p>
<p><a href="https://www.jianshu.com/u/d19536b0189b" target="_blank" rel="noopener">作者更多的原创文章在此</a></p>
<hr>
<hr>
<p>最后附上个人联系方式，欢迎大家交流学习：<br>个人博客：www.hansonwang99.com.cn<br>个人网站：<a href="http://113.209.119.170/（捂脸的表情，很慢，1G" target="_blank" rel="noopener">http://113.209.119.170/（捂脸的表情，很慢，1G</a> 1M 1核的云主机上）<br>简    书：<a href="https://www.jianshu.com/u/d19536b0189b" target="_blank" rel="noopener">https://www.jianshu.com/u/d19536b0189b</a></p>
<p><img src="https://hansonwang99.github.io/img/wechat_qrcode.jpg" title="欢迎扫描我的二维码！"></p>
]]></content>
      
        <categories>
            
            <category> Jenkins实践录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Jenkins </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Groovy初体验：构建高性能JVM应用]]></title>
      <url>/2018/03/14/Groovy%E5%88%9D%E4%BD%93%E9%AA%8C%EF%BC%9A%E6%9E%84%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BDJVM%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>Groovy系列实践文章</p>
<a id="more"></a>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-2c94b4372011cfce.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="VAIO王者归来"></p>
<hr>
<h2 id="为什么要学Groovy"><a href="#为什么要学Groovy" class="headerlink" title="为什么要学Groovy"></a>为什么要学Groovy</h2><p>Groovy运行于JVM之上，然而其对<strong>动态语言</strong>、<strong>函数式编程范式</strong>以及<strong>元编程功能</strong>的加持所带来的表现力和简洁性可以说甩了Java几条街。我们可以利用Groovy的所有动态功能构建高性能的JVM应用、将开发效率提高几个数量级！ 这就是我们为什么要学它！</p>
<hr>
<h2 id="Groovy环境部署"><a href="#Groovy环境部署" class="headerlink" title="Groovy环境部署"></a>Groovy环境部署</h2><p>本文实验所用OS为CentOS7，这里介绍使用sdk工具来安装Groovy的方法。</p>
<ul>
<li>首先在命令行下执行：</li>
</ul>
<p><code>curl -s get.sdkman.io | bash</code></p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-e7d9b9e2b8187473.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="炫酷得一腿！"></p>
<ul>
<li>接下来执行：</li>
</ul>
<p><code>source &quot;$HOME/.sdkman/bin/sdkman-init.sh&quot;</code></p>
<ul>
<li>然后我们就可以使用sdk工具来安装Groovy：</li>
</ul>
<p>一句话搞定！</p>
<p><code>sdk install groovy</code></p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-6b0222c8d69b01cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="sdk install"></p>
<ul>
<li>完成之后我们来检查Groovy安装状态</li>
</ul>
<p><code>groovy -v</code></p>
<p>一切就绪</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9824247-869cff6c527d2104.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<hr>
<h2 id="Hello-World-From-Groovy"><a href="#Hello-World-From-Groovy" class="headerlink" title="Hello World From Groovy"></a>Hello World From Groovy</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim Hello.groovy</span><br><span class="line">[root@localhost ~]# more Hello.groovy </span><br><span class="line">println &quot;Hello World From Groovy !&quot;</span><br><span class="line">[root@localhost ~]# groovy Hello</span><br><span class="line">Hello World From Groovy !</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Groovy语言特性"><a href="#Groovy语言特性" class="headerlink" title="Groovy语言特性"></a>Groovy语言特性</h2><ul>
<li>Groovy是轻量级的Java</li>
<li>Groovy的信噪比比Java高：较少的代码获得更多结果</li>
<li>GDK = Groovy JDK：通过向JDK的各种类中添加便捷方法，Groovy扩展了JDK形成了GDK库</li>
<li>return语句可选，分号结尾可选</li>
<li>方法和类默认public</li>
<li>导航操作符可帮助实现对象引用不为空时方法才会被调用</li>
<li>Groovy不强迫捕获自己不关心的异常，没捕获的异常自动传到高层</li>
<li>静态方法内可使用this来引用Class对象，因此可以链式调用！</li>
</ul>
<p>两大优点：<strong>表现力</strong> + <strong>简洁</strong>！！！</p>
<hr>
<h2 id="从Java到Groovy"><a href="#从Java到Groovy" class="headerlink" title="从Java到Groovy"></a>从Java到Groovy</h2><p>用Java写一段代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Greetingss &#123;</span><br><span class="line"></span><br><span class="line">  public static void main( String[] args ) &#123;</span><br><span class="line">    for( int i=0; i&lt;3; i++ ) &#123;</span><br><span class="line">      System.out.println(&quot;ho &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;Merry Groovy&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用Groovy重构一遍如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(i in 0..2) &#123;</span><br><span class="line">  print &apos;ho &apos;</span><br><span class="line">&#125;</span><br><span class="line">print &apos;Merry Groovy&apos;</span><br></pre></td></tr></table></figure>
<p>看看两种语言的信噪比对比，真是给人不可估量的感动！</p>
<h2 id="安全导航操作符"><a href="#安全导航操作符" class="headerlink" title="安全导航操作符 ?."></a>安全导航操作符 <strong>?.</strong></h2><p>可以避免代码中的大量null引用的判断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def foo( str ) &#123;</span><br><span class="line">  str?.reverse()  // 仅当str不为null时reverse才会执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这可以帮我们省多少个<code>if</code>啊！！！</p>
<hr>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>与Java相比，Groovy的异常处理少了很多繁文缛节</p>
<p>对于那些不想处理或者不适合在代码当前层次处理的异常，Groovy对用户不做任何要求，任何用户未处理的异常会自动传递到高一层，我们啥也不用写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def openfile( fileName ) &#123;  // 无需throws</span><br><span class="line">  new FileInputStream( fileName ) // 无需try...catch... 处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>异常可以放到其调用代码中处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  openFile(&quot;nonexistfile&quot;)</span><br><span class="line">&#125; catch( FileNotFoundException ex ) &#123;</span><br><span class="line">  print &quot;Oops: &quot; + ex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若捕获所有异常（Exception），则上面catch中异常的类型都可省略：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  openFile(&quot;nonexistfile&quot;)</span><br><span class="line">&#125; catch( ex ) &#123;  // 省略类型表示可捕获所有异常</span><br><span class="line">  print &quot;Oops: &quot; + ex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h2><p>静态方法内可使用this来引用Class对象，因此可以链式调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Wizard &#123;</span><br><span class="line">  def static learn( trick, action ) &#123;</span><br><span class="line">    //...</span><br><span class="line">    this</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Wizard.learn(&apos;xxxx&apos;, &#123;...&#125;)</span><br><span class="line">  .learn(&apos;yyyy&apos;, &#123;...&#125;)</span><br><span class="line">  .learn(&apos;zzzz&apos;, &#123;...&#125;)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p><a href="https://www.jianshu.com/u/d19536b0189b" target="_blank" rel="noopener">作者更多的原创文章在此</a></p>
<hr>
<p>最后附上个人联系方式，欢迎大家交流学习：<br>个人博客：www.hansonwang99.com.cn<br>个人网站：<a href="http://113.209.119.170/" target="_blank" rel="noopener">http://113.209.119.170/</a> （捂脸的表情，很慢，1G 1M 1核的云主机上）<br>简    书：<a href="https://www.jianshu.com/u/d19536b0189b" target="_blank" rel="noopener">https://www.jianshu.com/u/d19536b0189b</a></p>
<p><img src="https://hansonwang99.github.io/img/wechat_qrcode.jpg" title="欢迎扫描我的二维码！"></p>
]]></content>
      
        <categories>
            
            <category> Groovy实践录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Groovy </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[利用K8S技术栈打造个人私有云（连载之：K8S资源控制）]]></title>
      <url>/2018/03/05/%E5%88%A9%E7%94%A8K8S%E6%8A%80%E6%9C%AF%E6%A0%88%E6%89%93%E9%80%A0%E4%B8%AA%E4%BA%BA%E7%A7%81%E6%9C%89%E4%BA%91%EF%BC%88%E8%BF%9E%E8%BD%BD%E4%B9%8B%EF%BC%9AK8S%E8%B5%84%E6%BA%90%E6%8E%A7%E5%88%B6%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>利用K8S技术栈打造个人私有云连载文章</p>
<a id="more"></a>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-fada1858b3fbcfce.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="封面图片"></p>
<hr>
<p>【利用K8S技术栈打造个人私有云系列文章目录】</p>
<ul>
<li><a href="https://www.jianshu.com/p/9bc87b5380e8" target="_blank" rel="noopener">利用K8S技术栈打造个人私有云（连载之：初章） </a></li>
<li><a href="https://www.jianshu.com/p/7d1fb03b8925" target="_blank" rel="noopener">利用K8S技术栈打造个人私有云（连载之：K8S集群搭建）</a></li>
<li><a href="https://www.jianshu.com/p/5b0cd99e0332" target="_blank" rel="noopener">利用K8S技术栈打造个人私有云（连载之：K8S环境理解和练手）</a></li>
<li><a href="https://www.jianshu.com/p/e38c05cf076a" target="_blank" rel="noopener">利用K8S技术栈打造个人私有云（连载之：基础镜像制作与实验）</a></li>
<li><a href="https://www.jianshu.com/p/58a98e65074c" target="_blank" rel="noopener">利用K8S技术栈打造个人私有云（连载之：资源控制研究）</a></li>
<li>利用K8S技术栈打造个人私有云（连载之：私有云客户端打造）（Coming Soon…）</li>
<li>利用K8S技术栈打造个人私有云（连载之：总结与升华）（Coming Soon…）</li>
</ul>
<hr>
<h2 id="私有云K8S资源控制原理"><a href="#私有云K8S资源控制原理" class="headerlink" title="私有云K8S资源控制原理"></a>私有云K8S资源控制原理</h2><p>基于前面系列文章的详细阐述，我们已经可以手工去K8S集群的命令行下将CentOS 7.4操作系统的Docker镜像启动起来，然后用户可以通过SSH登录到CentOS容器之中进行使用。但实际使用过程中不同的用户不可能每次都手动去命令行启动一个CentOS镜像，然后用命令去查看该容器的IP地址和端口是多少，然后再通过ssh去连接。我们最好可以将Docker容器的启动、查询、删除等再封装一层，然后通过WEB页面去提供给用户操作，这才符合用户行为需求！</p>
<p>由于在我们的实践中Docker容器是放在kubernetes集群中进行管理，所以这里的资源控制涉及的资源主要就是kubernetes的资源，如Pod、RC、Service等。</p>
<p>kubernetes中的Master节点运行kube-apiserver模块，该模块对外提供restful接口，我们可以基于该接口进行编程，从而完成对集群资源的控制管理、如Pod、RC、Service等的申请、查询、删除等任务。</p>
<p>要CRUD一个 kubernetes 资源，比如一个 pod，首先要知道和 kubernetes 集群交互的接口。在 kubernetes 的 master 节点上安装有 kubectl 客户端程序，该程序面向用户提供命令行接口，供用户和 kubernetes 集群交互。 kubectl 将用户命令通过 restful 接口传送给 apiserver，从而进行资源的增、删、改等操作。该过程可以示意如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-6b56b407f0e63508.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="K8S资源控制架构图"></p>
<p>原理讲完了，接下来讲讲代码级别如何实现。</p>
<hr>
<h2 id="K8S资源控制客户端"><a href="#K8S资源控制客户端" class="headerlink" title="K8S资源控制客户端"></a>K8S资源控制客户端</h2><p>总结上文不难看出，k8s相关资源的CRUD控制可以通过restful接口来实现。要使用Kubernetes REST API编写应用程序，当下大多语言都可以很方便地去实现HTTP请求来操作kubernetes的restful接口从而控制和查询资源，但本文主要是利用已有的kubernetes客户端来更加优雅地实现kubernetes的资源控制。你不需要自己编写API来调用、请求/响应等类型，可以直接使用现成的客户端库来实现。</p>
<p>k8s的客户端开源项目有很多，官方有支持，社区也维护了很多。</p>
<p>官方支持的Kubernetes客户端库比较有限，有下面几种：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-dbc1f3628f1bffef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="官方支持的Kubernetes客户端库"></p>
<p>社区维护的客户端库则更加丰富，基本热门的编程语言都支持，下面的这些Kubernetes API客户端库由社区创建者维护，Kubernetes团队不会提供支持和维护：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-93d980f9738700ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="社区维护的Kubernetes客户端库"></p>
<p>本实践选用的是Fabric8的k8s-client，基于Java实现。</p>
<p>下面就基于该Clinet讲讲代码级别的实现</p>
<hr>
<h2 id="K8S资源控制代码实现举例"><a href="#K8S资源控制代码实现举例" class="headerlink" title="K8S资源控制代码实现举例"></a>K8S资源控制代码实现举例</h2><p>下面结合代码来阐述一下Fabric8常用的k8s资源控制操作：</p>
<ul>
<li><strong>创建K8S客户端</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String namespace = &quot;default&quot;;    // namespace名</span><br><span class="line">String master = &quot;http://XXXX/&quot;;  // 配置为你的k8s集群的主节点地址</span><br><span class="line">Config config = new ConfigBuilder().withMasterUrl(master).build();</span><br><span class="line">KubernetesClient client = new DefaultKubernetesClient(config);</span><br></pre></td></tr></table></figure>
<p>接下来对K8S资源的控制、查询等操作基本都靠该<strong>client</strong>来完成！</p>
<ul>
<li><strong>创建Pod</strong></li>
</ul>
<p>我们从一个pod.yaml文件来创建Pod资源：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> List&lt;HasMetadata&gt; resources = client.load(new FileInputStream(fileName)).get();  // fileName为一个外部的pod.yaml文件</span><br><span class="line"> if (resources.isEmpty()) &#123;</span><br><span class="line">System.err.println(&quot;No resources loaded from file: &quot; +fileName);</span><br><span class="line">return;</span><br><span class="line"> &#125;</span><br><span class="line"> HasMetadata resource = resources.get(0);</span><br><span class="line"> if (resource instanceof Pod)&#123;</span><br><span class="line">Pod pod = (Pod) resource;</span><br><span class="line">System.out.println(&quot;Creating pod in namespace &quot; + namespace);</span><br><span class="line">NonNamespaceOperation&lt;Pod, PodList, DoneablePod, PodResource&lt;Pod, DoneablePod&gt;&gt; pods = client.pods().inNamespace(namespace);</span><br><span class="line">Pod result = pods.create(pod);  // 此处创建pod资源！！！</span><br><span class="line">System.out.println(&quot;Created pod &quot; + result.getMetadata().getName());</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">System.err.println(&quot;Loaded resource is not a Pod! &quot; + resource);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>删除Pod</strong></li>
</ul>
<p>删除很简单，只要知道Pod所在的namespace和name，一行代码即可搞定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.pods().inNamespace(&quot;namespace名字&quot;).withName(&quot;pod名&quot;).delete();</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>查询Pod</strong></li>
</ul>
<p>查询Pod的log日志并于控制台打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.pods().inNamespace(&quot;namespace名字&quot;).withName(&quot;pod名&quot;).tailingLines(10).watchLog(System.out))</span><br></pre></td></tr></table></figure>
<p>欲查询Pod的一些其他信息，可以参考创建Pod步骤中的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Pod result = pods.create(pod);  // 此处创建pod资源！！！</span><br><span class="line">System.out.println(&quot;Created pod &quot; + result.getMetadata().getName()); // 类似于此处，除了获取Pod的名字外还可以获取很多类似信息</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>修改Pod配置</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Pod updatedPod = client.pods().inNamespace(&quot;namespace名字&quot;).withName(&quot;pod名&quot;).edit()</span><br><span class="line">          .editMetadata()</span><br><span class="line">          .addToLabels(&quot;server2&quot;, &quot;nginx2&quot;)</span><br><span class="line">          .and().done();</span><br><span class="line">log(&quot;Replaced testPod:&quot;, updatedPod);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上文从创建一个K8S客户端开始比较完整地介绍了一个Pod资源的CRUD操作，限于篇幅原因，其他资源如RC、Service、Deployment等等的增删改查操作都类似，只是名字不同而已，其接口稍微类比一下Pod即可写出对应的资源控制代码，此处不再赘述了，举一反三很重要。</p>
</blockquote>
<hr>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p><a href="https://www.jianshu.com/u/d19536b0189b" target="_blank" rel="noopener">作者更多的原创文章在此</a></p>
<hr>
<p>最后附上个人联系方式，欢迎大家交流学习：<br>个人博客：www.hansonwang99.com.cn<br>个人网站：<a href="http://113.209.119.170/" target="_blank" rel="noopener">http://113.209.119.170/</a> （捂脸的表情，很慢，1G 1M 1核的云主机上）<br>简    书：<a href="https://www.jianshu.com/u/d19536b0189b" target="_blank" rel="noopener">https://www.jianshu.com/u/d19536b0189b</a><br>SF：<a href="https://segmentfault.com/u/hansonwang99" target="_blank" rel="noopener">https://segmentfault.com/u/hansonwang99</a><br>OSC：<a href="https://my.oschina.net/hansonwang99" target="_blank" rel="noopener">https://my.oschina.net/hansonwang99</a><br>掘金：<a href="https://juejin.im/user/59551ecdf265da6c2518cd5c" target="_blank" rel="noopener">https://juejin.im/user/59551ecdf265da6c2518cd5c</a></p>
<p><img src="https://hansonwang99.github.io/img/wechat_qrcode.jpg" title="欢迎扫描我的二维码！"></p>
]]></content>
      
        <categories>
            
            <category> K8s沉思录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[你可能没有细究过的TCP/IP]]></title>
      <url>/2018/02/28/%E4%BD%A0%E5%8F%AF%E8%83%BD%E6%B2%A1%E6%9C%89%E7%BB%86%E7%A9%B6%E8%BF%87%E7%9A%84TCP-IP/</url>
      <content type="html"><![CDATA[<p>TCP/IP深入学习</p>
<a id="more"></a>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-9d8fbfc8a4a1e625.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="封面图片"></p>
<hr>
<p>作为互联网时代伟大发明的TCP/IP技术可以说对当今时代产生了深刻的影响。经过近一个月的学习摸索，基本清楚了TCP/IP的面貌。由于TCP/IP在OS中位于内核态，很多细节其实用户无法感知，所以自己对于TCP/IP会有一些疑惑。关于其中几个点经过查阅一些书籍、博客并结合自己的一些理解，在此整理精炼成帖。</p>
<hr>
<h2 id="疑惑1-—-关于拥塞"><a href="#疑惑1-—-关于拥塞" class="headerlink" title="疑惑1 — 关于拥塞"></a>疑惑1 — 关于拥塞</h2><blockquote>
<p><strong>疑惑一：</strong>无论是满启动还是拥塞避免阶段，拥塞窗口都在增加，理论上一定会碰到拥塞点，为什么平时感觉不到拥塞呢？</p>
</blockquote>
<p>看了很多书和文献以后可能的解答如下：</p>
<ul>
<li><p>1、OS中对接收窗口的最大设定多年未动，如windows在不启用“TCP Window Option”情况下，最大接收窗口仅64KB。然而网络进步，很多环境的拥塞点远在64kb以上，即发送窗口永远触碰不到拥塞点</p>
</li>
<li><p>2、很多应用场景是交互式小数据交换，如聊天等，不会有拥塞的可能</p>
</li>
<li><p>3、有些应用在传输数据时采用同步方式，可能需要的窗口非常小（如采用了同步方式的NFS写操作，每发一个写请求就停下来等回复，而一个写请求可能仅有4kb）</p>
</li>
<li><p>4、即便偶尔拥塞，持续时间也不足以长到能感受出来，除非抓包看包交换细节</p>
</li>
</ul>
<hr>
<h2 id="疑惑2-—-关于超时重传"><a href="#疑惑2-—-关于超时重传" class="headerlink" title="疑惑2 — 关于超时重传"></a>疑惑2 — 关于超时重传</h2><blockquote>
<p><strong>疑惑二：</strong> 关于超时重传后的ssthresh设置问题的争议</p>
</blockquote>
<ul>
<li><p>1、Richard Stevens在《TCP/IP详解》中把临界窗口值定为上次发生拥塞时的发送窗口的一半</p>
</li>
<li><p>2、RFC5681则认为应是发生拥塞时未被确认的数据量的1/2（又称FlightSize），且不小于2MSS</p>
</li>
<li><p>3、Westwood/Westwood+算法则这样认为：先推算出有多少包已被送达到接收方（可根据收方回应的ACK来推算），从而精确地估算发生拥塞时的带宽，最后再依据带宽来确认新的拥塞窗口</p>
</li>
<li><p>4、Vegas算法则这样认为：引入全新的概念，摒弃之前的在丢包后才调节拥塞窗口的做法。其通过监控网络状态来调整发包速度，实现“真正的拥塞避免”。当网络良好时，RTT较稳定，此时可以增加拥塞窗口；当网络繁忙时，RTT增加，此时减小拥塞窗口</p>
</li>
<li><p>5、Compound算法这样认为：同时维持两个拥塞窗口，一个类似于Vegas，另一个类似于RFC5681，真正起作用的是两者之和（Win7上其默认关闭）</p>
</li>
<li><p>6、BIC算法/CUBIC算法<br>分别是linux2.6.18和linux 2.6.19所采用，目前尚未研究</p>
</li>
</ul>
<hr>
<h2 id="关于TCP-IP的几点精炼总结："><a href="#关于TCP-IP的几点精炼总结：" class="headerlink" title="关于TCP/IP的几点精炼总结："></a>关于TCP/IP的几点精炼总结：</h2><ul>
<li><p>（1）当无拥塞时，发送窗口越大，性能越好。∴在带宽没有限制的情况下，应尽量增加接受窗口，比如启用Scale Option</p>
</li>
<li><p>（2）若经常发生拥塞，则限制发送窗口反而可以提高性能，∵即便万分之一的重传对性能的影响都非常大。很多OS上可通过限制接收窗口的方法来↓发送窗口</p>
</li>
<li><p>（3）超时重传对于性能影响最大，∵RTO时间内未传输任何数据，而Cwnd会被设成1MSS，应尽量避免</p>
</li>
<li><p>（4）快速重传对性能影响小一些，∵无等待时间，且Cwnd减幅不大</p>
</li>
<li><p>（5）SACK和NewReno有利于增加重传效率，增加传输性能</p>
</li>
<li><p>（6）丢包对极小文件的影响比打文件严重。深层原因是因为读写一个小文件需要的包数很少，∴丢包时往往凑不满三个Dup ACK，只能等待超时重传；而大文件有较大可能触发快速重传</p>
</li>
</ul>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p><a href="https://www.jianshu.com/u/d19536b0189b" target="_blank" rel="noopener">作者更多的原创文章在此</a></p>
<hr>
<p>最后附上个人联系方式，欢迎大家交流学习：<br>个人博客：www.hansonwang99.com.cn<br>个人网站：<a href="http://113.209.119.170/（捂脸的表情，很慢，1G" target="_blank" rel="noopener">http://113.209.119.170/（捂脸的表情，很慢，1G</a> 1M 1核的云主机上）<br>简    书：<a href="https://www.jianshu.com/u/d19536b0189b" target="_blank" rel="noopener">https://www.jianshu.com/u/d19536b0189b</a></p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://hansonwang99.github.io/img/wechat_qrcode.jpg" title="欢迎扫描我的二维码！"></h2>]]></content>
      
        <categories>
            
            <category> TCP/IP思考集 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> TCP/IP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[利用K8S技术栈打造个人私有云（连载之：基础镜像制作与实验）]]></title>
      <url>/2018/02/22/%E5%88%A9%E7%94%A8K8S%E6%8A%80%E6%9C%AF%E6%A0%88%E6%89%93%E9%80%A0%E4%B8%AA%E4%BA%BA%E7%A7%81%E6%9C%89%E4%BA%91%EF%BC%88%E8%BF%9E%E8%BD%BD%E4%B9%8B%EF%BC%9A%E5%9F%BA%E7%A1%80%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E4%B8%8E%E5%AE%9E%E9%AA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>利用K8S技术栈打造个人私有云连载文章</p>
<a id="more"></a>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-904f1ca7a1821eb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="封面图片"></p>
<hr>
<p>【利用K8S技术栈打造个人私有云系列文章目录】</p>
<ul>
<li><a href="https://www.jianshu.com/p/9bc87b5380e8" target="_blank" rel="noopener">利用K8S技术栈打造个人私有云（连载之：初章） </a></li>
<li><a href="https://www.jianshu.com/p/7d1fb03b8925" target="_blank" rel="noopener">利用K8S技术栈打造个人私有云（连载之：K8S集群搭建）</a></li>
<li><a href="https://www.jianshu.com/p/5b0cd99e0332" target="_blank" rel="noopener">利用K8S技术栈打造个人私有云（连载之：K8S环境理解和练手）</a></li>
<li><a href="https://www.jianshu.com/p/e38c05cf076a" target="_blank" rel="noopener">利用K8S技术栈打造个人私有云（连载之：基础镜像制作与实验）</a></li>
<li>利用K8S技术栈打造个人私有云（连载之：资源控制研究）（Coming Soon…） </li>
<li>利用K8S技术栈打造个人私有云（连载之：私有云客户端打造）（Coming Soon…）</li>
<li>利用K8S技术栈打造个人私有云（连载之：总结与升华）（Coming Soon…）</li>
</ul>
<hr>
<p>任何一家云主机厂商提供给用户的主机功能其实讲白了就是一个操作系统基础镜像的运行实例。因此本篇博文将讲解如何在本地构建一个带ssh组件的centos底包镜像并上传到docker hub上供下载使用。</p>
<hr>
<h2 id="docker-hub注册"><a href="#docker-hub注册" class="headerlink" title="docker hub注册"></a>docker hub注册</h2><p>注册网址：<code>https://hub.docker.com/</code></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-c32602ec9a9ef453.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Docker Hub"></p>
<hr>
<h2 id="命令行中登录到docker-hub"><a href="#命令行中登录到docker-hub" class="headerlink" title="命令行中登录到docker hub"></a>命令行中登录到docker hub</h2><p>命令行中输入：<code>docker login</code></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-0892fc84c708970c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="docker login"></p>
<hr>
<h2 id="制作centos7-4镜像"><a href="#制作centos7-4镜像" class="headerlink" title="制作centos7.4镜像"></a>制作centos7.4镜像</h2><p>####<strong>1、第一步：</strong>去远端拉取一个最新的centos最基础镜像，基于此镜像来制作</p>
<p><code>docker pull centos</code></p>
<p>####<strong>2、第二步：</strong>启动该docker容器</p>
<p><code>docker run -it centos：latest /bin/bash</code></p>
<p>####<strong>3、第三步：</strong>在启动的容器中来安装sshd</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install openssh-server</span><br><span class="line">yum -y install openssh-clients</span><br></pre></td></tr></table></figure>
<p>####<strong>4、第四步：</strong>我们来尝试启动一下sshd服务，会发现有报错</p>
<p>启动sshd服务命令: <code>/usr/sbin/sshd -D</code><br>报如下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Could not load host key: /etc/ssh/ssh_host_rsa_key</span><br><span class="line">Could not load host key: /etc/ssh/ssh_host_ecdsa_key</span><br><span class="line">Could not load host key: /etc/ssh/ssh_host_ed25519_key</span><br></pre></td></tr></table></figure>
<p>我们来解决以上错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_key -N &quot;&quot;</span><br><span class="line">ssh-keygen -t ecdsa -f /etc/ssh/ssh_host_ecdsa_key -N &quot;&quot;</span><br><span class="line">ssh-keygen -t ed25519 -f /etc/ssh/ssh_host_ed25519_key -N &quot;&quot;</span><br></pre></td></tr></table></figure></p>
<p>此时再次来启动sshd服务应该无错误了</p>
<p>####<strong>5、第五步：</strong>编辑sshd_config配置文件</p>
<p>执行命令：<code>vim /etc/ssh/sshd_config</code><br>将配置文件中原本<code>UsePAM yes</code>换成<code>UsePAM no</code></p>
<p>####<strong>6、第六步：</strong>修改root的密码</p>
<p>执行命令：<code>passwd root</code><br>输入两次密码即可</p>
<p>####<strong>7、第七步：</strong>我们用exit命令来退出容器</p>
<p>####<strong>8、第八步：</strong>基于刚退出的容器我们来制作带ssh功能的centos镜像<br><code>docker commit bf5b84f8e2d8 docker.io/hansonwang/centos7.4_ssh</code></p>
<p>（1）<strong>注意</strong>此处的bf5b84f8e2d8即为刚才运行的容器的id，可用docker ps -a查看<br>（2）<strong>注意</strong>此处的commit格式，必须为docker.io/&lt;你的dockerhub用户名&gt;/centos7.4_ssh</p>
<hr>
<h2 id="push镜像到远端"><a href="#push镜像到远端" class="headerlink" title="push镜像到远端"></a>push镜像到远端</h2><p><code>docker push docker.io/hansonwang/centos7.4_ssh:latest</code></p>
<blockquote>
<p>同样需要注意此处的push格式，必须为docker.io/&lt;你的dockerhub用户名/完整的镜像名</p>
</blockquote>
<p>如下图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-76faae6e68e1c021.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="docker push"></p>
<p>同时我们去docker hub上也能看到我们刚push的镜像：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-e8153357d7ca6c86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Repositories"></p>
<hr>
<h2 id="效果验证"><a href="#效果验证" class="headerlink" title="效果验证"></a>效果验证</h2><p>为了验证镜像确实被推到远端，我们将本地刚打包好的镜像删除，然后从远端pull下来运行看看</p>
<p><code>docker pull hansonwang/centos7.4_ssh</code></p>
<p>可以成功pull下来：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-89ca942bedb58971.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="重新pull镜像"></p>
<p>我们来测试一下该镜像里是否包含有ssh组件：运行其并用ssh连接到容器中：<br>运行容器：<code>docker run -d -p 2222:22 docker.io/hansonwang/centos7.4_ssh:latest /usr/sbin/sshd -D</code><br>ssh接入：<code>ssh root@localhost -p 2222</code><br>此时会让你输入密码，然后成功登入容器之中：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-0078c14edbb9dcd8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ssh接入centos容器"></p>
<hr>
<p>最后附上个人联系方式，欢迎大家交流学习：<br>个人博客：www.hansonwang99.com.cn<br>个人网站：<a href="http://113.209.119.170/" target="_blank" rel="noopener">http://113.209.119.170/</a> （捂脸的表情，很慢，1G 1M 1核的云主机上）<br>简    书：<a href="https://www.jianshu.com/u/d19536b0189b" target="_blank" rel="noopener">https://www.jianshu.com/u/d19536b0189b</a></p>
<p><img src="https://hansonwang99.github.io/img/wechat_qrcode.jpg" title="欢迎扫描我的二维码！"></p>
]]></content>
      
        <categories>
            
            <category> K8s沉思录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[利用K8S技术栈打造个人私有云（连载之：K8S环境理解和练手）]]></title>
      <url>/2018/02/08/%E5%88%A9%E7%94%A8K8S%E6%8A%80%E6%9C%AF%E6%A0%88%E6%89%93%E9%80%A0%E4%B8%AA%E4%BA%BA%E7%A7%81%E6%9C%89%E4%BA%91%EF%BC%88%E8%BF%9E%E8%BD%BD%E4%B9%8B%EF%BC%9AK8S%E7%8E%AF%E5%A2%83%E7%90%86%E8%A7%A3%E5%92%8C%E7%BB%83%E6%89%8B%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>利用K8S技术栈打造个人私有云连载文章</p>
<a id="more"></a>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-639ac95127f7f0e1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="封面图片"></p>
<hr>
<p>【利用K8S技术栈打造个人私有云系列文章目录】</p>
<ul>
<li><a href="https://www.jianshu.com/p/9bc87b5380e8" target="_blank" rel="noopener">利用K8S技术栈打造个人私有云（连载之：初章） </a></li>
<li><a href="https://www.jianshu.com/p/7d1fb03b8925" target="_blank" rel="noopener">利用K8S技术栈打造个人私有云（连载之：K8S集群搭建）</a></li>
<li><a href="https://www.jianshu.com/p/5b0cd99e0332" target="_blank" rel="noopener">利用K8S技术栈打造个人私有云（连载之：K8S环境理解和练手）</a></li>
<li>利用K8S技术栈打造个人私有云（连载之：基础镜像制作与实验）（Coming Soon…）</li>
<li>利用K8S技术栈打造个人私有云（连载之：资源控制研究）（Coming Soon…）</li>
<li>利用K8S技术栈打造个人私有云（连载之：私有云客户端打造）（Coming Soon…）</li>
<li>利用K8S技术栈打造个人私有云（连载之：总结与升华）（Coming Soon…）</li>
</ul>
<p>在前文中我们已经搭建好了K8S集群，接下来就来讲述一下K8S的一些重要的概念和知识，并搞两个例子在集群中来实际练手感受一把！</p>
<hr>
<h2 id="K8S环境理解"><a href="#K8S环境理解" class="headerlink" title="K8S环境理解"></a>K8S环境理解</h2><p>kubernetes的概念非常多，组件也不少，本文主要阐述一下几个最主要、平时用得最频繁的概念，最详细的学习文档是官网教程！</p>
<h3 id="K8S设计架构"><a href="#K8S设计架构" class="headerlink" title="K8S设计架构"></a>K8S设计架构</h3><p><img src="http://upload-images.jianshu.io/upload_images/9824247-1ae08462a61408d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="K8S架构"></p>
<p>该图描述的设计架构是一个典型的M-S架构，一主两从，这和<a href="https://www.jianshu.com/p/7d1fb03b8925" target="_blank" rel="noopener">我搭建的集群</a>基本是一致的，主节点和从节点上运行哪些kube组件，其实在我<a href="https://www.jianshu.com/p/7d1fb03b8925" target="_blank" rel="noopener">搭建集群那篇文章</a>也已经讲过了，下面来阐述一下kubernetes集群里的重要概念和操作命令。</p>
<h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><p>Pod是Kubernetes中最小的管理元素，Pod是一组容器的集合，且一个Pod只能运行在一个Node上，Pod是kubernetes调度、部署、扩展的基本单位 </p>
<ul>
<li>kubectl run命令创建一个pod：<code>kubectl run pod-example --image=nginx</code></li>
<li>kubectl create命令创建pod：<code>kubectl create -f create_pod.yaml</code></li>
<li>删除pod：<code>kubectl delete po pod名</code></li>
<li>查看pod启动情况：<code>kubectl get pods</code>， <code>kubectl get pods -o wide</code></li>
<li>查看pod的详细信息：<code>kubectl discrible po pod名</code></li>
</ul>
<h3 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h3><p>Namespace是对一组资源和对象的抽象集合，比如可以用来将系统内部的对象划分为不同的项目组或用户组。常见的pods, services, replication controllers和deployments等都是属于某一个namespace的（默认是default），而node, persistentVolumes等则不属于任何namespace。</p>
<ul>
<li>创建 <code>kubectl create namespace namespace名</code></li>
<li>删除 <code>kubectl delete namespaces namespace名</code></li>
<li>查询 <code>kubectl get namespaces</code></li>
</ul>
<h3 id="Replication-Controller（RC）"><a href="#Replication-Controller（RC）" class="headerlink" title="Replication Controller（RC）"></a>Replication Controller（RC）</h3><p>Replication Controller 保证了在所有时间内，都有特定数量的Pod副本正在运行，如果太多了，Replication Controller就杀死几个，如果太少了，Replication Controller会新建几个，和直接创建的pod不同的是，Replication Controller会替换掉那些删除的或者被终止的pod，而不管删除的原因是什么。</p>
<p>其实其CURD的命令和上面都差不多，这里不一一列出了</p>
<ul>
<li>创建：<code>kubectl create -f create_rc.json</code></li>
<li>查看rc启动情况：<code>kubectl get rc</code></li>
</ul>
<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>Service 是一个定义了一组Pod的策略的抽象，可以理解为抽象到用户层的一个宏观服务。其实这个概念在<a href="https://www.jianshu.com/p/3f3c9e0e3db5" target="_blank" rel="noopener">Swarm集群</a>里也有，可以参照理解。</p>
<p>Service的这样一层抽象最起码可以抵御两个方面的问题：</p>
<ul>
<li>Pod重启后IP地址的变化（保持用我们系统的客户其IP不变）</li>
<li>提供负载均衡能力</li>
</ul>
<p>其CURD的命令和上面都差不多，这里依然不一一列出</p>
<ul>
<li>创建service：<code>kubectr create -f redis-master-service.json</code></li>
<li>查看service的启动情况：<code>kubectl get svc</code></li>
</ul>
<p>这里给一个Service的示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: my-nginx-svc</span><br><span class="line">  labels:</span><br><span class="line">    app: nginx</span><br><span class="line">spec:</span><br><span class="line">  type: LoadBalancer</span><br><span class="line">  ports:</span><br><span class="line">  - port: 80</span><br><span class="line">  selector:  </span><br><span class="line">    app: nginx</span><br></pre></td></tr></table></figure>
<blockquote>
<p>好了，理论的东西看多了可能有点蒙，只能多找点不同的材料阅读并理解了。下面开始做几个练手示例，这几个例子都源自于<a href="https://kubernetes.io/docs/home/" target="_blank" rel="noopener">K8S官网</a>，对于理解理论概念非常有好处，下面开始动手吧！</p>
</blockquote>
<hr>
<h2 id="关于Pod的实例练手"><a href="#关于Pod的实例练手" class="headerlink" title="关于Pod的实例练手"></a>关于Pod的实例练手</h2><p>本例子创建一个包含两个容器的POD，并在容器之间完成文件交换</p>
<ul>
<li><p>yaml配置文件如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: two-containers</span><br><span class="line">spec:</span><br><span class="line"></span><br><span class="line">  restartPolicy: Never</span><br><span class="line"></span><br><span class="line">  volumes:</span><br><span class="line">  - name: shared-data</span><br><span class="line">    emptyDir: &#123;&#125;</span><br><span class="line"></span><br><span class="line">  containers:</span><br><span class="line"></span><br><span class="line">  - name: nginx-container</span><br><span class="line">    image: nginx</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: shared-data</span><br><span class="line">      mountPath: /usr/share/nginx/html</span><br><span class="line"></span><br><span class="line">  - name: debian-container</span><br><span class="line">    image: debian</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: shared-data</span><br><span class="line">      mountPath: /pod-data</span><br><span class="line">    command: [&quot;/bin/sh&quot;]</span><br><span class="line">    args: [&quot;-c&quot;, &quot;echo Hello from the debian container &gt; /pod-data/index.html&quot;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建pod</p>
</li>
</ul>
<p><code>kubectl create -f two-container-pod.yaml</code></p>
<ul>
<li>查看pod和容器的信息</li>
</ul>
<p><code>kubectl get pod two-containers --output=yaml</code></p>
<p>执行完成输出内容大致如下（经过缩减）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  ...</span><br><span class="line">  name: two-containers</span><br><span class="line">  namespace: default</span><br><span class="line">  ...</span><br><span class="line">spec:</span><br><span class="line">  ...</span><br><span class="line">  containerStatuses:</span><br><span class="line"></span><br><span class="line">  - containerID: docker://c1d8abd1 ...</span><br><span class="line">    image: debian</span><br><span class="line">    ...</span><br><span class="line">    lastState:</span><br><span class="line">      terminated:  // debian容器已停止</span><br><span class="line">        ...</span><br><span class="line">    name: debian-container</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">  - containerID: docker://96c1ff2c5bb ...</span><br><span class="line">    image: nginx</span><br><span class="line">    ...</span><br><span class="line">    name: nginx-container</span><br><span class="line">    ...</span><br><span class="line">    state:</span><br><span class="line">      running:  // nginx容器已运行</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>可以看到debian容器已经停止了，nginx容器依然运行</p>
<ul>
<li>我们进入nginx容器的/bin/bash并验证nginx服务器</li>
</ul>
<p><code>kubectl exec -it two-containers -c nginx-container -- /bin/bash</code></p>
<p>执行如下命令来安装curl：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@two-containers:/# apt-get update</span><br><span class="line">root@two-containers:/# apt-get install curl procps</span><br><span class="line">root@two-containers:/# ps aux</span><br></pre></td></tr></table></figure>
<p>然后执行<code>curl localhost</code>,可以获得输出：</p>
<blockquote>
<p>Hello from the debian container</p>
</blockquote>
<p>可见debian容器中写入的东西在nginx容器中获得了，因此文件交换也完成了</p>
<p>用Pod来做一件事很简单吧！</p>
<hr>
<h2 id="关于RC和Service的实例练手"><a href="#关于RC和Service的实例练手" class="headerlink" title="关于RC和Service的实例练手"></a>关于RC和Service的实例练手</h2><p>本示例演示的是：部署一个包含Redis集群、基于PHP的留言板系统</p>
<ul>
<li>创建redis-master的<strong>RC</strong></li>
</ul>
<p>redis-master-controller.yaml内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ReplicationController</span><br><span class="line">metadata:</span><br><span class="line">  name: redis-master</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    name: redis-master</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      name: redis-master</span><br><span class="line">      labels:</span><br><span class="line">        name: redis-master</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: redis-master</span><br><span class="line">        image: kubeguide/redis-master</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 6379</span><br></pre></td></tr></table></figure></p>
<p>创建该RC并查看创建结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f redis-master-controller.yaml</span><br><span class="line">kubectl get rc</span><br><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure>
<ul>
<li>创建redis-master的<strong>service</strong></li>
</ul>
<p>redis-master-service.yaml内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: redis-master</span><br><span class="line">  labels:</span><br><span class="line">    name: redis-master</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - port: 6379</span><br><span class="line">    targetPort: 6379</span><br><span class="line">  selector:</span><br><span class="line">    name: redis-master</span><br></pre></td></tr></table></figure></p>
<p>创建该Service并查看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f redis-master-service.yaml</span><br><span class="line">kubectl get services</span><br></pre></td></tr></table></figure>
<ul>
<li>创建redis-slave的<strong>RC</strong></li>
</ul>
<p>redis-slave-controller.yaml文件内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ReplicationController</span><br><span class="line">metadata:</span><br><span class="line">  name: redis-slave</span><br><span class="line">spec:</span><br><span class="line">  replicas: 2</span><br><span class="line">  selector: # RC通过spec.selector来筛选要控制的Pod</span><br><span class="line">    name: redis-slave</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      name: redis-slave</span><br><span class="line">      labels: # Pod的label，可以看到这个label与spec.selector相同</span><br><span class="line">        name: redis-slave</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: redis-slave</span><br><span class="line">        image: kubeguide/guestbook-redis-slave</span><br><span class="line">        env:</span><br><span class="line">        - name: GET_HOSTS_FROM</span><br><span class="line">          value: env</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 6379</span><br></pre></td></tr></table></figure></p>
<p>创建该RC并查看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f redis-slave-controller.yaml</span><br><span class="line">kubectl get rc</span><br><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure>
<ul>
<li>创建redis-slave的<strong>service</strong></li>
</ul>
<p>redis-slave-service.yaml文件内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: redis-slave</span><br><span class="line">  labels:</span><br><span class="line">    name: redis-slave</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - port: 6379  </span><br><span class="line">  selector:</span><br><span class="line">    name: redis-slave</span><br></pre></td></tr></table></figure>
<p>创建该Service并查看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f redis-slave-service.yaml</span><br><span class="line">kubectl get services</span><br></pre></td></tr></table></figure>
<ul>
<li>创建frontend的<strong>RC</strong></li>
</ul>
<p>frontend-controller.yaml内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ReplicationController</span><br><span class="line">metadata:</span><br><span class="line">  name: frontend</span><br><span class="line">  labels:</span><br><span class="line">    name: frontend</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    name: frontend</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        name: frontend</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: frontend</span><br><span class="line">        image: kubeguide/guestbook-php-frontend</span><br><span class="line">        env:</span><br><span class="line">        - name: GET_HOSTS_FROM</span><br><span class="line">          value: env</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br></pre></td></tr></table></figure>
<p>创建该RC并查看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f frontend-controller.yaml</span><br><span class="line">kubectl get rc</span><br><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure>
<ul>
<li>创建frontend的<strong>Service</strong></li>
</ul>
<p>frontend-service.yaml文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: frontend</span><br><span class="line">  labels:</span><br><span class="line">    name: frontend</span><br><span class="line">spec:</span><br><span class="line">  type: NodePort</span><br><span class="line">  ports:</span><br><span class="line">  - port: 80</span><br><span class="line">    nodePort: 30001</span><br><span class="line">  selector:</span><br><span class="line">    name: frontend</span><br></pre></td></tr></table></figure>
<p>创建该Service并查看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f frontend-service.yaml</span><br><span class="line">kubectl get services</span><br></pre></td></tr></table></figure>
<ul>
<li>访问<code>http://your-host:30001/</code></li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-d29f826fda03668e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="浏览器访问结果"></p>
<p>简单的留言板系统就生成了！</p>
<hr>
<p>最后附上个人联系方式，欢迎大家交流学习：<br>个人博客：www.hansonwang99.com.cn<br>个人网站：<a href="http://113.209.119.170/" target="_blank" rel="noopener">http://113.209.119.170/</a> （捂脸的表情，很慢，1G 1M 1核的云主机上）<br>简    书：<a href="https://www.jianshu.com/u/d19536b0189b" target="_blank" rel="noopener">https://www.jianshu.com/u/d19536b0189b</a></p>
<p><img src="https://hansonwang99.github.io/img/wechat_qrcode.jpg" title="欢迎扫描我的二维码！"></p>
]]></content>
      
        <categories>
            
            <category> K8s沉思录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java编程思想学习录（连载之：异常）]]></title>
      <url>/2018/02/06/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E5%BD%95%EF%BC%88%E8%BF%9E%E8%BD%BD%E4%B9%8B%EF%BC%9A%E5%BC%82%E5%B8%B8%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>Java编程思想学习录连载文章</p>
<a id="more"></a>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-d2ff273461030dbc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Samsung Display"></p>
<hr>
<p>Thinking in java系列博文目录：</p>
<ul>
<li><a href="https://www.jianshu.com/p/8968abb42fba" target="_blank" rel="noopener">Java编程思想学习录（连载之：一切都是对象）</a></li>
<li><a href="https://www.jianshu.com/p/2b78bb88cb5a" target="_blank" rel="noopener">Java编程思想学习录（连载之：初始化与清理）</a></li>
<li><a href="https://www.jianshu.com/p/5df8c9d5f69c" target="_blank" rel="noopener">Java编程思想学习录（连载之：内部类）</a></li>
<li><a href="https://www.jianshu.com/p/fbe2ed1d1d99" target="_blank" rel="noopener">Java编程思想学习录（连载之：异常）</a></li>
</ul>
<p>本篇文章将讲述关于异常的相关知识</p>
<hr>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>Java使用异常来提供一致性的错误报告模型；且可集中错误处理；且任务代码与异常代码分割开来，易于理解和维护</li>
<li>虽然异常处理理论有<strong>终止模型</strong>、<strong>恢复模型</strong>两种，但恢复模型很难优雅地做到，∴并不实用，实际中大家都是转向使用终止模型代码</li>
<li>一个异常抛出后发生的两件事：① 使用new在堆上创建异常对象；② 异常处理机制开始接管流程（当前的执行流程被终止）</li>
<li>标准异常类均有两个ctor：① default ctor； ② 带字符串参数的ctor</li>
<li>Throwable是异常类型的根类</li>
<li>catch异常时，try中抛出的是子类异常，但catch的是基类异常也是OK，但若catch子类异常和基类异常的子句同时存在时，应将基类catch子句放在后面避免“屏蔽”现象发生</li>
</ul>
<hr>
<h2 id="抛出异常-捕获异常"><a href="#抛出异常-捕获异常" class="headerlink" title="抛出异常 + 捕获异常"></a>抛出异常 + 捕获异常</h2><ul>
<li>抛出异常（throw）：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if( t==null )</span><br><span class="line">  throw new NullPointerException(); // 异常对象用new创建于堆上</span><br></pre></td></tr></table></figure>
<ul>
<li>捕获异常（try+catch）：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; catch( Type1 id1 ) &#123; </span><br><span class="line">  // 处理Type1类型的异常代码</span><br><span class="line">&#125; catch( Type2 id2 ) &#123;</span><br><span class="line">  // 处理Type2类型的异常代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>虽然上面的id1和id2在处理异常代码中可能用不到，但不能少，必须定义</li>
<li>异常发生时，异常机制搜寻参数与异常类型相匹配的第一个catch子句并进入</li>
</ol>
<hr>
<h2 id="创建自定义异常"><a href="#创建自定义异常" class="headerlink" title="创建自定义异常"></a>创建自定义异常</h2><p>创建<strong>不带参数</strong>ctor的自定义异常类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 自定义异常类（default ctor）</span><br><span class="line">class SimpleException extends Exception &#123;&#125;</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">// 客户端代码</span><br><span class="line">public class UseException &#123;</span><br><span class="line">  public void fun throws SimpleException &#123;</span><br><span class="line">    System.out.println( &quot;Throw SimpleExcetion from fun&quot; );</span><br><span class="line">    throw new SimpleException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void main( String[] args ) &#123;</span><br><span class="line">    UseException user = new UseException();</span><br><span class="line">    try &#123;</span><br><span class="line">      user.fun(); </span><br><span class="line">    &#125; catch( SimpleException e ) &#123;</span><br><span class="line">      System.out.println(&quot;Caught it !&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">// 输出</span><br><span class="line">Throw SimpleExcetion from fun</span><br><span class="line">Caught it !</span><br></pre></td></tr></table></figure>
<p>创建<strong>带参数</strong>ctor的自定义异常类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// 自定义异常类（有参ctor）</span><br><span class="line">class MyException extends  Exception &#123;</span><br><span class="line">  public MyException() &#123; &#125;</span><br><span class="line">  public MyException( String msg ) &#123; super(msg); &#125;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">// 客户端代码</span><br><span class="line">public class UseException &#123;</span><br><span class="line">  </span><br><span class="line">  pubilc static void f() throws MyException &#123;</span><br><span class="line">    System.out.println( &quot;Throwing MyException from f()&quot; )</span><br><span class="line">    throw new MyException();</span><br><span class="line">  &#125;</span><br><span class="line">  public static void g() throws MyException &#123;</span><br><span class="line">    System.out.println( &quot;Throwing MyException from g()&quot; )</span><br><span class="line">    throw new MyException(&quot;Originated in g()&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  publib static void main( String[] args ) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      f();</span><br><span class="line">    &#125; catch( MyException e ) &#123;</span><br><span class="line">      e.printStackTrace( System.out );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">      g();</span><br><span class="line">    &#125; catch( MyException e ) &#123;</span><br><span class="line">      e.printStackTrace( System.out );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">Throwing MyException from f()</span><br><span class="line">MyException</span><br><span class="line">      at ...</span><br><span class="line">      at ...</span><br><span class="line">Throwing MyException from g()</span><br><span class="line">MyException: Originated in g() // 此即创建异常类型时传入的String参数</span><br><span class="line">      at ...</span><br><span class="line">      at ...</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="捕获所有异常"><a href="#捕获所有异常" class="headerlink" title="捕获所有异常"></a>捕获所有异常</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; catch( Exception e ) &#123; // 填写异常的基类，该catch子句一般置于末尾</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Exception类型所持有的方法：</p>
<ul>
<li>String getMessage()</li>
<li>String getLocalizedMessage()</li>
<li>String toString()</li>
<li>void printStackTrace()</li>
<li>void printStackTrace( PrintStream )</li>
<li>void printStackTrace( javo.io.PrintWriter )</li>
</ul>
<p>注意：从下往上每个方法都比前一个提供了更多的异常信息！</p>
<hr>
<h2 id="栈轨迹"><a href="#栈轨迹" class="headerlink" title="栈轨迹"></a>栈轨迹</h2><p>printStackTrace()方法所提供的栈轨迹信息可以通过getStackTrace()方法来Get，举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  throw new Exception();</span><br><span class="line">&#125; catch( Exception e ) &#123;</span><br><span class="line">  for( StackTraceElement ste : e.getStackTrace() )</span><br><span class="line">    System.out.println( ste.getMethodName() );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用getMethodName()方法来给出异常栈轨迹所经过的方法名！</p>
<hr>
<h2 id="重抛异常"><a href="#重抛异常" class="headerlink" title="重抛异常"></a>重抛异常</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; catch( Exception e ) &#123;</span><br><span class="line">  throw e;   // 重新抛出一个异常！</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若只是简单地将异常重新抛出，则而后用printStackTrace()显示的将是原异常抛出点的调用栈信息，而非重新抛出点的信息，欲更正该信息，可以使用fillInStackTrace()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; catch( Exception e ) &#123;</span><br><span class="line">  throw (Exception)e.fillInStackTrace(); // 该行就成了异常的新发生地！</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="异常链"><a href="#异常链" class="headerlink" title="异常链"></a>异常链</h2><p>异常链：在捕获一个异常后抛出另一个异常，并希望将原始的异常信息保存下来！</p>
<p>解决办法：</p>
<ol>
<li>在异常的ctor中加入cause参数</li>
<li>使用initCause()方法</li>
</ol>
<p>注意：Throwable子类中，仅三种基本的异常类提供了待cause参数的ctor（Error、Exception、RuntimeException），其余情况只能靠initCause()方法，举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class DynamicFieldsException extends Exception &#123; &#125;</span><br><span class="line"></span><br><span class="line">public Object setField( String id, Object value ) throws DynamicFieldsException &#123;</span><br><span class="line"></span><br><span class="line">  if( value == null ) &#123;</span><br><span class="line">    DynamicFieldsException dfe = new DynamicFieldsException();</span><br><span class="line">    dfe.initCause( new NullPointerException() ); </span><br><span class="line">    throw dfe;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Object result = null;</span><br><span class="line">  try &#123;</span><br><span class="line">    result = getField(id);</span><br><span class="line">  &#125; catch( NoSuchFieldException e ) &#123;</span><br><span class="line">    throw new RuntimeException( e );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Java标准异常"><a href="#Java标准异常" class="headerlink" title="Java标准异常"></a>Java标准异常</h2><p><img src="http://upload-images.jianshu.io/upload_images/9824247-5981e42aa0005346.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java标准异常类体系"></p>
<ul>
<li>看这个图需要明确：程序员一般关心Exception基类型的异常</li>
<li>由图中可知，Error、RuntimeException都叫做“Unchecked Exception”，即不检查异常，程序员也无需写异常处理的代码，这种自动捕获</li>
<li>若诸如RuntimeException这种Unchecked异常没有被捕获而直达main()，则程序在退出前将自动调用异常的printStackTrace()方法</li>
</ul>
<hr>
<h2 id="使用finally进行清理"><a href="#使用finally进行清理" class="headerlink" title="使用finally进行清理"></a>使用finally进行清理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; catch(...) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; finally &#123; // finally子句总是会被执行！！！</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用时机：</p>
<ul>
<li>当需要把内存之外的资源（如：文件句柄、网络连接、某个外部世界的开关）恢复到初始状态时！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; catch(...) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; finally &#123; // finally子句总是会被执行！！！</span><br><span class="line">  sw.off(); // 最后总是需要关掉某个开关！</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在return中使用finally</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void func( int i ) &#123;</span><br><span class="line">  </span><br><span class="line">  try &#123;</span><br><span class="line">    if( i==1 )</span><br><span class="line">      return;</span><br><span class="line">    if( i==2 )</span><br><span class="line">      return;</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    print( &quot;Performing cleanup!&quot; ); // 即使上面有很多return，但该句肯定被执行</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>finally存在的缺憾：两种情况下的finally使用会导致异常丢失！</p>
<ul>
<li>前一个异常还未处理就抛出下一个异常</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 异常类</span><br><span class="line">class VeryImportantException extends Exception &#123;</span><br><span class="line">  poublic String toString() &#123;</span><br><span class="line">    return &quot;A verfy important exception!&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class HoHumException extends Exception &#123;</span><br><span class="line">  public String toString() &#123;</span><br><span class="line">    return &quot;A trivial exception!&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------------</span><br><span class="line">// 使用异常的客户端</span><br><span class="line">public class LostMessage &#123;</span><br><span class="line">  void f() throws VeryImportantException &#123;</span><br><span class="line">    throw new VeryImportantException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void dispose() throws HoHumException &#123;</span><br><span class="line">    throw new HoHumException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void main( String[] args ) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      LostMessage lm = new LostMessage();</span><br><span class="line">      try &#123;</span><br><span class="line">        lm.f();</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        lm.dispose(); // 最后只会该异常生效，lm.f()抛出的异常丢了！</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch( Exception e ) &#123;</span><br><span class="line">      System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">// 输出</span><br><span class="line">A trivial exception!</span><br></pre></td></tr></table></figure>
<ul>
<li>finally子句中的return</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main( String[] args ) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    throw new RuntimeException();</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    return; // 这将会掩盖所有的异常抛出</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="继承基类、实现接口时的异常限制"><a href="#继承基类、实现接口时的异常限制" class="headerlink" title="继承基类、实现接口时的异常限制"></a>继承基类、实现接口时的异常限制</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">// 异常类</span><br><span class="line">class A extends Exception &#123; &#125;</span><br><span class="line">class A1 extends A &#123; &#125;</span><br><span class="line">class A2 extends A &#123; &#125;</span><br><span class="line">class A1_1 extends A1 &#123; &#125;</span><br><span class="line"></span><br><span class="line">class B extends Exception &#123; &#125;</span><br><span class="line">class B1 extends B &#123; &#125;</span><br><span class="line">-------------------------------------------------</span><br><span class="line">// 用了异常类的基类</span><br><span class="line">abstract class Base &#123;</span><br><span class="line">  public Base() throws A &#123; &#125;</span><br><span class="line">  public void event() throws A &#123; &#125;                   // (1)</span><br><span class="line">  public abstract void atBat throws A1, A2;</span><br><span class="line">  public void walk() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">-------------------------------------------------</span><br><span class="line">// 用了异常类的接口</span><br><span class="line">interface Interf &#123;</span><br><span class="line">  public void event() throws B1;</span><br><span class="line">  public void rainHard() throws B1;</span><br><span class="line">&#125;</span><br><span class="line">-------------------------------------------------</span><br><span class="line">// 继承基类并实现接口的客户端类</span><br><span class="line">public class Ext extends Base implements Interf &#123;</span><br><span class="line"></span><br><span class="line">  public Ext() throws B1, A &#123; &#125;            // (2)</span><br><span class="line">  public Ext( String s ) throws A1, A &#123;&#125;   // (2)</span><br><span class="line">  public void walk() throws A1_1 &#123; &#125;       // (3) 编译错误！</span><br><span class="line">  public void rainHard() throws B1 &#123;&#125;      // (4)</span><br><span class="line">  public void event() &#123; &#125;                  // (5)</span><br><span class="line">  public void atBat() throws A1_1 &#123; &#125;      // (6)</span><br><span class="line"></span><br><span class="line">  public static void main( String[] args ) &#123;</span><br><span class="line">  </span><br><span class="line">    try &#123;</span><br><span class="line">      Ext ext = new Ext();</span><br><span class="line">      ext.atBat();</span><br><span class="line">    &#125; catch( A1_1 e ) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125; catch( B1 e ) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125; catch( A e ) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">      Base base = new Ext();</span><br><span class="line">      ext.atBat();</span><br><span class="line">    &#125; catch( A2 e ) &#123; // 这里的catch必须按照Base中函数的异常抛出来写</span><br><span class="line">      ...</span><br><span class="line">    &#125; catch( A1 e ) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125; catch( B1 e ) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125; catch( A ) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子可以总结如下：【注意对应数字标号】</p>
<ul>
<li>(1) 基类的构造器或者方法声明了抛出异常，但实际上没有，这里相当于为继承类写了一个异常抛出规范，子类实现时安装这个规范来抛异常</li>
<li>(2) 从这两个ctor看出：异常限制对ctor不生效，子类ctor可以抛出任何异常而不管基类ctor所抛出的异常</li>
<li>(3) 基类函数没抛异常，派生类重写时不能瞎抛！</li>
<li>(4) 完全遵守基类的抛出，正常情况</li>
<li>(5) 基类函数抛了异常，派生类重写时不抛也是OK的</li>
<li>(6) 派生类重写基类函数时抛的异常可以是基类函数抛出异常的子类型</li>
</ul>
<hr>
<h2 id="构造器中异常如何书写"><a href="#构造器中异常如何书写" class="headerlink" title="构造器中异常如何书写"></a>构造器中异常如何书写</h2><p>对于在构造阶段可能会抛出异常并要求清理的类，安全的方式是使用嵌套的try子句：即在创建需要清理的对象之后，立即进入一个try-finally块，举例：</p>
<blockquote>
<p>特别需要注意的是下面的例子里<strong>在ctor中对文件句柄的close</strong>应放置的合理位置！</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">// 需要清理的对象类</span><br><span class="line">class InputFile &#123;</span><br><span class="line">  private BufferedReader in;</span><br><span class="line">  </span><br><span class="line">  InputFile( String fname ) throws Exception &#123;  // 构造函数！</span><br><span class="line">    try &#123;</span><br><span class="line">      in = new BufferedReader( new FileReader(fname) );</span><br><span class="line">      // 这里放置可能抛出异常的其他代码</span><br><span class="line">    &#125; catch( FileNotFoundException e ) &#123; // 若上面的FileReader异常，将会抛FileNotFoundException，走到这里，该分支无需in.close()的</span><br><span class="line">      System.out.println( &quot;Could not open &quot; + fname );</span><br><span class="line">      throw e;</span><br><span class="line">    &#125; catch( Exception e ) &#123;</span><br><span class="line">      // 走到这里其实说明in对象已经构建成功，这里是必须in.close()的</span><br><span class="line">      try &#123;</span><br><span class="line">        in.close();   // 注意此处关闭动作单独用try进行保障</span><br><span class="line">      &#125; catch( IOException e2 ) &#123;</span><br><span class="line">        System.out.println(&quot;in.close() unsuccessful&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      throw e;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      // 注意in.close() 不要在此处关闭，因为try中假如BufferedReader构造失败，此时in对象未生成成功，是无需close()一说的！</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  String getLine() &#123;</span><br><span class="line">    String s;</span><br><span class="line">    try &#123;</span><br><span class="line">      s = in.readLine();</span><br><span class="line">    &#125; catch( IOException e ) &#123;</span><br><span class="line">      System.out.println( &quot;readLine() unsuccessful!&quot; );</span><br><span class="line">      s = &quot;failed&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return s;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void cleanup() &#123;  // 提供手动的关闭文件句柄的操作函数</span><br><span class="line">    try &#123;</span><br><span class="line">      in.close();</span><br><span class="line">    &#125; catch( IOException e ) &#123;</span><br><span class="line">      System.out.println( &quot;in.close() failed !&quot; );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------</span><br><span class="line">// 客户端代码</span><br><span class="line">public class Cleanup &#123;</span><br><span class="line"></span><br><span class="line">  public static void main( String[] args ) &#123;</span><br><span class="line">    </span><br><span class="line">    try &#123;</span><br><span class="line">      InputFile in = new InputFile( &quot;Cleanup.java&quot; );</span><br><span class="line">      try &#123; // 上面InputFile构造完成以后立即进入该try-finally子句！</span><br><span class="line">        String s = &quot;&quot;;</span><br><span class="line">        int i = 1;</span><br><span class="line">        while( (s = in.getLine()) != null )</span><br><span class="line">          System.out.println(&quot;&quot;+ i++ + &quot;: &quot; + s);</span><br><span class="line">      &#125; catch( Exception e ) &#123;</span><br><span class="line">        e.printStackTrace( System.out );</span><br><span class="line">      &#125; finally &#123;  // 该finally一定确保in能正常cleanup()！</span><br><span class="line">        in.cleanup();</span><br><span class="line">      &#125; </span><br><span class="line">    &#125; catch( Exception e ) &#123;</span><br><span class="line">      System.out.println( &quot;InputFile ctor failed!&quot; );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125; // end main()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>最后附上个人联系方式，欢迎大家交流学习：<br>个人博客：www.hansonwang99.com.cn<br>个人网站：<a href="http://113.209.119.170/" target="_blank" rel="noopener">http://113.209.119.170/</a> （捂脸的表情，很慢，1G 1M 1核的云主机上）<br>简    书：<a href="https://www.jianshu.com/u/d19536b0189b" target="_blank" rel="noopener">https://www.jianshu.com/u/d19536b0189b</a></p>
<p><img src="https://hansonwang99.github.io/img/wechat_qrcode.jpg" title="欢迎扫描我的二维码！"></p>
]]></content>
      
        <categories>
            
            <category> Java沉思录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[利用K8S技术栈打造个人私有云（连载之：K8S集群搭建）]]></title>
      <url>/2018/02/01/%E5%88%A9%E7%94%A8K8S%E6%8A%80%E6%9C%AF%E6%A0%88%E6%89%93%E9%80%A0%E4%B8%AA%E4%BA%BA%E7%A7%81%E6%9C%89%E4%BA%91%EF%BC%88%E8%BF%9E%E8%BD%BD%E4%B9%8B%EF%BC%9AK8S%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>利用K8S技术栈打造个人私有云连载文章</p>
<a id="more"></a>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-b8c9f19a9e567080.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="iPhone 5S"></p>
<hr>
<p>最近被业务折腾的死去活来，实在没时间发帖，花了好多个晚上才写好这篇帖子，后续会加油的！</p>
<hr>
<p>【利用K8S技术栈打造个人私有云系列文章目录】</p>
<ul>
<li><a href="https://www.jianshu.com/p/9bc87b5380e8" target="_blank" rel="noopener">利用K8S技术栈打造个人私有云（连载之：初章） </a></li>
<li><a href="https://www.jianshu.com/p/7d1fb03b8925" target="_blank" rel="noopener">利用K8S技术栈打造个人私有云（连载之：K8S集群搭建）</a></li>
<li><a href="https://www.jianshu.com/p/5b0cd99e0332" target="_blank" rel="noopener">利用K8S技术栈打造个人私有云（连载之：K8S环境理解和练手）</a></li>
<li>利用K8S技术栈打造个人私有云（连载之：基础镜像制作与实验）（Coming Soon…）</li>
<li>利用K8S技术栈打造个人私有云（连载之：资源控制研究）（Coming Soon…）</li>
<li>利用K8S技术栈打造个人私有云（连载之：私有云客户端打造）（Coming Soon…）</li>
<li>利用K8S技术栈打造个人私有云（连载之：总结与升华）（Coming Soon…）</li>
</ul>
<hr>
<h2 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h2><blockquote>
<p>玩集群嘛，当然要搞几台机器做节点！无赖自己并没有性能很强劲的多余机器，在家里翻箱倒柜，找出了几台破旧的本子，试试看吧，与其垫桌脚不如拿出来遛遛弯…</p>
</blockquote>
<p>总体环境安排如下图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-1d070c4ca3049662.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="集群总体架构布局"></p>
<p>各部分简介如下：</p>
<p><strong>Master节点</strong> ( 一台08年买的Hedy笔记本 Centos7.3 64bit )</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-3f152e1aa0c3ebed.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HEDY"></p>
<ul>
<li>docker </li>
<li>etcd</li>
<li>flannel</li>
<li>kube-apiserver</li>
<li>kube-scheduler</li>
<li>kube-controller-manager</li>
</ul>
<p><strong>Slave节点</strong> ( 一台二手Thinkpad T420s  Centos7.3 64bit )</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-e3e7e4a3a88cad93.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Thinkpad  T420s"></p>
<ul>
<li>docker</li>
<li>flannel</li>
<li>kubelet</li>
<li>kube-proxy</li>
</ul>
<p><strong>Client节点</strong>（ 一台12年的Sony Vaio SVS13 Win7 Ultimate）</p>
<ul>
<li>客户端嘛，毕竟甲方，不需要安装啥东西，有个ssh客户端能连到master和slave节点就OK</li>
</ul>
<p><strong>Docker镜像仓库</strong></p>
<ul>
<li>一般企业内部应用的话，其会搭建自己的docker registry，用作镜像仓库，我这里就直接用Docker Gub作为镜像仓库，自己不搭建了（其实主要是没机子啊！）</li>
</ul>
<p><strong>Wireless Router</strong> （雷猴子家的小米路由器3）</p>
<ul>
<li>最好能穿墙，因为我家路由器放在客厅，但我实验是在卧室里做的啊！</li>
</ul>
<blockquote>
<p>各部分全部都是由wifi进行互联，我个人不太喜欢一大堆线绕来绕去</p>
</blockquote>
<hr>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ol>
<li>先设置master节点和所有slave节点的主机名</li>
</ol>
<p>master上执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hostnamectl --static set-hostname  k8s-master</span><br></pre></td></tr></table></figure>
<p>slave上执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hostnamectl --static set-hostname  k8s-node-1</span><br></pre></td></tr></table></figure></p>
<ol>
<li>修改master和slave上的hosts</li>
</ol>
<p>在master和slave的<code>/etc/hosts</code>文件中均加入以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.168.31.166   k8s-master</span><br><span class="line">192.168.31.166   etcd</span><br><span class="line">192.168.31.166   registry</span><br><span class="line">192.168.31.199   k8s-node-1</span><br></pre></td></tr></table></figure>
<ol>
<li>关闭master和slave上的防火墙</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl disable firewalld.service</span><br><span class="line">systemctl stop firewalld.service</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="部署Master节点"><a href="#部署Master节点" class="headerlink" title="部署Master节点"></a>部署Master节点</h2><p>master节点需要安装以下组件：</p>
<ul>
<li>etcd</li>
<li>flannel</li>
<li>docker</li>
<li>kubernets</li>
</ul>
<p>下面按顺序阐述</p>
<p><strong>1. etcd安装</strong></p>
<ul>
<li>安装命令：<code>yum install etcd -y</code></li>
<li>编辑etcd的默认配置文件<code>/etc/etcd/etcd.conf</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"># [member]</span><br><span class="line">ETCD_NAME=master</span><br><span class="line">ETCD_DATA_DIR=&quot;/var/lib/etcd/default.etcd&quot;</span><br><span class="line">#ETCD_WAL_DIR=&quot;&quot;</span><br><span class="line">#ETCD_SNAPSHOT_COUNT=&quot;10000&quot;</span><br><span class="line">#ETCD_HEARTBEAT_INTERVAL=&quot;100&quot;</span><br><span class="line">#ETCD_ELECTION_TIMEOUT=&quot;1000&quot;</span><br><span class="line">#ETCD_LISTEN_PEER_URLS=&quot;http://localhost:2380&quot;</span><br><span class="line">ETCD_LISTEN_CLIENT_URLS=&quot;http://0.0.0.0:2379,http://0.0.0.0:4001&quot;</span><br><span class="line">#ETCD_MAX_SNAPSHOTS=&quot;5&quot;</span><br><span class="line">#ETCD_MAX_WALS=&quot;5&quot;</span><br><span class="line">#ETCD_CORS=&quot;&quot;</span><br><span class="line">#</span><br><span class="line">#[cluster]</span><br><span class="line">#ETCD_INITIAL_ADVERTISE_PEER_URLS=&quot;http://localhost:2380&quot;</span><br><span class="line"># if you use different ETCD_NAME (e.g. test), set ETCD_INITIAL_CLUSTER value for this name, i.e. &quot;test=http://...&quot;</span><br><span class="line">#ETCD_INITIAL_CLUSTER=&quot;default=http://localhost:2380&quot;</span><br><span class="line">#ETCD_INITIAL_CLUSTER_STATE=&quot;new&quot;</span><br><span class="line">#ETCD_INITIAL_CLUSTER_TOKEN=&quot;etcd-cluster&quot;</span><br><span class="line">ETCD_ADVERTISE_CLIENT_URLS=&quot;http://etcd:2379,http://etcd:4001&quot;</span><br><span class="line">#ETCD_DISCOVERY=&quot;&quot;</span><br><span class="line">#ETCD_DISCOVERY_SRV=&quot;&quot;</span><br><span class="line">#ETCD_DISCOVERY_FALLBACK=&quot;proxy&quot;</span><br><span class="line">#ETCD_DISCOVERY_PROXY=&quot;&quot;</span><br><span class="line">#ETCD_STRICT_RECONFIG_CHECK=&quot;false&quot;</span><br><span class="line">#ETCD_AUTO_COMPACTION_RETENTION=&quot;0&quot;</span><br><span class="line">#ETCD_ENABLE_V2=&quot;true&quot;</span><br><span class="line">#</span><br><span class="line">#[proxy]</span><br><span class="line">#ETCD_PROXY=&quot;off&quot;</span><br><span class="line">#ETCD_PROXY_FAILURE_WAIT=&quot;5000&quot;</span><br><span class="line">#ETCD_PROXY_REFRESH_INTERVAL=&quot;30000&quot;</span><br><span class="line">#ETCD_PROXY_DIAL_TIMEOUT=&quot;1000&quot;</span><br><span class="line">#ETCD_PROXY_WRITE_TIMEOUT=&quot;5000&quot;</span><br><span class="line">#ETCD_PROXY_READ_TIMEOUT=&quot;0&quot;</span><br><span class="line">#</span><br><span class="line">#[security]</span><br><span class="line">#ETCD_CERT_FILE=&quot;&quot;</span><br><span class="line">#ETCD_KEY_FILE=&quot;&quot;</span><br><span class="line">#ETCD_CLIENT_CERT_AUTH=&quot;false&quot;</span><br><span class="line">#ETCD_TRUSTED_CA_FILE=&quot;&quot;</span><br><span class="line">#ETCD_AUTO_TLS=&quot;false&quot;</span><br><span class="line">#ETCD_PEER_CERT_FILE=&quot;&quot;</span><br><span class="line">#ETCD_PEER_KEY_FILE=&quot;&quot;</span><br><span class="line">#ETCD_PEER_CLIENT_CERT_AUTH=&quot;false&quot;</span><br><span class="line">#ETCD_PEER_TRUSTED_CA_FILE=&quot;&quot;</span><br><span class="line">#ETCD_PEER_AUTO_TLS=&quot;false&quot;</span><br><span class="line">#</span><br><span class="line">#[logging]</span><br><span class="line">#ETCD_DEBUG=&quot;false&quot;</span><br><span class="line"># examples for -log-package-levels etcdserver=WARNING,security=DEBUG</span><br><span class="line">#ETCD_LOG_PACKAGE_LEVELS=&quot;&quot;</span><br><span class="line">#</span><br><span class="line">#[profiling]</span><br><span class="line">#ETCD_ENABLE_PPROF=&quot;false&quot;</span><br><span class="line">#ETCD_METRICS=&quot;basic&quot;</span><br><span class="line">#</span><br><span class="line">#[auth]</span><br><span class="line">#ETCD_AUTH_TOKEN=&quot;simple&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>启动etcd并验证</li>
</ul>
<p>首先启动etcd服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start etcd // 启动etcd服务</span><br></pre></td></tr></table></figure></p>
<p>再获取etcd的健康指标看看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">etcdctl -C http://etcd:2379 cluster-health</span><br><span class="line">etcdctl -C http://etcd:4001 cluster-health</span><br></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-de2a7c9861b510ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查看etcd集群健康度"></p>
<p><strong>2. flannel安装</strong></p>
<ul>
<li>安装命令：<code>yum install flannel</code></li>
<li>配置flannel：<code>/etc/sysconfig/flanneld</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Flanneld configuration options  </span><br><span class="line"></span><br><span class="line"># etcd url location.  Point this to the server where etcd runs</span><br><span class="line">FLANNEL_ETCD_ENDPOINTS=&quot;http://etcd:2379&quot;</span><br><span class="line"></span><br><span class="line"># etcd config key.  This is the configuration key that flannel queries</span><br><span class="line"># For address range assignment</span><br><span class="line">FLANNEL_ETCD_PREFIX=&quot;/atomic.io/network&quot;</span><br><span class="line"></span><br><span class="line"># Any additional options that you want to pass</span><br><span class="line">#FLANNEL_OPTIONS=&quot;&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>配置etcd中关于flannel的key</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl mk /atomic.io/network/config &apos;&#123; &quot;Network&quot;: &quot;10.0.0.0/16&quot; &#125;&apos;</span><br></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-c35f72f7937b44f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>启动flannel并设置开机自启</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start flanneld.service</span><br><span class="line">systemctl enable flanneld.service</span><br></pre></td></tr></table></figure>
<p><strong>3. docker安装</strong></p>
<p>该部分网上教程太多了，主要步骤如下</p>
<ul>
<li>安装命令：<code>yum install docker -y</code></li>
<li>开启docker服务：<code>service docker start</code></li>
<li>设置docker开启自启动：<code>chkconfig docker on</code></li>
</ul>
<p><strong>4. kubernets安装</strong></p>
<p>k8s的安装命令很简单，执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install kubernetes</span><br></pre></td></tr></table></figure>
<p>但k8s需要配置的东西比较多，正如第一节“环境介绍”中提及的，毕竟master上需要运行以下组件：</p>
<ul>
<li>kube-apiserver</li>
<li>kube-scheduler</li>
<li>kube-controller-manager</li>
</ul>
<p>下面详细阐述：</p>
<ul>
<li>配置<code>/etc/kubernetes/apiserver</code>文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">###</span><br><span class="line"># kubernetes system config</span><br><span class="line">#</span><br><span class="line"># The following values are used to configure the kube-apiserver</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"># The address on the local server to listen to.</span><br><span class="line">KUBE_API_ADDRESS=&quot;--address=0.0.0.0&quot;</span><br><span class="line"></span><br><span class="line"># The port on the local server to listen on.</span><br><span class="line">KUBE_API_PORT=&quot;--port=8080&quot;</span><br><span class="line"></span><br><span class="line"># Port minions listen on</span><br><span class="line">KUBELET_PORT=&quot;--kubelet-port=10250&quot;</span><br><span class="line"></span><br><span class="line"># Comma separated list of nodes in the etcd cluster</span><br><span class="line">KUBE_ETCD_SERVERS=&quot;--etcd-servers=http://etcd:2379&quot;</span><br><span class="line"></span><br><span class="line"># Address range to use for services</span><br><span class="line">KUBE_SERVICE_ADDRESSES=&quot;--service-cluster-ip-range=10.254.0.0/16&quot;</span><br><span class="line"></span><br><span class="line"># default admission control policies</span><br><span class="line"># KUBE_ADMISSION_CONTROL=&quot;--admission-control=NamespaceLifecycle,NamespaceExists,LimitRanger,SecurityContextDeny,ServiceAccount,ResourceQuota&quot;</span><br><span class="line">KUBE_ADMISSION_CONTROL=&quot;--admission-control=NamespaceLifecycle,NamespaceExists,LimitRanger,SecurityContextDeny,ResourceQuota&quot;</span><br><span class="line"></span><br><span class="line"># Add your own!</span><br><span class="line">KUBE_API_ARGS=&quot;&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>配置<code>/etc/kubernetes/config</code>文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">###</span><br><span class="line"># kubernetes system config</span><br><span class="line">#</span><br><span class="line"># The following values are used to configure various aspects of all</span><br><span class="line"># kubernetes services, including</span><br><span class="line">#</span><br><span class="line">#   kube-apiserver.service</span><br><span class="line">#   kube-controller-manager.service</span><br><span class="line">#   kube-scheduler.service</span><br><span class="line">#   kubelet.service</span><br><span class="line">#   kube-proxy.service</span><br><span class="line"># logging to stderr means we get it in the systemd journal</span><br><span class="line">KUBE_LOGTOSTDERR=&quot;--logtostderr=true&quot;</span><br><span class="line"></span><br><span class="line"># journal message level, 0 is debug</span><br><span class="line">KUBE_LOG_LEVEL=&quot;--v=0&quot;</span><br><span class="line"></span><br><span class="line"># Should this cluster be allowed to run privileged docker containers</span><br><span class="line">KUBE_ALLOW_PRIV=&quot;--allow-privileged=false&quot;</span><br><span class="line"></span><br><span class="line"># How the controller-manager, scheduler, and proxy find the apiserver</span><br><span class="line">KUBE_MASTER=&quot;--master=http://k8s-master:8080&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>启动k8s各个组件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl start kube-apiserver.service</span><br><span class="line">systemctl start kube-controller-manager.service</span><br><span class="line">systemctl start kube-scheduler.service</span><br></pre></td></tr></table></figure>
<ul>
<li>设置k8s各组件开机启动</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable kube-apiserver.service</span><br><span class="line">systemctl enable kube-controller-manager.service</span><br><span class="line">systemctl enable kube-scheduler.service</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="部署Slave节点"><a href="#部署Slave节点" class="headerlink" title="部署Slave节点"></a>部署Slave节点</h2><p>slave节点需要安装以下组件：</p>
<ul>
<li>flannel</li>
<li>docker</li>
<li>kubernetes</li>
</ul>
<p>下面按顺序阐述：</p>
<p><strong>1. flannel安装</strong></p>
<ul>
<li>安装命令：<code>yum install flannel</code></li>
<li>配置flannel：<code>/etc/sysconfig/flanneld</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Flanneld configuration options  </span><br><span class="line"></span><br><span class="line"># etcd url location.  Point this to the server where etcd runs</span><br><span class="line">FLANNEL_ETCD_ENDPOINTS=&quot;http://etcd:2379&quot;</span><br><span class="line"></span><br><span class="line"># etcd config key.  This is the configuration key that flannel queries</span><br><span class="line"># For address range assignment</span><br><span class="line">FLANNEL_ETCD_PREFIX=&quot;/atomic.io/network&quot;</span><br><span class="line"></span><br><span class="line"># Any additional options that you want to pass</span><br><span class="line">#FLANNEL_OPTIONS=&quot;&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>启动flannel并设置开机自启</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start flanneld.service</span><br><span class="line">systemctl enable flanneld.service</span><br></pre></td></tr></table></figure>
<p><strong>2. docker安装</strong></p>
<p>参考前文master节点上部署docker过程，此处不再赘述</p>
<p><strong>3. kubernetes安装</strong></p>
<p>安装命令：<code>yum install kubernetes</code></p>
<p>不同于master节点，slave节点上需要运行kubernetes的如下组件：</p>
<ul>
<li>kubelet</li>
<li>kubernets-proxy</li>
</ul>
<p>下面详细阐述要配置的东西：</p>
<ul>
<li>配置<code>/etc/kubernetes/config</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">###</span><br><span class="line"># kubernetes system config</span><br><span class="line">#</span><br><span class="line"># The following values are used to configure various aspects of all</span><br><span class="line"># kubernetes services, including</span><br><span class="line">#</span><br><span class="line">#   kube-apiserver.service</span><br><span class="line">#   kube-controller-manager.service</span><br><span class="line">#   kube-scheduler.service</span><br><span class="line">#   kubelet.service</span><br><span class="line">#   kube-proxy.service</span><br><span class="line"># logging to stderr means we get it in the systemd journal</span><br><span class="line">KUBE_LOGTOSTDERR=&quot;--logtostderr=true&quot;</span><br><span class="line"></span><br><span class="line"># journal message level, 0 is debug</span><br><span class="line">KUBE_LOG_LEVEL=&quot;--v=0&quot;</span><br><span class="line"></span><br><span class="line"># Should this cluster be allowed to run privileged docker containers</span><br><span class="line">KUBE_ALLOW_PRIV=&quot;--allow-privileged=false&quot;</span><br><span class="line"></span><br><span class="line"># How the controller-manager, scheduler, and proxy find the apiserver</span><br><span class="line">KUBE_MASTER=&quot;--master=http://k8s-master:8080&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>配置<code>/etc/kubernetes/kubelet</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">###</span><br><span class="line"># kubernetes kubelet (minion) config</span><br><span class="line"></span><br><span class="line"># The address for the info server to serve on (set to 0.0.0.0 or &quot;&quot; for all interfaces)</span><br><span class="line">KUBELET_ADDRESS=&quot;--address=0.0.0.0&quot;</span><br><span class="line"></span><br><span class="line"># The port for the info server to serve on</span><br><span class="line"># KUBELET_PORT=&quot;--port=10250&quot;</span><br><span class="line"></span><br><span class="line"># You may leave this blank to use the actual hostname</span><br><span class="line">KUBELET_HOSTNAME=&quot;--hostname-override=k8s-node-1&quot;</span><br><span class="line"></span><br><span class="line"># location of the api-server</span><br><span class="line">KUBELET_API_SERVER=&quot;--api-servers=http://k8s-master:8080&quot;</span><br><span class="line"></span><br><span class="line"># pod infrastructure container</span><br><span class="line">KUBELET_POD_INFRA_CONTAINER=&quot;--pod-infra-container-image=registry.access.redhat.com/rhel7/pod-infrastructure:latest&quot;</span><br><span class="line"></span><br><span class="line"># Add your own!</span><br><span class="line">KUBELET_ARGS=&quot;&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>启动kube服务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start kubelet.service</span><br><span class="line">systemctl start kube-proxy.service</span><br></pre></td></tr></table></figure>
<ul>
<li>设置k8s组件开机自启</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable kubelet.service</span><br><span class="line">systemctl enable kube-proxy.service</span><br></pre></td></tr></table></figure>
<p>至此为止，k8s集群的搭建过程就完成了，下面来验证一下集群是否搭建成功了</p>
<h2 id="验证集群状态"><a href="#验证集群状态" class="headerlink" title="验证集群状态"></a>验证集群状态</h2><ul>
<li>查看端点信息：<code>kubectl get endpoints</code></li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-b4c5cad8590090a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>查看集群信息：<code>kubectl cluster-info</code></li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-925036816371a655.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="集群信息"></p>
<ul>
<li>获取集群中的节点状态： <code>kubectl get nodes</code></li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-ada6e1cd1bbf0539.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="获取集群中的节点状态"></p>
<p>OK，节点已经就绪，可以在上面做实验了！</p>
<hr>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://www.kubernetes.org.cn/" target="_blank" rel="noopener">https://www.kubernetes.org.cn/</a></li>
</ul>
<hr>
<p>最后附上个人联系方式，欢迎大家交流学习：<br>个人博客：www.hansonwang99.com.cn<br>个人网站：<a href="http://113.209.119.170/" target="_blank" rel="noopener">http://113.209.119.170/</a> （捂脸的表情，很慢，1G 1M 1核的云主机上）<br>简    书：<a href="https://www.jianshu.com/u/d19536b0189b" target="_blank" rel="noopener">https://www.jianshu.com/u/d19536b0189b</a></p>
<p><img src="https://hansonwang99.github.io/img/wechat_qrcode.jpg" title="欢迎扫描我的二维码！"></p>
]]></content>
      
        <categories>
            
            <category> K8s沉思录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[利用K8S技术栈打造个人私有云（连载之：初章）]]></title>
      <url>/2018/01/24/%E5%88%A9%E7%94%A8K8S%E6%8A%80%E6%9C%AF%E6%A0%88%E6%89%93%E9%80%A0%E4%B8%AA%E4%BA%BA%E7%A7%81%E6%9C%89%E4%BA%91%EF%BC%88%E8%BF%9E%E8%BD%BD%E4%B9%8B%EF%BC%9A%E5%88%9D%E7%AB%A0%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>利用K8S技术栈打造个人私有云连载文章</p>
<a id="more"></a>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-f5551626a3c69a3d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="iMac Pro"></p>
<hr>
<h2 id="我的想法是什么"><a href="#我的想法是什么" class="headerlink" title="我的想法是什么"></a>我的想法是什么</h2><p>最近在学习Docker技术，相信Docker技术大家都有所了解，Docker类似于虚拟机（但与虚拟机又有本质不同），提供进程级别的隔离。我们可以利用Docker来方便地来做很多事情，比如搭建一个翻墙VPN、搞一个爬虫、弄一个私人博客，部署一个裸机上比较难以安装的环境等等……可以说几乎没有什么目的办不到，这简直是宅男老铁们的福利啊！</p>
<p>但话又说回来，单个Docker所能发挥的作用毕竟有限，也不便于批量管理，更满足不了各种量比较大的业务场景所需的高可用、弹性伸缩等特性，所以Docker得组集群来并赋予各种完善的调度机制才能发挥强大的技术优势。既然要组集群那就涉及诸如Docker的资源调度、管理等等一系列问题。Docker集群技术发展得很火热， 目前涉及Docker集群的三个主要的技术无外乎Docker Swarm、Kubernetes、Mesos三种主流方案。</p>
<p>Docker Swarm是Docker提供的原生集群技术，我只做过一些初步实践（<a href="https://www.jianshu.com/p/3f3c9e0e3db5" target="_blank" rel="noopener">Docker Swarm集群初探</a>），发现还比较容易上手，大家也可以自行去深入学习一下，我就不多说了。</p>
<p>Kubernetes（以下简称K8S）源自于Google，是一个为容器化应用提供自动部署、扩容和管理的开源项目，社区非常活跃，也是用得更加广泛的Docker集群技术。我最近也是花了一些时间在这上面进行学习，但由于缺少实际实践经验，总有点不痛不痒的感觉，所以没办法只能自己来创造一些实践，就想着用它来做出点什么出来。</p>
<p>好，背景介绍完了。那我到底想用我刚自学的Docker和Kubernetes来做一件什么事情呢？听我慢慢道来…</p>
<hr>
<p>当下云主机可以说非常火热了，不知道大家是否用过BAT等一系列厂商旗下XX云所提供的云主机服务。我们只需要买一个云主机，然后就可以尽情地去上面干各种事情了，常见的比如建站、搭博客、部署服务甚至直接买一个windows云主机直接用于办公。</p>
<p>以某个云服务为例，来张图看看：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-46f8ac0b0fbefb6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="某个云服务的控制台"></p>
<p>然后我们就可以进去付费创建一个云主机自己使用，就像下面这样：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-5fd6ce3bb6d34e4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="实例化（创建）云主机"></p>
<p>这种服务如今如此地火热，我想这背后肯定少不了的就是容器技术和集群技术的加持，想到这里我想大家应该明白我这篇文章的主题了。是的，本篇文章及接下来的连载系列文章将详细讲述如何用k8s技术栈打造一个属于自己的私有云服务（取名为 <strong>SheepCloud</strong>，怎么样是不是很时髦…）。这样的话，我自己在家就可以申请创建很多云主机节点，然后自己想做啥就做啥，什么云计算、分布式实验统统不都可以免费进行了！</p>
<p>嗯，理想是好的，接下来还有一大堆事情要做呢…</p>
<hr>
<h2 id="我准备打造什么样形式的个人私有云"><a href="#我准备打造什么样形式的个人私有云" class="headerlink" title="我准备打造什么样形式的个人私有云"></a>我准备打造什么样形式的个人私有云</h2><p>其实上面已经说过了，准备模仿那些云服务提供商的云主机功能，先在网页上申请创建云主机，创建成功后分配 <strong>IP地址/子网号 + 用户名 + 密码</strong> 给用户，这样用户就可以用用ssh方式连入分配到的具有独立IP的云主机中进行工作，这样就和那些服务商提供的云主机服务没有什么不同了。</p>
<p>所以首先得有前端页面，我自己用Vue.js写了一个Demo（目前还未跟后端联调），让大家有个感性的认识：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-df82fba2398131fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SheepCloud控制台界面"></p>
<h2 id="我准备如何来入手这个小项目"><a href="#我准备如何来入手这个小项目" class="headerlink" title="我准备如何来入手这个小项目"></a>我准备如何来入手这个小项目</h2><p>本来我的初衷就是想深入实践一下Docker和Kubernetes（以下简称K8S）是怎么玩的，但东西还真不少，总结了一下涉及的技术，可能还不止这些：</p>
<ul>
<li>Docker：不用多说，毕竟负责容器的落地，云主机本质上就是一个win或linux容器</li>
<li>Kubernetes：管理Docker的集群技术，这里面是有很多kube的组件</li>
<li>flannel：负责节点中容器间的通信以及私有云各个实例的IP地址规划</li>
<li>etcd：分布式数据库，kubernetes和flannel都需要它</li>
<li>SpringBt：驱动后端服务</li>
<li>Vue.js：编写私有云前端WEB页面<br>…</li>
</ul>
<p>我自己规划了一个基本路线来入手：</p>
<ul>
<li>熟悉Docker</li>
<li>熟悉Kubernetes基本概念并搭建K8S集群</li>
<li>K8S集群理解与练手实验</li>
<li>基础镜像制作与实验，能完成单个操作系统容器的手动管理</li>
<li>K8S资源控制代码编写，能实现集群对容器资源的自动控制</li>
<li>私有云客户端WEB前端页面编写</li>
<li>前后端联调</li>
<li>总结输出</li>
</ul>
<h2 id="我准备输出哪些东西"><a href="#我准备输出哪些东西" class="headerlink" title="我准备输出哪些东西"></a>我准备输出哪些东西</h2><p>准备输出连载文章 + 源码，这篇文章是连载系列的第一篇</p>
<ul>
<li><a href="https://www.jianshu.com/p/9bc87b5380e8" target="_blank" rel="noopener">利用K8S技术栈打造个人私有云（连载之：初章） </a>(已完成)</li>
<li>利用K8S技术栈打造个人私有云（连载之：K8S环境搭建）（Coming Soon…）</li>
<li>利用K8S技术栈打造个人私有云（连载之：K8S环境理解和练手）（Coming Soon…）</li>
<li>利用K8S技术栈打造个人私有云（连载之：基础镜像制作与实验）（Coming Soon…）</li>
<li>利用K8S技术栈打造个人私有云（连载之：资源控制研究）（Coming Soon…）</li>
<li>利用K8S技术栈打造个人私有云（连载之：私有云客户端打造）（Coming Soon…）</li>
<li>利用K8S技术栈打造个人私有云（连载之：总结与升华）（Coming Soon…）</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>学以致用这个词我近来感触颇深，学一门技术，如果不辅之以实践，真的很难深入其中。浮在表面不痛不痒地学习真心很不爽，没有实践，自己制造实践也要上！大家共勉</p>
<hr>
<p>最后附上个人联系方式，欢迎大家交流学习：<br>个人博客：www.hansonwang99.com.cn<br>个人网站：<a href="http://113.209.119.170/" target="_blank" rel="noopener">http://113.209.119.170/</a> （捂脸的表情，很慢，1G 1M 1核的云主机上）<br>简    书：<a href="https://www.jianshu.com/u/d19536b0189b" target="_blank" rel="noopener">https://www.jianshu.com/u/d19536b0189b</a></p>
<p><img src="https://hansonwang99.github.io/img/wechat_qrcode.jpg" title="欢迎扫描我的二维码！"></p>
]]></content>
      
        <categories>
            
            <category> K8s沉思录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[初探Kotlin+SpringBoot联合编程]]></title>
      <url>/2018/01/23/%E5%88%9D%E6%8E%A2Kotlin-SpringBoot%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>Kotlin是一门最近比较流行的静态类型编程语言，而且和Groovy、Scala一样同属Java系。Kotlin具有的很多静态语言特性诸如：类型判断、多范式、扩展函数、模式匹配等等让我无法只作为一个吃瓜群众了，所以稍微花了点时间了解了一下该语言。</p>
<a id="more"></a>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-4557d0b25ee5525c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Macbook"></p>
<hr>
<p>Kotlin是一门最近比较流行的静态类型编程语言，而且和Groovy、Scala一样同属Java系。Kotlin具有的很多静态语言特性诸如：类型判断、多范式、扩展函数、模式匹配等等让我无法只作为一个吃瓜群众了，所以稍微花了点时间了解了一下该语言。</p>
<p>本文主要介绍一下如何使用Kotlin结合SpringBt开发一个带有数据库交互的REST风格基本程序</p>
<hr>
<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><ul>
<li>JDK不用说了，Kotlin毕竟是运行在JVM环境下的语言，所以JDK必须，我这里用的JDK1.8</li>
<li>数据库：MySQL</li>
<li>数据库访问组件：Spring data jpa</li>
<li>J2EE框架：SpringBt 1.5.2.RELEASE</li>
<li>构建工具：Gradle</li>
</ul>
<hr>
<h2 id="工程创建"><a href="#工程创建" class="headerlink" title="工程创建"></a>工程创建</h2><p>没啥好说的，我这里创建的是基于Gradle的Kotlin工程：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-baac893f0e5a1191.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="基于Gradle的Kotlin工程"></p>
<p>创建完成后的基本工程样式和SpringBt的工程几乎没任何区别，给张图示意一下好了：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-3c96778d62f47999.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="工程基本样式"></p>
<p>好啦，接下来我们就来写代码完善这个工程即可</p>
<hr>
<h2 id="完善build-gradle配置"><a href="#完善build-gradle配置" class="headerlink" title="完善build.gradle配置"></a>完善build.gradle配置</h2><p>我们需要在build.gradle中引入SpringBt依赖，除此之外还要引入一些特定的插件方便我们向写Java代码一样来写Kotlin程序！</p>
<p>在dependencies中加入如下依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile &quot;org.jetbrains.kotlin:kotlin-stdlib-jre8:$kotlin_version&quot;</span><br><span class="line">    testCompile group: &apos;junit&apos;, name: &apos;junit&apos;, version: &apos;4.12&apos;</span><br><span class="line">    compile(&quot;org.springframework.boot:spring-boot-starter-web&quot;)</span><br><span class="line">    testCompile(&quot;org.springframework.boot:spring-boot-starter-test&quot;)</span><br><span class="line">    compile(&quot;org.springframework.boot:spring-boot-starter-data-jpa&quot;)</span><br><span class="line">    compile(&apos;mysql:mysql-connector-java:5.1.13&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样SpringBt相关的依赖就配置上了！</p>
<p>接下来我们配置两个非常关键的插件依赖：</p>
<ul>
<li>无参（no-arg）插件</li>
<li>全开放（allopen）插件</li>
</ul>
<p>我们先配上，等下解释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext.kotlin_version = &apos;1.1.1&apos;</span><br><span class="line">    ext.springboot_version = &apos;1.5.2.RELEASE&apos;</span><br><span class="line"></span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        // Kotlin Gradle插件</span><br><span class="line">        classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;</span><br><span class="line">        // SpringBoot Gradle插件</span><br><span class="line">        classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:$springboot_version&quot;)</span><br><span class="line">        // Kotlin整合SpringBoot的默认无参构造函数，默认把所有的类设置open类插件</span><br><span class="line">        classpath(&quot;org.jetbrains.kotlin:kotlin-noarg:$kotlin_version&quot;) // 无参插件</span><br><span class="line">        classpath(&quot;org.jetbrains.kotlin:kotlin-allopen:$kotlin_version&quot;) // 全开放插件</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中（以下解释源自《Kotlin极简教程》）：</p>
<ul>
<li><p>org.jetbrains.kotlin:kotlin-noarg是无参（no-arg）编译器插件，它为具有特定注解的类生成一个额外的零参数构造函数。 这个生成的构造函数是合成的，因此不能从 Java 或 Kotlin 中直接调用，但可以使用反射调用。 这样我们就可以使用 Java Persistence API（JPA）实例化 data 类。</p>
</li>
<li><p>org.jetbrains.kotlin:kotlin-allopen 是全开放编译器插件。我们使用Kotlin 调用Java的Spring AOP框架和库，需要类为 open（可被继承实现），而Kotlin 类和函数都是默认 final 的，这样我们需要为每个类和函数前面加上open修饰符。这样的代码写起来很费事。还好，我们有all-open 编译器插件。它会适配 Kotlin 以满足这些框架的需求，并使用指定的注解标注类而其成员无需显式使用 open 关键字打开。 例如，当我们使用 Spring 时，就不需要打开所有的类，跟我们在Java中写代码一样，只需要用相应的注解标注即可，如 @Configuration 或 @Service。</p>
</li>
</ul>
<p>讲白了，引入这两个特定的插件的目的就是为了方便我们向写SpringBt代码一样来写Kotlin程序！</p>
<hr>
<h2 id="配置application-properties"><a href="#配置application-properties" class="headerlink" title="配置application.properties"></a>配置application.properties</h2><p>这里面主要是跟Mysql数据库相关的一些配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.url = jdbc:mysql://localhost:3306/easykotlin</span><br><span class="line">spring.datasource.username = root</span><br><span class="line">spring.datasource.password = 你的Mysql密码</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">spring.jpa.database = MYSQL</span><br><span class="line">spring.datasource.testWhileIdle = true</span><br><span class="line">spring.datasource.validationQuery = SELECT 1</span><br><span class="line">spring.jpa.show-sql = true</span><br><span class="line">spring.jpa.hibernate.ddl-auto = update</span><br><span class="line">spring.jpa.hibernate.naming-strategy = org.hibernate.cfg.ImprovedNamingStrategy</span><br><span class="line">spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQL5Dialect</span><br><span class="line"></span><br><span class="line">server.port=7000</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="正式编写工程"><a href="#正式编写工程" class="headerlink" title="正式编写工程"></a>正式编写工程</h2><p>我们需要去数据库中查询东西，所以二话不说，写个访问数据库的标准代码层：</p>
<ul>
<li>controller</li>
<li>entity</li>
<li>repository</li>
<li>service</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-e8cd8481ead01eeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="整体代码框架"></p>
<p>各部分代码如下：</p>
<ul>
<li>People.kt</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">class People(</span><br><span class="line">        @Id @GeneratedValue(strategy = GenerationType.AUTO)</span><br><span class="line">        val id: Long?,</span><br><span class="line">        val firstName: String?,</span><br><span class="line">        val lastName: String?,</span><br><span class="line">        val gender: String?,</span><br><span class="line">        val age: Int?,</span><br><span class="line">        val gmtCreated: Date,</span><br><span class="line">        val gmtModified: Date</span><br><span class="line">) &#123;</span><br><span class="line">    override fun toString(): String &#123;</span><br><span class="line">        return &quot;People(id=$id, firstName=&apos;$firstName&apos;, lastName=&apos;$lastName&apos;, gender=&apos;$gender&apos;, age=$age, gmtCreated=$gmtCreated, gmtModified=$gmtModified)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>PeopleRepository.kt</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface PeopleRepository : CrudRepository&lt;People, Long&gt; &#123;</span><br><span class="line">    fun findByLastName(lastName: String): List&lt;People&gt;?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>PeopleService.kt</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">class PeopleService : PeopleRepository &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    val peopleRepository: PeopleRepository? = null</span><br><span class="line"></span><br><span class="line">    override fun findByLastName(lastName: String): List&lt;People&gt;? &#123;</span><br><span class="line">        return peopleRepository?.findByLastName(lastName)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun &lt;S : People?&gt; save(entity: S): S? &#123;</span><br><span class="line">        return peopleRepository?.save(entity)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun &lt;S : People?&gt; save(entities: MutableIterable&lt;S&gt;?): MutableIterable&lt;S&gt;? &#123;</span><br><span class="line">        return peopleRepository?.save(entities)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun delete(entities: MutableIterable&lt;People&gt;?) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun delete(entity: People?) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun delete(id: Long?) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun findAll(ids: MutableIterable&lt;Long&gt;?): MutableIterable&lt;People&gt;? &#123;</span><br><span class="line">        return peopleRepository?.findAll(ids)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun findAll(): MutableIterable&lt;People&gt;? &#123;</span><br><span class="line">        return peopleRepository?.findAll()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun exists(id: Long?): Boolean &#123;</span><br><span class="line">        return peopleRepository?.exists(id)!!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun count(): Long &#123;</span><br><span class="line">        return peopleRepository?.count()!!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun findOne(id: Long?): People? &#123;</span><br><span class="line">        return peopleRepository?.findOne(id)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun deleteAll() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>PeopleController.kt</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">class PeopleController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    val peopleService: PeopleService? = null</span><br><span class="line"></span><br><span class="line">    @GetMapping(value = &quot;/hello&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    fun hello(@RequestParam(value = &quot;lastName&quot;) lastName: String): Any &#123;</span><br><span class="line">        val peoples = peopleService?.findByLastName(lastName)</span><br><span class="line">        val map = HashMap&lt;Any, Any&gt;()</span><br><span class="line">        map.put(&quot;hello&quot;, peoples!!)</span><br><span class="line">        return map</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见有了无参、全开放组件加持后，写代码和写Java的代码基本没区别了</p>
<hr>
<h2 id="实际实验"><a href="#实际实验" class="headerlink" title="实际实验"></a>实际实验</h2><p>首先需要去Mysql中建好数据库，并插入一些数据：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-1f59d8e3ae409028.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数据库预览"></p>
<p>然后启动工程，访问：<br><a href="http://localhost:7000/hello?lastName=wang" target="_blank" rel="noopener">http://localhost:7000/hello?lastName=wang</a></p>
<p>可以看到数据成功被取回：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-6bc738ccd94b1e88.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="成功获取到数据"></p>
<hr>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>《Kotlin极简教程》</p>
<hr>
<p>最后附上个人联系方式，欢迎大家交流学习：<br>个人博客：www.hansonwang99.com.cn<br>个人网站：<a href="http://113.209.119.170/" target="_blank" rel="noopener">http://113.209.119.170/</a> （捂脸的表情，很慢，1G 1M 1核的云主机上）<br>简    书：<a href="https://www.jianshu.com/u/d19536b0189b" target="_blank" rel="noopener">https://www.jianshu.com/u/d19536b0189b</a></p>
<p><img src="https://hansonwang99.github.io/img/wechat_qrcode.jpg" title="欢迎扫描我的二维码！"></p>
]]></content>
      
        <categories>
            
            <category> Kotlin学习录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java编程思想学习录（连载之：内部类）]]></title>
      <url>/2018/01/21/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E5%BD%95%EF%BC%88%E8%BF%9E%E8%BD%BD%E4%B9%8B%EF%BC%9A%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>Java编程思想学习录连载文章</p>
<a id="more"></a>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-0fb7bdff80a77326.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Thinkpad 25 Anniversary"></p>
<p>用thinkpad打字确实很爽啊！</p>
<hr>
<h2 id="内部类基本概念"><a href="#内部类基本概念" class="headerlink" title="内部类基本概念"></a>内部类基本概念</h2><ul>
<li>可将一个类的定义置于另一个类定义的内部</li>
<li>内部类允许将逻辑相关的类组织在一起，并控制位于内部的类的可见性</li>
<li>甚至可将内部类定义于一个<strong>方法</strong>或者<strong>任意作用域</strong>内！</li>
<li>当然，内部类 ≠ 组合 </li>
<li>内部类拥有其外围类 所有元素的 访问权</li>
<li>更有甚，嵌套多层的内部类能透明地访问所有它所嵌入的外围类的所有成员</li>
</ul>
<p>一个典型的例子：利用 <strong>Java内部类</strong> 实现的 <strong>迭代器模式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// 接口</span><br><span class="line">-------------------------------------------------------------</span><br><span class="line">public interface Selector &#123;</span><br><span class="line">  boolean end();</span><br><span class="line">  Object current();</span><br><span class="line">  void next();</span><br><span class="line">&#125;</span><br><span class="line">// 外部类（集合类） + 内部类（迭代器类）</span><br><span class="line">-------------------------------------------------------------</span><br><span class="line">public class Sequence &#123; // 外部类（代表一个集合类）</span><br><span class="line">  </span><br><span class="line">  private Object[] items;</span><br><span class="line">  private int next = 0;</span><br><span class="line">  </span><br><span class="line">  public Sequence( int size ) &#123;</span><br><span class="line">    items = new Object[size];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void add( Object x ) &#123;</span><br><span class="line">    if( next &lt; items.length )</span><br><span class="line">      items[next++] = x;</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  // 迭代器类：实现了 Selector接口的 内部类</span><br><span class="line">  private class SequenceSelector implements Selector &#123;</span><br><span class="line">    private int i = 0;</span><br><span class="line">    public boolean end() &#123; return i == items.length; &#125;</span><br><span class="line">    public Object current() &#123; return items[i]; &#125;</span><br><span class="line">    public void next() &#123;</span><br><span class="line">      if( i&lt;items.length )</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Selector selector() &#123; // 该函数也表明了：内部类也可以向上转型，这样在外部就隐藏了实现细节！</span><br><span class="line">    return new SequenceSelector();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void main( String[] args ) &#123;</span><br><span class="line">    Sequence sequence = new Sequence(10);</span><br><span class="line">    for( int i=0; i&lt;10; ++i ) &#123; // 装填元素</span><br><span class="line">      sequence.add( Integer.toString(i) );</span><br><span class="line">    &#125;</span><br><span class="line">    Selector selector = sequence.selector(); // 获取iterator！</span><br><span class="line">    while( !selector.end() ) &#123;</span><br><span class="line">      print( selector.current() + &quot; &quot; );</span><br><span class="line">      selector.next();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 输出</span><br><span class="line">-------------------------------------------------------------</span><br><span class="line">0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="this-与-new-的使用场景"><a href="#this-与-new-的使用场景" class="headerlink" title=".this 与 .new 的使用场景"></a>.this 与 .new 的使用场景</h2><p>.this用于在内部类中生成对其外部类对象的引用之时，举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class DotThis &#123;</span><br><span class="line">  </span><br><span class="line">  void f() &#123; print(&quot;DotThis.f()&quot;); &#125;</span><br><span class="line">  </span><br><span class="line">  public class Inner &#123; // 内部类</span><br><span class="line">    public DotThis outer() &#123; // 返回外部类对象的引用</span><br><span class="line">      return DotThis.this; // 若直接返回this，那指的便是内部类自身</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Inner inner() &#123; return new Inner(); &#125;</span><br><span class="line"></span><br><span class="line">  public static void main( String[] args ) &#123;</span><br><span class="line">    DotThis dt = new DotThis();</span><br><span class="line">    DotThis.Inner dti = dt.inner();</span><br><span class="line">    dti.outer().f(); // 输出 DotThis.f()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>.new用于直接创建内部类的对象之时，距离：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class DotNew &#123;</span><br><span class="line">  public class Inner &#123; &#125; // 空内部类</span><br><span class="line">  public static void main( String[] args ) &#123;</span><br><span class="line">    DotNew dn = new DotNew();</span><br><span class="line">    DotNew.Inner dni = dn.new Inner(); //注意此处必须使用外部类的对象，而不能直接 DotNew.Inner dni = new DotNew.Inner()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="嵌套类（static类型的内部类）"><a href="#嵌套类（static类型的内部类）" class="headerlink" title="嵌套类（static类型的内部类）"></a>嵌套类（static类型的内部类）</h2><p>嵌套类是无需依赖其外部类的对象的。非static内部类通过一个特殊的this链接到其外围类的对象，而static类型的内部类无此this引用。</p>
<p><strong>接口与内部类</strong>有着很有趣的关系：<br>放到接口中的任何类自动都是public且static，即接口中的任何类都是嵌套类，我们甚至可以在接口的内部类中去实现其外围接口，举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface ClassInInterface &#123;</span><br><span class="line">  void howdy();</span><br><span class="line">  class Test implements ClassInInterface &#123; // 类Test默认static，所以是嵌套类</span><br><span class="line">    public void howdy() &#123;</span><br><span class="line">      print(&quot;Howdy!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main( String[] args ) &#123;</span><br><span class="line">      new Test().howdy(); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="在-方法-和-作用域-内的内部类"><a href="#在-方法-和-作用域-内的内部类" class="headerlink" title="在 方法 和 作用域 内的内部类"></a>在 <strong>方法</strong> 和 <strong>作用域</strong> 内的内部类</h2><p>可以称这类为 <strong>局部内部类</strong>！</p>
<p>方法中定义的内部类只能在方法内被使用，方法之外不可访问，举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Parcel &#123;  // parcel是“包裹”之意</span><br><span class="line">  </span><br><span class="line">  public Destination destination( String s ) &#123;</span><br><span class="line"></span><br><span class="line">    class PDestination implements Destination &#123; // 方法中定义的内部类</span><br><span class="line">      private String label;</span><br><span class="line">      private PDestination( String whereTo ) &#123; label = whereTo; &#125;</span><br><span class="line">      public String readLabel() &#123; return label; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return new PDestination( s ); // 只有在方法中才能访问内部类PDestination</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void main( String[] args ) &#123;</span><br><span class="line">    Parcel p = new Parcel();</span><br><span class="line">    Destination d = p.destination( &quot;Hello&quot; );</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更进一步，可在任意作用域内定义内部类，举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Parcel &#123;</span><br><span class="line">  </span><br><span class="line">  private void internalTracking( boolean b ) &#123;</span><br><span class="line">    </span><br><span class="line">    if( b ) &#123; // 局部作用域中定义了内部类，作用域之外不可访问！</span><br><span class="line">      class TrackingSlip &#123;</span><br><span class="line">        private String id;</span><br><span class="line">        TrackingSlip( String s ) &#123; id = s; &#125;</span><br><span class="line">        String getSlip() &#123; return id; &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void track() &#123; interTracking( true ); &#125;</span><br><span class="line"></span><br><span class="line">  public static void main( String[] args ) &#123;</span><br><span class="line">    Parcel p = new Parcel();</span><br><span class="line">    p.track();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>直观上看，这种内部类没有“名字”，举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Parcel &#123;</span><br><span class="line">  </span><br><span class="line">  public Contents contents() &#123;</span><br><span class="line">    return new Contents() &#123; // 此即匿名内部类！！！</span><br><span class="line">      private int i = 11;</span><br><span class="line">      public int value() &#123; return i; &#125;</span><br><span class="line">    &#125;; // ！！！注意这里必须要加分号！！！</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void main( String[] args ) &#123;</span><br><span class="line">    Parcel p = new Parcel();</span><br><span class="line">    Contents c = p.contents();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若想将外部的参数传到匿名内部类中（典型的如将外部参数用于对匿名内部类中的定义字段进行初始化时）使用的话，该参数必须final，举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Parcel &#123;</span><br><span class="line">  </span><br><span class="line">  public Destination destination( final String s ) &#123; // final必须！</span><br><span class="line">    return new Destination() &#123;</span><br><span class="line">      private String label = s;</span><br><span class="line">      public String readLabel() &#123; return label; &#125;</span><br><span class="line">    &#125;; // 分号必须！</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void mian( String[] args ) &#123;</span><br><span class="line">    Parcel p = new Parcel();</span><br><span class="line">    Destination d = p.destination(&quot;Hello&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>匿名内部类中不可能有命名的显式构造器，此时只能使用实例初始化的方式来模仿，举例（当然下面这个例子还反映了匿名内部类如何参与继承）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 基类</span><br><span class="line">---------------------------------------------</span><br><span class="line">abstact class Base() &#123;</span><br><span class="line">  public Base( int i ) &#123;</span><br><span class="line">    print( &quot;Base ctor, i = &quot; + i );</span><br><span class="line">  &#125;</span><br><span class="line">  public abstract void f();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//主类（其中包含了继承上面Base的派生匿名内部类！）</span><br><span class="line">----------------------------------------------</span><br><span class="line">public class AnonymousConstructor &#123;</span><br><span class="line">  </span><br><span class="line">  public static Base getBase( int i ) &#123; // 该处参数无需final，因为并未在下面的内部类中直接使用！</span><br><span class="line">    return new Base(i)&#123; // 匿名内部类</span><br><span class="line">      &#123; // 实例初始化语法！！！</span><br><span class="line">        print(&quot;Inside instance initializer&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      public void f() &#123; </span><br><span class="line">        print( &quot;In anonymous f()&quot; );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;; // 分号必须！</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void main( String[] args ) &#123;</span><br><span class="line">    Base base = getBase(47);</span><br><span class="line">    base.f();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">------------------------------------------</span><br><span class="line">Base ctor, i = 47 // 先基类</span><br><span class="line">Inside instance initializer // 再打印派生类</span><br><span class="line">In anonymous f()</span><br></pre></td></tr></table></figure>
<p><strong>匿名内部类</strong> + <strong>工厂模式</strong> =  更加简洁易懂：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">// Service接口</span><br><span class="line">---------------------------------------------------</span><br><span class="line">interface Service &#123;</span><br><span class="line">  void method1();</span><br><span class="line">  void method2();</span><br><span class="line">&#125;</span><br><span class="line">// ServiceFactory接口</span><br><span class="line">---------------------------------------------------</span><br><span class="line">interface ServiceFactory &#123;</span><br><span class="line">  Service getService();</span><br><span class="line">&#125;</span><br><span class="line">// Service接口的实现</span><br><span class="line">---------------------------------------------------</span><br><span class="line">class Implementation1 implements Service &#123;</span><br><span class="line">  private Implementation1() &#123;&#125; // 构造函数私有</span><br><span class="line">  public void method1() &#123; print(&quot;Implementation1 method1&quot;); &#125;</span><br><span class="line">  public void method2() &#123; print(&quot;Implementation1 method2&quot;); &#125;</span><br><span class="line">  public static ServiceFactory factory = </span><br><span class="line">    new ServiceFactory() &#123;</span><br><span class="line">      public Service getService() &#123;</span><br><span class="line">        return new Implementation1();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;; // 分号必须！！！</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Implementation2 implements Service &#123;</span><br><span class="line">  private Implementation2() &#123;&#125;</span><br><span class="line">  public void method1() &#123; print(&quot;Implementation2 method1&quot;); &#125;</span><br><span class="line">  public void method2() &#123; print(&quot;Implementation2 method2&quot;); &#125;</span><br><span class="line">  public static ServiceFactory factory = </span><br><span class="line">    new ServiceFactory() &#123;</span><br><span class="line">      public Service getService() &#123;</span><br><span class="line">        return new Implementation2();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;; // 分号必须！！！</span><br><span class="line">&#125;</span><br><span class="line">// 客户端代码</span><br><span class="line">----------------------------------------------------</span><br><span class="line">public class Factories &#123;</span><br><span class="line">  public static void serviceConsumer( ServiceFactory fact ) &#123;</span><br><span class="line">    Service s = fact.getService();</span><br><span class="line">    s.method1();</span><br><span class="line">    s.method2();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void main( String[] args ) &#123;</span><br><span class="line">    serviceComsumer( Implementation1.factory );</span><br><span class="line">    serviceComsumer( Implementation2.factory );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="总结：为什么需要内部类"><a href="#总结：为什么需要内部类" class="headerlink" title="总结：为什么需要内部类"></a>总结：为什么需要内部类</h2><p>内部类可以独立地继承自一个接口或者类而无需关注其外围类的实现，这使得扩展类或者接口更加灵活，控制的粒度也可以更细！</p>
<p>注意Java中还有一个细节：虽然Java中一个接口可以继承多个接口，但是一个类是不能继承多个类的！要想完成该特性，此时除了使用内部类来“扩充多重继承机制”，你可能别无选择，举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class D &#123; &#125;               // 普通类</span><br><span class="line">abstract class E &#123; &#125;      // 抽象类</span><br><span class="line"></span><br><span class="line">class Z extend D &#123;    // 外围类显式地完成一部分继承</span><br><span class="line">  E makeE() &#123;</span><br><span class="line">    return new E() &#123; &#125;; // 内部类隐式地完成一部分继承</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MultiImplementation &#123;</span><br><span class="line">  static void takesD( D d ) &#123; &#125;</span><br><span class="line">  static void takesE( E e ) &#123; &#125;</span><br><span class="line">  public static void main( String[] args ) &#123;</span><br><span class="line">    Z z = new Z();</span><br><span class="line">    takesD( z );</span><br><span class="line">    takesE( z.makeE() );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>最后附上个人联系方式，欢迎大家交流学习：<br>个人博客：www.hansonwang99.com.cn<br>个人网站：<a href="http://113.209.119.170/" target="_blank" rel="noopener">http://113.209.119.170/</a> （捂脸的表情，很慢，1G 1M 1核的云主机上）<br>简    书：<a href="https://www.jianshu.com/u/d19536b0189b" target="_blank" rel="noopener">https://www.jianshu.com/u/d19536b0189b</a></p>
<p><img src="https://hansonwang99.github.io/img/wechat_qrcode.jpg" title="欢迎扫描我的二维码！"></p>
]]></content>
      
        <categories>
            
            <category> Java沉思录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[为Hexo博客添加LiveRe评论系统]]></title>
      <url>/2018/01/20/%E4%B8%BAHexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0LiveRe%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/</url>
      <content type="html"><![CDATA[<p>最近有些网友问我，我的个人博客中的评论系统是怎么添加的，说实话我都有点忘了，毕竟搞了有好长一段时间了，唉不得不说这个遗忘得真是很快。<br>今天正好有时间，我就把如何为自己的Hexo博客添加评论系统写一篇水文好了。</p>
<a id="more"></a>
<blockquote>
<p>最近有些网友问我，我的个人博客中的评论系统是怎么添加的，说实话我都有点忘了，毕竟搞了有好长一段时间了，唉不得不说这个遗忘得真是很快。<br>今天正好有时间，我就把如何为自己的Hexo博客添加评论系统写一篇水文好了。</p>
</blockquote>
<p>相信大家看过很多个人博客，用Hexo搭建的博客应该说很流行了，既方便又极具性价比，适合大家自己来动手DIY。</p>
<p>我们都希望自己的博客具有一个评论系统，一方面用于收集大家的意见来更好的改进，另一方面评论系统也提供了一个读者与作者之间交流的平台。</p>
<p>评论系统可以说五花八门啦，用得多的比如：畅言、Gitment、Gitalk、LiveRe、Disqus、友言 等等</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-d910d225c8688587.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="畅言评论系统"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-61adee870bfbdcce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Gitment评论系统"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-4c2f710a968c5a03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Gitalk评论系统"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-6f65e6b4ed7a6870.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="LiveRe评论系统"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-85c4ee673e83e30f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="友言评论系统"></p>
<p>本文接下来主要阐述如何添加LiveRe作为博客的评论系统</p>
<hr>
<h2 id="首先注册并登录LiveRe"><a href="#首先注册并登录LiveRe" class="headerlink" title="首先注册并登录LiveRe"></a>首先注册并登录LiveRe</h2><p>LiveRe注册地址：<a href="https://livere.me/register?lang=zh-cn" target="_blank" rel="noopener">https://livere.me/register?lang=zh-cn</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-50057d202067280a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="LiveRe注册表单"></p>
<p>注册以后登录进去，选择City版进行安装，City版是免费的，对我们这种个人博客而言完全足够了</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-645d4a1bc7d698cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="选择City版本的LiveRe"></p>
<p>接下来需要填写一些关于你想将LiveRe用于的博客的一些信息：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-e05b05aea1bb46f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="信息填写"></p>
<p>填完之后，申请获取代码，此时其将会给你一段代码，该段代码等下需要加到你的个人博客的页面中，我们可以先将其复制并保存起来：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-f4bcc784bc74694a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="LiveRe代码"></p>
<hr>
<h2 id="在个人博客中加入LiveRe代码"><a href="#在个人博客中加入LiveRe代码" class="headerlink" title="在个人博客中加入LiveRe代码"></a>在个人博客中加入LiveRe代码</h2><p>首先去如路径：hexo_bolg/themes/your-theme/layout/_partial/post下创建livere.ejs代码。livere.ejs的内容就是上一步中获取的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 来必力City版安装代码 --&gt;</span><br><span class="line">&lt;div id=&quot;lv-container&quot; data-id=&quot;city&quot; data-uid=&quot;MTAyMC8zMzM5MC85OTQ2&quot;&gt;</span><br><span class="line">	&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">   (function(d, s) &#123;</span><br><span class="line">       var j, e = d.getElementsByTagName(s)[0];</span><br><span class="line"></span><br><span class="line">       if (typeof LivereTower === &apos;function&apos;) &#123; return; &#125;</span><br><span class="line"></span><br><span class="line">       j = d.createElement(s);</span><br><span class="line">       j.src = &apos;https://cdn-city.livere.com/js/embed.dist.js&apos;;</span><br><span class="line">       j.async = true;</span><br><span class="line"></span><br><span class="line">       e.parentNode.insertBefore(j, e);</span><br><span class="line">   &#125;)(document, &apos;script&apos;);</span><br><span class="line">	&lt;/script&gt;</span><br><span class="line">&lt;noscript&gt; 为正常使用来必力评论功能请激活JavaScript&lt;/noscript&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!-- City版安装代码已完成 --&gt;</span><br></pre></td></tr></table></figure>
<p>然后修改路径：hexo_bolg/themes/your-theme/layout/_partial下的article.ejs文件，在<code>&lt;% if (!index &amp;&amp; post.comments){ %&gt;</code> 代码块下添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (!index)&#123; %&gt;</span><br><span class="line">  &lt;% if (post.comments)&#123; %&gt;</span><br><span class="line">  &lt;%- partial(&apos;post/livere&apos;) %&gt;</span><br><span class="line">  &lt;% &#125; else &#123; %&gt;</span><br><span class="line">    &lt;div class=&quot;lv-container&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>
<p>我再来配一张图给你们看一下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-a1f5482a1bddba64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在article.ejs中添加一段代码"></p>
<p>此时LiveRe已经添加OK了，重新部署你的博客然后刷新页面就可以看到博客中添加好了LiveRe评论系统（比如我的博客：<a href="http://www.hansonwang99.com.cn/）：">http://www.hansonwang99.com.cn/）：</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-4beeb37383a52b3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="LiveRe评论系统添加完成"></p>
<hr>
<h2 id="如何自定义LiveRe的样式"><a href="#如何自定义LiveRe的样式" class="headerlink" title="如何自定义LiveRe的样式"></a>如何自定义LiveRe的样式</h2><p>LiveRe支持多重方式进行登录，而且其样式也是可以自定义的：<br><img src="http://upload-images.jianshu.io/upload_images/9824247-b4503bc8d2a61767.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="LiveRe的登录方式和样式"></p>
<p>可以去LiveRe的网站的管理页面中进行设置：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-468b514283d6c05f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="LiveRe管理页面"></p>
<p>更多好玩的东西你可以尽情探索，找到你自己喜欢的样式就可以啦</p>
<hr>
<p>最后附上个人联系方式，欢迎大家交流学习：<br>个人博客：www.hansonwang99.com.cn<br>个人网站：<a href="http://113.209.119.170/" target="_blank" rel="noopener">http://113.209.119.170/</a> （捂脸的表情，很慢，1G 1M 1核的云主机上）<br>简    书：<a href="https://www.jianshu.com/u/d19536b0189b" target="_blank" rel="noopener">https://www.jianshu.com/u/d19536b0189b</a></p>
<p><img src="https://hansonwang99.github.io/img/wechat_qrcode.jpg" title="欢迎扫描我的二维码！"></p>
]]></content>
      
        <categories>
            
            <category> Hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[前后端分离实践：基于vue实现网站前台的权限管理]]></title>
      <url>/2018/01/13/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%AE%9E%E8%B7%B5%EF%BC%9A%E5%9F%BA%E4%BA%8Evue%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%AB%99%E5%89%8D%E5%8F%B0%E7%9A%84%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<p>Vue系列实践文章</p>
<a id="more"></a>
<blockquote>
<p>Javascript做为当下的热门语言，用途很广泛，从前端到后端处处可见其存在，该技术如今在我们项目内部也大量使用来开发诸如CMS系统以及其他其他一些数据分析系统的前端页面，为此个人非常感兴趣并将其作为帽子卡的扩展内容来进行课余学习。</p>
</blockquote>
<hr>
<blockquote>
<p>Javascript框架鳞次栉比，但基本原理大致相同，因此选用国内人开发的vue.js进行一个初步的尝试。学习vue.js也一周多的时间了，说起vue的主要用法，无外乎Declarative Rendering、Component System、Client-side Routing、Vue-resource、Axios以及视项目大小而决定是否使用的Vuex，学习vue事小，主要转变思维，面向前后端分离的组件式web开发才是真正想去实践的。</p>
</blockquote>
<hr>
<blockquote>
<p>正好我的个人网站CodeSheep最近要开发后台管理，因此正好用vue这一套来实现了一下。说到后台管理，绕不开的问题就是权限的管理。既然想实践前后端分离这种思想，因此后台管理的所有web前端的东西应该独立由前端完成，这其中就包括很重要的由前端来根据权限进行相关东西的控制。我们想要做到的是：不同的权限对应着不同的路由，同时页面侧边栏也应该根据不同的权限，来异步生成对应的菜单，讲白了就是后台管理时不同权限的用户其看到的界面菜单是不一样的，因此有了这里实现登录和权限验证的一套流程。</p>
</blockquote>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="1、点击“登录”按钮触发登录事件"><a href="#1、点击“登录”按钮触发登录事件" class="headerlink" title="1、点击“登录”按钮触发登录事件"></a>1、点击“登录”按钮触发登录事件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">this.$store.dispatch(&apos;LoginByEmail&apos;, this.loginForm).then(() =&gt; &#123;</span><br><span class="line">  this.$router.push(&#123; path: &apos;/&apos; &#125;); //登录成功之后重定向到首页</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">  this.$message.error(err); //登录失败提示错误</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>其中异步触发的actions LoginByEmail的处理内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LoginByEmail (&#123; commit &#125;, userInfo) &#123;</span><br><span class="line">      const email = userInfo.email.trim()</span><br><span class="line">      return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        loginByEmail(email, userInfo.password).then(response =&gt; &#123;</span><br><span class="line">          const data = response.data</span><br><span class="line">          setToken(response.data.token)</span><br><span class="line">          commit(&apos;SET_TOKEN&apos;, data.token)</span><br><span class="line">          resolve()</span><br><span class="line">        &#125;).catch(error =&gt; &#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>很容易看出想做的是将从服务器端拿到的token（唯一标示用户身份）放到浏览器本地Cookie中去</p>
<h3 id="2、全局钩子router-beforeEach中拦截路由"><a href="#2、全局钩子router-beforeEach中拦截路由" class="headerlink" title="2、全局钩子router.beforeEach中拦截路由"></a>2、全局钩子router.beforeEach中拦截路由</h3><p>这一步是核心，具体处理流程示意如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-caec6e4bef6a20bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="路由拦截处理流程"></p>
<p>具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">  if (getToken()) &#123;  // 判断是否取到token</span><br><span class="line">    if (to.path === &apos;/login&apos;) &#123;</span><br><span class="line">      next(&#123; path: &apos;/&apos; &#125;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      if (store.getters.roles.length === 0) &#123;  // 判断当前用户是否已获取完user_info信息</span><br><span class="line">        store.dispatch(&apos;GetInfo&apos;).then(res =&gt; &#123; // 获取user_info</span><br><span class="line">          const roles = res.data.role</span><br><span class="line">          store.dispatch(&apos;GenerateRoutes&apos;, &#123; roles &#125;).then(() =&gt; &#123; // 生成可访问的路由表</span><br><span class="line">            router.addRoutes(store.getters.addRouters)  // 动态添加可访问路由表</span><br><span class="line">            next(&#123; ...to &#125;) // 放行路由</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;).catch(() =&gt; &#123;</span><br><span class="line">          store.dispatch(&apos;FedLogOut&apos;).then(() =&gt; &#123;</span><br><span class="line">            next(&#123; path: &apos;/login&apos; &#125;)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        next() // 放行该路由</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    if (whiteList.indexOf(to.path) !== -1) &#123; // 在免登录白名单里的路径，继续让其访问</span><br><span class="line">      next()</span><br><span class="line">    &#125; else &#123; // 其他不在白名单里的路径全部让其重定向到登录页面！</span><br><span class="line">      next(&apos;/login&apos;)</span><br><span class="line">      alert(&apos;not in white list, now go to the login page&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<hr>
<p>流程图中几个重要步骤解释一下：</p>
<ul>
<li><p>判断前端是否取到了token令牌：getToken()</p>
<blockquote>
<p>操作很简单，主要是从Cookie中获取，看token是不是已经拿到了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export function getToken () &#123;</span><br><span class="line">  return Cookies.get(TokenKey)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>vuex异步操作store.dispatch(‘GetInfo’)：获取用户信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GetInfo (&#123; commit, state &#125;) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    getInfo(state.token).then(response =&gt; &#123;</span><br><span class="line">      const data = response.data</span><br><span class="line">      console.log(data)</span><br><span class="line">      commit(&apos;SET_ROLES&apos;, data.role)</span><br><span class="line">      commit(&apos;SET_NAME&apos;, data.name)</span><br><span class="line">      resolve(response)</span><br><span class="line">    &#125;).catch(error =&gt; &#123;</span><br><span class="line">      reject(error)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>操作也很简单，用一个get的restful api从服务器获取用户的角色和名字</p>
</blockquote>
<ul>
<li>vuex异步操作store.dispatch(‘GenerateRoutes’, { roles })：根据不同的roles来生成不同的前台路由<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GenerateRoutes (&#123; commit &#125;, data) &#123;</span><br><span class="line">  return new Promise(resolve =&gt; &#123;</span><br><span class="line">    const &#123; roles &#125; = data</span><br><span class="line">    let accessedRouters</span><br><span class="line">    if (roles.indexOf(&apos;admin&apos;) &gt;= 0) &#123;</span><br><span class="line">      accessedRouters = asyncRouter</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      accessedRouters = filterAsyncRouter(asyncRouter, roles)</span><br><span class="line">    &#125;</span><br><span class="line">    commit(&apos;SET_ROUTERS&apos;, accessedRouters)</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>从代码中可以看出，我这是只区分了管理员角色admin和其他普通用户（即非Aadmin两种权限）</p>
</blockquote>
<p>该系列的实践后续还将尝试更多，将会一一撰帖成文，我也是个初学者，路漫漫而求索之。。。</p>
<hr>
<p>最后附上个人联系方式，欢迎大家交流学习：<br>个人博客：www.hansonwang99.com.cn<br>个人网站：<a href="http://113.209.119.170/（捂脸的表情，很慢，1G" target="_blank" rel="noopener">http://113.209.119.170/（捂脸的表情，很慢，1G</a> 1M 1核的云主机上）<br>简    书：<a href="https://www.jianshu.com/u/d19536b0189b" target="_blank" rel="noopener">https://www.jianshu.com/u/d19536b0189b</a></p>
<p><img src="https://hansonwang99.github.io/img/wechat_qrcode.jpg" title="欢迎扫描我的二维码！"></p>
]]></content>
      
        <categories>
            
            <category> Vue.js </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Vue.js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Elastic Search搜索引擎在SpringBoot中的实践]]></title>
      <url>/2018/01/09/Elasticsearch%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E5%9C%A8SpringBoot%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5/</url>
      <content type="html"><![CDATA[<p>Elastic Search搜索引擎在SpringBoot中的实践</p>
<a id="more"></a>
<hr>
<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><ul>
<li>ES版本：5.3.0</li>
<li>spring bt版本：1.5.9</li>
</ul>
<p>首先当然需要安装好elastic search环境，最好再安装上可视化插件 elasticsearch-head来便于我们直观地查看数据。</p>
<p>当然这部分可以参考本人的帖子：<br>《centos7上elastic search安装填坑记》<br><a href="https://www.jianshu.com/p/04f4d7b4a1d3" target="_blank" rel="noopener">https://www.jianshu.com/p/04f4d7b4a1d3</a></p>
<p>我的ES安装在<a href="http://113.209.119.170:9200/这个地址（该地址需要配到springboot项目中去）" target="_blank" rel="noopener">http://113.209.119.170:9200/这个地址（该地址需要配到springboot项目中去）</a></p>
<hr>
<h2 id="Spring工程创建"><a href="#Spring工程创建" class="headerlink" title="Spring工程创建"></a>Spring工程创建</h2><p>这部分没有特殊要交代的，但有几个注意点一定要当心</p>
<ul>
<li>注意在新建项目时记得勾选web和NoSQL中的Elasticsearch依赖，来张图说明一下吧：</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-785048db3dca0957.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建工程时勾选Nosql中的es依赖选项"></p>
<p>项目自动生成以后pom.xml中会自动添加<code>spring-boot-starter-data-elasticsearch</code>的依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>本项目中我们使用开源的基于restful的es java客户端<code>jest</code>，所以还需要在pom.xml中添加<code>jest</code>依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;io.searchbox&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;jest&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>除此之外还必须添加<code>jna</code>的依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;net.java.dev.jna&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;jna&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>否则启动spring项目的时候会报<code>JNA not found. native methods will be disabled.</code>的错误：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-128eaa8fa61a1b69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="JNA not found. native methods will be disabled."></p>
<ul>
<li>项目的配置文件application.yml中需要把es服务器地址配置对<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 6325</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  elasticsearch:</span><br><span class="line">    jest:</span><br><span class="line">      uris:</span><br><span class="line">      - http://113.209.119.170:9200  # ES服务器的地址！</span><br><span class="line">      read-timeout: 5000</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="代码组织"><a href="#代码组织" class="headerlink" title="代码组织"></a>代码组织</h2><p>我的项目代码组织如下：<br><img src="http://upload-images.jianshu.io/upload_images/9824247-65554c20279d1f6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="项目代码组织"></p>
<p>各部分代码详解如下，注释都有：</p>
<ul>
<li>Entity.java</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package com.hansonwang99.springboot_es_demo.entity;</span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import org.springframework.data.elasticsearch.annotations.Document;</span><br><span class="line"></span><br><span class="line">public class Entity implements Serializable&#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = -763638353551774166L;</span><br><span class="line"></span><br><span class="line">    public static final String INDEX_NAME = &quot;index_entity&quot;;</span><br><span class="line"></span><br><span class="line">    public static final String TYPE = &quot;tstype&quot;;</span><br><span class="line"></span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public Entity() &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Entity(Long id, String name) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Long getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Long id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>TestService.java</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.hansonwang99.springboot_es_demo.service;</span><br><span class="line"></span><br><span class="line">import com.hansonwang99.springboot_es_demo.entity.Entity;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public interface TestService &#123;</span><br><span class="line"></span><br><span class="line">    void saveEntity(Entity entity);</span><br><span class="line"></span><br><span class="line">    void saveEntity(List&lt;Entity&gt; entityList);</span><br><span class="line"></span><br><span class="line">    List&lt;Entity&gt; searchEntity(String searchContent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>TestServiceImpl.java</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.hansonwang99.springboot_es_demo.service.impl;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">import com.hansonwang99.springboot_es_demo.entity.Entity;</span><br><span class="line">import com.hansonwang99.springboot_es_demo.service.TestService;</span><br><span class="line">import org.elasticsearch.index.query.QueryBuilders;</span><br><span class="line">import org.elasticsearch.search.builder.SearchSourceBuilder;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import io.searchbox.client.JestClient;</span><br><span class="line">import io.searchbox.client.JestResult;</span><br><span class="line">import io.searchbox.core.Bulk;</span><br><span class="line">import io.searchbox.core.Index;</span><br><span class="line">import io.searchbox.core.Search;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class TestServiceImpl implements TestService &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger LOGGER = LoggerFactory.getLogger(TestServiceImpl.class);</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private JestClient jestClient;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void saveEntity(Entity entity) &#123;</span><br><span class="line">        Index index = new Index.Builder(entity).index(Entity.INDEX_NAME).type(Entity.TYPE).build();</span><br><span class="line">        try &#123;</span><br><span class="line">            jestClient.execute(index);</span><br><span class="line">            LOGGER.info(&quot;ES 插入完成&quot;);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            LOGGER.error(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 批量保存内容到ES</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void saveEntity(List&lt;Entity&gt; entityList) &#123;</span><br><span class="line">        Bulk.Builder bulk = new Bulk.Builder();</span><br><span class="line">        for(Entity entity : entityList) &#123;</span><br><span class="line">            Index index = new Index.Builder(entity).index(Entity.INDEX_NAME).type(Entity.TYPE).build();</span><br><span class="line">            bulk.addAction(index);</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            jestClient.execute(bulk.build());</span><br><span class="line">            LOGGER.info(&quot;ES 插入完成&quot;);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            LOGGER.error(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 在ES中搜索内容</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;Entity&gt; searchEntity(String searchContent)&#123;</span><br><span class="line">        SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();</span><br><span class="line">        //searchSourceBuilder.query(QueryBuilders.queryStringQuery(searchContent));</span><br><span class="line">        //searchSourceBuilder.field(&quot;name&quot;);</span><br><span class="line">        searchSourceBuilder.query(QueryBuilders.matchQuery(&quot;name&quot;,searchContent));</span><br><span class="line">        Search search = new Search.Builder(searchSourceBuilder.toString())</span><br><span class="line">                .addIndex(Entity.INDEX_NAME).addType(Entity.TYPE).build();</span><br><span class="line">        try &#123;</span><br><span class="line">            JestResult result = jestClient.execute(search);</span><br><span class="line">            return result.getSourceAsObjectList(Entity.class);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>EntityController.java</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">package com.hansonwang99.springboot_es_demo.controller;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">import com.hansonwang99.springboot_es_demo.entity.Entity;</span><br><span class="line">import com.hansonwang99.springboot_es_demo.service.TestService;</span><br><span class="line">import org.apache.commons.lang.StringUtils;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/entityController&quot;)</span><br><span class="line">public class EntityController &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    TestService cityESService;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value=&quot;/save&quot;, method=RequestMethod.GET)</span><br><span class="line">    public String save(long id, String name) &#123;</span><br><span class="line">        System.out.println(&quot;save 接口&quot;);</span><br><span class="line">        if(id&gt;0 &amp;&amp; StringUtils.isNotEmpty(name)) &#123;</span><br><span class="line">            Entity newEntity = new Entity(id,name);</span><br><span class="line">            List&lt;Entity&gt; addList = new ArrayList&lt;Entity&gt;();</span><br><span class="line">            addList.add(newEntity);</span><br><span class="line">            cityESService.saveEntity(addList);</span><br><span class="line">            return &quot;OK&quot;;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return &quot;Bad input value&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value=&quot;/search&quot;, method=RequestMethod.GET)</span><br><span class="line">    public List&lt;Entity&gt; save(String name) &#123;</span><br><span class="line">        List&lt;Entity&gt; entityList = null;</span><br><span class="line">        if(StringUtils.isNotEmpty(name)) &#123;</span><br><span class="line">            entityList = cityESService.searchEntity(name);</span><br><span class="line">        &#125;</span><br><span class="line">        return entityList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="实际实验"><a href="#实际实验" class="headerlink" title="实际实验"></a>实际实验</h2><p>增加几条数据，可以使用postman工具，也可以直接在浏览器中输入，如增加以下5条数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:6325/entityController/save?id=1&amp;name=南京中山陵</span><br><span class="line">http://localhost:6325/entityController/save?id=2&amp;name=中国南京师范大学</span><br><span class="line">http://localhost:6325/entityController/save?id=3&amp;name=南京夫子庙</span><br><span class="line">http://localhost:6325/entityController/save?id=4&amp;name=杭州也非常不错</span><br><span class="line">http://localhost:6325/entityController/save?id=5&amp;name=中国南边好像没有叫带京字的城市了</span><br></pre></td></tr></table></figure></p>
<p>数据插入效果如下（使用可视化插件elasticsearch-head观看）：<br><img src="http://upload-images.jianshu.io/upload_images/9824247-190179127668122f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数据插入效果"></p>
<p>我们来做一下搜索的测试：例如我要搜索关键字“南京”<br>我们在浏览器中输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:6325/entityController/search?name=南京</span><br></pre></td></tr></table></figure></p>
<p>搜索结果如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-59c5039405186431.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="关键字“南京”的搜索结果"></p>
<p>刚才插入的5条记录中包含关键字“南京”的四条记录均被搜索出来了！</p>
<p>当然这里用的是standard分词方式，将每个中文都作为了一个term，凡是包含“南”、“京”关键字的记录都被搜索了出来，只是评分不同而已，当然还有其他的一些分词方式，此时需要其他分词插件的支持，此处暂不涉及，后文中再做探索。</p>
<hr>
<p>最后附上个人联系方式，欢迎大家交流学习：<br>个人博客：www.hansonwang99.com.cn<br>个人网站：<a href="http://113.209.119.170/（" target="_blank" rel="noopener">http://113.209.119.170/（</a> 捂脸的表情，很慢，1G 1M 1核的云主机上）<br>简    书：<a href="https://www.jianshu.com/u/d19536b0189b" target="_blank" rel="noopener">https://www.jianshu.com/u/d19536b0189b</a></p>
<p><img src="https://hansonwang99.github.io/img/wechat_qrcode.jpg" title="欢迎扫描我的二维码！"></p>
]]></content>
      
        <categories>
            
            <category> ES </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ES </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[centos7上elastic search安装填坑记]]></title>
      <url>/2018/01/08/centos7%E4%B8%8Aelasticsearch%E5%AE%89%E8%A3%85%E5%A1%AB%E5%9D%91%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>Elastic Search探索的第一课</p>
<a id="more"></a>
<p>—-stic search 5.3.0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.3.0.tar.gz</span><br><span class="line">mv elasticsearch-5.3.0.tar.gz /opt</span><br><span class="line">cd /opt</span><br><span class="line">tar -xzvf elasticsearch-5.3.0.tar.gz</span><br><span class="line">cd elasticsearch-5.3.0/</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="启动ES"><a href="#启动ES" class="headerlink" title="启动ES"></a>启动ES</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /bin</span><br><span class="line">./elasticsearch</span><br></pre></td></tr></table></figure>
<p>按照道理应该就可以了，然而接下来各种坑一一出现，分别阐述</p>
<blockquote>
<p><strong>错误1</strong>：<code>error=&#39;Cannot allocate memory&#39; (errno=12)</code></p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-bf7df623f31204b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="error=&#39;Cannot allocate memory&#39; "></p>
<p><strong>solutions:</strong><br>由于elasticsearch5.0默认分配jvm空间大小为2g，需要改小一点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim config/jvm.options  </span><br><span class="line">-Xms2g  →  -Xms512m</span><br><span class="line">-Xmx2g  →  -Xmx512m</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>错误2</strong>： can not run elasticsearch as root</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-ae352ae5780de1dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="can not run elasticsearch as root"></p>
<p><strong>solutions：</strong><br>在 Linux 环境中，elasticsearch 不允许以 root 权限来运行！所以需要创建一个非root用户，以非root用户来起es<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">groupadd elk  # 创建用户组elk</span><br><span class="line">useradd elk -g elk -p 111111  # 创建新用户elk，-g elk 设置其用户组为 elk，-p 111 设置其密码6个1</span><br><span class="line">chown -R elk:elk /opt  # 更改 /opt 文件夹及内部文件的所属用户及组为 elk:elk</span><br><span class="line">su elk # 切换到非root用户elk下来</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>错误3</strong>：(1) max file descriptors [4096] for elasticsearch process is too low, increase to at least [65536]<br>(2) max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]</p>
</blockquote>
<p>此错误出现在修改config/elasticsearch.yml中的network.host为network.host: 0.0.0.0以便让外网任何IP都能来访问时。</p>
<p><strong>solutions：</strong><br>切换到root用户，然后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/security/limits.conf</span><br><span class="line">* soft nofile 300000</span><br><span class="line">* hard nofile 300000</span><br><span class="line">* soft nproc 102400</span><br><span class="line">* soft memlock unlimited</span><br><span class="line">* hard memlock unlimited</span><br></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-06d4a2c3a5a28ff6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="/etc/security/limits.conf"></p>
<blockquote>
<p><strong>错误4</strong>：max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-f347a09184d4c171.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="vm.max_map_count is too low"></p>
<p><strong>solutions：</strong><br>先要切换到root用户；<br>然后可以执行以下命令，设置 vm.max_map_count ，但是重启后又会恢复为原值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w vm.max_map_count=262144</span><br></pre></td></tr></table></figure></p>
<p>持久性的做法是在 /etc/sysctl.conf 文件中修改 vm.max_map_count 参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;vm.max_map_count=262144&quot; &gt; /etc/sysctl.conf</span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-70f1fd2f3ca40884.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>最后终于在外网访问成功：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-b81eb7e914736546.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="外网访问成功！"></p>
<hr>
<h2 id="安装可视化插件-elasticsearch-head"><a href="#安装可视化插件-elasticsearch-head" class="headerlink" title="安装可视化插件 elasticsearch-head"></a>安装可视化插件 elasticsearch-head</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone git://github.com/mobz/elasticsearch-head.git</span><br><span class="line">cd elasticsearch-head</span><br><span class="line">npm install   # 此处我试图用cnpm install有问题，用npm可以</span><br><span class="line">npm run start</span><br></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-b5ce1ede0ce91b04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>然后在外网访问<a href="http://你的安装机IP:9100" target="_blank" rel="noopener">http://你的安装机IP:9100</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-9d0fbaec06affe90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="访问elasticsearch-head可视化界面成功"></p>
<hr>
<h2 id="最后实际简单测试一下"><a href="#最后实际简单测试一下" class="headerlink" title="最后实际简单测试一下"></a>最后实际简单测试一下</h2><p>新建 Index，可以直接向 Elastic 服务器发出 PUT 请求。下面的例子是新建一个名叫weather的 Index。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-519f086e398de237.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="用rest接口向es添加index"></p>
<p>然而刷新elasticsearch-head可视化界面可以看到索引已经成功插入</p>
<p>  <img src="http://upload-images.jianshu.io/upload_images/9824247-a6e9bc43827de5a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="索引已经插入"></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p><a href="https://www.jianshu.com/p/8f226206ca30" target="_blank" rel="noopener">关于作者更多的elastic search实践在此</a></p>
<hr>
<p>最后附上个人联系方式，欢迎大家交流学习：<br>个人博客：www.hansonwang99.com.cn<br>个人网站：<a href="http://113.209.119.170/（捂脸的表情，很慢，1G" target="_blank" rel="noopener">http://113.209.119.170/（捂脸的表情，很慢，1G</a> 1M 1核的云主机上）<br>简    书：<a href="https://www.jianshu.com/u/d19536b0189b" target="_blank" rel="noopener">https://www.jianshu.com/u/d19536b0189b</a></p>
<p><img src="https://hansonwang99.github.io/img/wechat_qrcode.jpg" title="欢迎扫描我的二维码！"></p>
]]></content>
      
        <categories>
            
            <category> ES </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ES </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Docker Swarm 集群初探]]></title>
      <url>/2018/01/04/Docker-Swarm%E9%9B%86%E7%BE%A4%E5%88%9D%E6%8E%A2/</url>
      <content type="html"><![CDATA[<p>Docker集群初探之：Docker Swarm</p>
<a id="more"></a>
<p>cker技术大家都有所了解，单个Docker能发挥的作用毕竟有限，也不便于管理，所以Docker得组集群来使用才能发挥强大的技术优势。既然要组集群那就涉及诸如Docker的资源调度、管理等等一系列问题。目前涉及Docker集群的三个主要的技术无外乎Swarm、<a href="https://www.jianshu.com/p/9bc87b5380e8" target="_blank" rel="noopener">Kubernetes</a>、Mesos三种。从本文开始作者将会一一实践这几种主要的Docker集群技术，话不多说，现在开始。</p>
<p>注意：<a href="https://www.jianshu.com/p/9bc87b5380e8" target="_blank" rel="noopener">作者的kubernetes相关实践在此</a></p>
<hr>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul>
<li>Mac OS X 10.13.2  </li>
<li>Docker 17.09.1-ce-mac42 (21090)</li>
<li>virtualbox（虚拟集群中节点时需要）</li>
<li>boot2docker v1.8.0（在虚拟节点中起docker环境时需要）</li>
</ul>
<hr>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>节点规划如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-e93d6d3b9c1095e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="集群节点规划图"></p>
<p>我们需要4个节点（1个master + 3个slave），由于没有真实地4台物理机，所以下文中是靠<code>docker-machine</code>、<code>virtualbox</code>以及<code>boot2docker</code>来虚拟出4个独立IP地址的带docker环境的节点，大家注意！</p>
<p>环境安装：</p>
<ul>
<li>Docker环境安装：<blockquote>
<p><strong>Tips</strong>： 以前Mac上一般是使用<code>boot2docker</code>这个专门为OS X上运行 Docker 而开发的一个轻量级的虚拟主机管理工具来安装docker，现在<code>boot2docker</code>这种安装方式官方已经deprecated 了（当然下文中还是需要<code>boot2docker.iso</code>的镜像来帮助我们在虚拟的节点上起docker环境），可以直接下载docker的dmg安装包双击进行安装即可</p>
</blockquote>
</li>
</ul>
<p>我们选择docker CE版安装即可，下载链接如下：<br><a href="https://store.docker.com/search?type=edition&amp;offering=community" target="_blank" rel="noopener">https://store.docker.com/search?type=edition&amp;offering=community</a></p>
<blockquote>
<p><strong>注意</strong>：选择官方docker dmg包安装完成以后，<code>docker-machine</code>已经天然地集成于其中了，该工具在下文中创建虚拟节点时需要，它是一个可以在虚拟主机节点上安装docker engine的工具</p>
</blockquote>
<ul>
<li>virtualbox安装<blockquote>
<p>由于我们搭建集群需要具备多个不同IP地址的节点，然而我们手上仅一台电脑，所以需要借助virtualbox来虚拟出多个不同IP地址的节点供我们使用需要</p>
</blockquote>
</li>
</ul>
<p>去官方下载virtualbox的dmg安装包，双击安装即可：<br><a href="https://www.virtualbox.org/" target="_blank" rel="noopener">https://www.virtualbox.org/</a></p>
<ul>
<li>boot2docker安装<br>Boot2Docker是一个专为Docker而设计的轻量级Linux发型包，解决Windows或者OS X用户不能安装Docker的问题。Boot2Docker完全运行于内存中，体积小，启动快。Boot2Docker需要运行在VirtualBox中。</li>
</ul>
<p>我使用的是brew这个mac上的包管理器安装的，非常方便，只需一行命令：<br><code>brew install boot2docker</code></p>
<p>除此之外我们还需要下载boot2docker.iso镜像在后文中进行使用：<br><a href="https://github.com/boot2docker/boot2docker/releases/tag/v17.07.0-ce" target="_blank" rel="noopener">https://github.com/boot2docker/boot2docker/releases/tag/v17.07.0-ce</a><br>我们先把<code>boot2docker.iso</code>下好后面备用</p>
<hr>
<h2 id="Docker-Swarm集群实验"><a href="#Docker-Swarm集群实验" class="headerlink" title="Docker Swarm集群实验"></a>Docker Swarm集群实验</h2><h4 id="先创建4个虚拟节点（1个master-3个slave）"><a href="#先创建4个虚拟节点（1个master-3个slave）" class="headerlink" title="先创建4个虚拟节点（1个master + 3个slave）"></a>先创建4个虚拟节点（1个master + 3个slave）</h4><p>首先要将之前下载的<code>boot2docker.iso</code>放到<code>/Users/你的用户名/.docker/machine/cache/</code>目录下，然后执行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker-machine create --virtualbox-boot2docker-url ~/.docker/machine/cache/boot2docker.iso master</span><br><span class="line">docker-machine create --virtualbox-boot2docker-url ~/.docker/machine/cache/boot2docker.iso slave1</span><br><span class="line">docker-machine create --virtualbox-boot2docker-url ~/.docker/machine/cache/boot2docker.iso slave2</span><br><span class="line">docker-machine create --virtualbox-boot2docker-url ~/.docker/machine/cache/boot2docker.iso slave3</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：上面若不指定boot2docker的路径：<code>--virtualbox-boot2docker-url ~/.docker/machine/cache/boot2docker.iso</code>，直接执行<code>docker-machine create master</code>创建节点时，可能会报<code>No default Boot2Docker ISO found locally, downloading the latest release...</code>这种错误！所以最好自己指定boot2docker.iso镜像路径</p>
</blockquote>
<p>docker-machine命令创建虚拟机过程细节如下：<br><img src="http://upload-images.jianshu.io/upload_images/9824247-463c8595386fd948.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="docker-machine命令创建虚拟机过程"></p>
<p>创建完4个节点以后，可以用<code>docker-machine ls</code>命令查看一下各个节点的情况，可以看到自动为其分配了独立的IP地址：<br><img src="http://upload-images.jianshu.io/upload_images/9824247-53b25342e9cd7a19.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="docker-machine ls查看虚拟节点创建情况"></p>
<h4 id="ssh接入虚拟节点"><a href="#ssh接入虚拟节点" class="headerlink" title="ssh接入虚拟节点"></a>ssh接入虚拟节点</h4><p>开启4个独立的terminal终端，分别执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ssh master</span><br><span class="line">docker-machine ssh slave1</span><br><span class="line">docker-machine ssh slave2</span><br><span class="line">docker-machine ssh slave3</span><br></pre></td></tr></table></figure></p>
<p>执行后的效果如下图：<br><img src="http://upload-images.jianshu.io/upload_images/9824247-8f1a772ba1f693b0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3个slave1个master概览.jpg"></p>
<h4 id="接下来在master上初始化一个docker-swarm集群"><a href="#接下来在master上初始化一个docker-swarm集群" class="headerlink" title="接下来在master上初始化一个docker swarm集群"></a>接下来在master上初始化一个docker swarm集群</h4><p>执行命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm init --advertise-addr 192.168.99.100</span><br></pre></td></tr></table></figure></p>
<p>效果如下：<br><img src="http://upload-images.jianshu.io/upload_images/9824247-6a0be9a52f89eefc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在master节点上初始化集群"></p>
<p>上述命令执行成功后，提示中会告知用户在slave节点上执行命令 <code>docker swarm join --token SWMTKN-1-1uzft9zcrd5cl7eva4gr4ptgrs1gc252483ey19xfphcuxc8ta-evsmmj7b7kleh7yoezjutzuu2 192.168.99.100:2377</code><br>可以加入到该集群中，把命令都告诉你了，你说智不只能！</p>
<h4 id="将3个slave节点加入集群"><a href="#将3个slave节点加入集群" class="headerlink" title="将3个slave节点加入集群"></a>将3个slave节点加入集群</h4><p>分别去三个slave上，输入上面提示中的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm join --token SWMTKN-1-1uzft9zcrd5cl7eva4gr4ptgrs1gc252483ey19xfphcuxc8ta-evsmmj7b7kleh7yoezjutzuu2 192.168.99.100:2377</span><br></pre></td></tr></table></figure></p>
<p>执行效果如下：<br><img src="http://upload-images.jianshu.io/upload_images/9824247-e22accdc7b8b8bdb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="master上初始化集群以及3个slave加入集群"></p>
<blockquote>
<p>注意：如果忘了docker swarm join 命令中的token命令的话，可以使用命令<code>docker swarm join-token worker</code>来get之</p>
</blockquote>
<p>好，到此为止应该说docker swarm集群的搭建工作已经完成了，那下面在这个集群上做点实际的任务吧！</p>
<h4 id="开始在master节点上创建服务"><a href="#开始在master节点上创建服务" class="headerlink" title="开始在master节点上创建服务"></a>开始在master节点上创建服务</h4><p>我们计划在该docker集群上部署高可用的nginx容器任务来作为演示：<br>在master节点上执行如下命令来创建名为mynginx的service，让其有2份nginx容器副本分配到集群中去，起在8080端口：<br><code>docker service create --replicas 2 -d -p 8080:80 --name mynginx registry.docker-cn.com/library/nginx</code><br>然后使用如下两条命令查看效果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker service ls</span><br><span class="line">docker service ps mynginx</span><br></pre></td></tr></table></figure></p>
<p>执行效果如下：<br><img src="http://upload-images.jianshu.io/upload_images/9824247-2fc87e12018b66ec.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在master节点上刚创建mynginx service"></p>
<p>此处有两点需要注意：</p>
<ol>
<li>我们使用了<code>registry.docker-cn.com/library/nginx</code>作为加速镜像，不然可能在slave上pull镜像的时候timeout</li>
<li>注意此处创建了service之后并不是nginx容器立马都在slave上起起来了，是需要等一段时间的（如，我等了近8分钟），因为在slave上还要去pull nginx镜像，再启动nginx容器等，没有那么快</li>
</ol>
<p><strong>等待若干分钟</strong>以后，我们再看效果，发现此时任务顺利地分发到slave1和slave2上了：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-efa10145c043947e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="经过若干分钟后在master上查看service的效果"></p>
<p>分别用浏览器访问：<br><a href="http://192.168.99.101:8080" target="_blank" rel="noopener">http://192.168.99.101:8080</a> 和 <a href="http://192.168.99.102:8080" target="_blank" rel="noopener">http://192.168.99.102:8080</a> ，会得到如下结果：<br><img src="http://upload-images.jianshu.io/upload_images/9824247-b5be4d1192d55ad7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="192.168.99.101（slave1）上nginx容器访问结果"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-28c6f6b350affebd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="192.168.99.102（slave2）上nginx容器访问结果"></p>
<p>成功访问到了slave节点中起起来的nginx服务！</p>
<p>此时分别去 slave1 和 slave2 上查看容器运行情况，结果如下：<br><img src="http://upload-images.jianshu.io/upload_images/9824247-8294ce8d6829c377.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="slave1 和 slave2 上查看容器运行情况"></p>
<h4 id="进一步实验：扩容service中的任务"><a href="#进一步实验：扩容service中的任务" class="headerlink" title="进一步实验：扩容service中的任务"></a>进一步实验：扩容service中的任务</h4><p>我们想将nginx容器平滑地扩容到3份，在master上执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service scale mynginx=3</span><br></pre></td></tr></table></figure></p>
<p>然后在master上查看service，发现新增的一个容器任务分配到slave3上了，当然此时slave3上正在preparing：<br><img src="http://upload-images.jianshu.io/upload_images/9824247-2ab71eef5a9b3541.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="扩容为3份后任务被分到slave3上）.jpg"></p>
<p>等若干分钟后在master上再次查看service，发现slave3上的nginx容器任务成功启动了：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-ce0e398fff13eaf6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="成功扩容之后master节点上看集群信息"></p>
<p>去slave3节点上docker ps看一下，发现容器确实启动了：<br><img src="http://upload-images.jianshu.io/upload_images/9824247-06f77b8f006a4a63.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="扩容到slave3后slave3上的docker ps信息"></p>
<p>####进一步实验：集群中service高可用<br>目前有3个运行的nginx容器保证服务的可用性，如果其中一个容器意外关闭将会是什么情况？接下来就来模拟</p>
<p>我们关闭slave1上此时正在运行着的nginx容器，看服务有什么变化：<br><img src="http://upload-images.jianshu.io/upload_images/9824247-25e3c6f476063443.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="关掉slave1上的nginx容器"></p>
<p>此时去master节点上查看信息发现，被关掉的nginx被分配到master上重启了：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-561136e66dd1093d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="关闭了slave1后，在master节点上恢复了nginx服务"></p>
<p>此时我又关闭master节点上启动的nginx容器，发现刚关闭不久后，nginx容器又重新在master上恢复了：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-f028e2c8f23c63d0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="再次关闭master上的ngix，结果在master上全部重启.jpg"></p>
<p>接下来我们来将slave3宕机（宕机和前文的关闭nginx容器不同，此处模仿的是物理宕机），我们在控制台中使用docker-machine stop来模拟宕机动作：<br><img src="http://upload-images.jianshu.io/upload_images/9824247-e006a44950eb7b52.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="将slave3从集群中断开"></p>
<p>此时去master上查看service信息发现slave3宕机以后，nginx任务又重启与slave1上来保持高可用：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-84870e9debc9e9ae.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="将slave3宕机后nginx重启在slave1上"></p>
<p>最后来把狠的，我们将slave1，slave2，slave3全部从集群中断开：<br><img src="http://upload-images.jianshu.io/upload_images/9824247-ac0271b7188ed3d4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="将所有节点全部宕机.jpg"></p>
<p>结果去master上查看service信息，发现3个容器副本全部迁移到master之上了：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9824247-c172956fd86b6109.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3个slave全部宕机后任务全部重启在master上"></p>
<p>此时在master上执行<code>docker ps</code>查看容器信息如下：运行着3个nginx容器：<br><img src="http://upload-images.jianshu.io/upload_images/9824247-8abea86992190358.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="slave全部宕机后在master节点上看到的nginx容器进程"></p>
<p>总而言之，无论怎么操作集群都能保持制定数量的容器副本来实现高可用！</p>
<hr>
<h2 id="【干货】总结一下上文中的常用命令"><a href="#【干货】总结一下上文中的常用命令" class="headerlink" title="【干货】总结一下上文中的常用命令"></a>【干货】总结一下上文中的常用命令</h2><ul>
<li><p>创建虚拟主机节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine create 虚拟主机名</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看虚拟机节点信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ls</span><br></pre></td></tr></table></figure>
</li>
<li><p>停止虚拟主机节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine stop 虚拟主机名</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除虚拟主机节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine rm 虚拟主机名</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化docker swarm集群</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm init --advertise-addr master的IP地址</span><br></pre></td></tr></table></figure>
</li>
<li><p>slave节点加入集群</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm join --token [token] [master的IP]:[master的端口]</span><br></pre></td></tr></table></figure>
</li>
<li><p>slave节点主动离开集群</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm leave</span><br></pre></td></tr></table></figure>
</li>
<li><p>在master上获取加入集群的token</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm join-token worker</span><br></pre></td></tr></table></figure>
</li>
<li><p>master上创建service举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service create --replicas 2 -d -p 8080:80 --name 服务名 镜像名</span><br></pre></td></tr></table></figure>
</li>
<li><p>master上查看service信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker service ls</span><br><span class="line">docker service ps 你所创建的服务的ID</span><br></pre></td></tr></table></figure>
</li>
<li><p>在master上删除service</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service rm 服务名</span><br></pre></td></tr></table></figure>
</li>
<li><p>在master上进行服务扩容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service scale 你的service name=你要的副本数目</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="http://www.widuu.com/docker/installation/mac.html" target="_blank" rel="noopener">http://www.widuu.com/docker/installation/mac.html</a></li>
<li><a href="http://www.widuu.com/docker/installation/mac.html" target="_blank" rel="noopener">http://www.widuu.com/docker/installation/mac.html</a></li>
<li><a href="https://www.docker.com/community-edition" target="_blank" rel="noopener">https://www.docker.com/community-edition</a></li>
<li><a href="https://www.docker.com/community-edition" target="_blank" rel="noopener">https://www.docker.com/community-edition</a></li>
<li><a href="https://www.jianshu.com/p/096244610e15" target="_blank" rel="noopener">https://www.jianshu.com/p/096244610e15</a></li>
<li><a href="https://www.cnblogs.com/atuotuo/p/6265541.html" target="_blank" rel="noopener">https://www.cnblogs.com/atuotuo/p/6265541.html</a></li>
</ul>
<hr>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>想要看作者关于kubernetes的相关实践？<br><a href="https://www.jianshu.com/p/9bc87b5380e8" target="_blank" rel="noopener">请戳这里</a></p>
<hr>
<p>最后附上个人联系方式，欢迎大家交流学习：<br>个人博客：www.hansonwang99.com.cn<br>个人网站：<a href="http://113.209.119.170/（捂脸的表情，很慢，1G" target="_blank" rel="noopener">http://113.209.119.170/（捂脸的表情，很慢，1G</a> 1M 1核的云主机上）<br>简    书：<a href="https://www.jianshu.com/u/d19536b0189b" target="_blank" rel="noopener">https://www.jianshu.com/u/d19536b0189b</a></p>
<p><img src="https://hansonwang99.github.io/img/wechat_qrcode.jpg" title="欢迎扫描我的二维码！"></p>
]]></content>
      
        <categories>
            
            <category> Docker </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java编程思想学习录（连载之：初始化与清理）]]></title>
      <url>/2018/01/03/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E5%BD%95%EF%BC%88%E8%BF%9E%E8%BD%BD%E4%B9%8B%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>Java编程思想学习录连载文章</p>
<a id="more"></a>
<h3 id="关于构造器与初始化"><a href="#关于构造器与初始化" class="headerlink" title="关于构造器与初始化"></a>关于构造器与初始化</h3><ul>
<li>无参构造器 = 默认构造器 = 自己未写编译器帮忙自动创建的</li>
<li>若自行定义了构造器（无论参数有否），编译器便停止默认创建动作</li>
<li>类里的对象引用默认初始化为null，基本类型初始化为0</li>
</ul>
<p><strong>四种常见初始化方式：</strong></p>
<ul>
<li>自动初始化：无法被阻止的，先于构造器，即所谓的基本类型赋空值（0），对象赋null</li>
<li>指定初始化：定义类成员的时候直接赋初始值</li>
<li>初始化子句：(匿名内部类的初始化的必需品！且一定先于构造器执行)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Example &#123;</span><br><span class="line">  int i;</span><br><span class="line">  int j;</span><br><span class="line">  &#123;</span><br><span class="line">    i = 1;</span><br><span class="line">    j = 2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>构造器初始化：在构造器中对成员赋上值</li>
</ul>
<p><strong>静态域的初始化：</strong></p>
<ul>
<li>java中的static关键字是只能用于域，而不能用于普通的局部变量</li>
<li>未赋值过的类的静态域默认有初值：（object=null、基本数据类型 = 0）</li>
<li>静态子句的概念：包含有多个静态域初始化的的语句块，举例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Cups &#123;</span><br><span class="line">  Static cup cup1;</span><br><span class="line">  Static cup cup2;</span><br><span class="line">  static &#123; // 静态子句</span><br><span class="line">    cup1 = new Cup(1);</span><br><span class="line">    cup2 = new Cup(2);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>数组的初始化：</strong></p>
<ul>
<li>java是不允许定义数组时指定数组大小的</li>
<li>所有数组都有一个固定成员length</li>
<li>对象数组初始化方法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 形式1：只能被用在数组定义处，比较受限</span><br><span class="line">Integer[] a = &#123;</span><br><span class="line">  new Integer(1),</span><br><span class="line">  new Integer(2),</span><br><span class="line">  3, // 会被自动包装</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 形式2：可用于任何地方，典型在函数传参时：如：Example.func( new Ingeger[] &#123; new Integer(1), new Integer(2), 3 &#125; )</span><br><span class="line">Integer[] b = new Ingeger[] &#123;</span><br><span class="line">    new Integer(1),</span><br><span class="line">    new Integer(2),</span><br><span class="line">    3, // 会被自动包装</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>可变参数列表</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Example &#123;</span><br><span class="line">  static void f( int i, String... trailing ) &#123;</span><br><span class="line">    ...</span><br><span class="line">    for( String s : trailing  )</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line">  public static void main( String[] args ) &#123;</span><br><span class="line">    f( 1, &quot;one&quot; );</span><br><span class="line">    f( 1, &quot;one&quot;, &quot;tow&quot; );</span><br><span class="line">    f( 1 );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特别注意：</p>
<blockquote>
<p>若函数参数只使用可变函数列表这将会使重载变得难以理解，解决办法是：（1）要么在参数中加一个非可变参数；（2）要么只在重载方法的一个版本上使用可变参数；（3）不要尝试这种做法  </p>
</blockquote>
<p><strong>初始化的顺序：</strong></p>
<ul>
<li>static成员先于non-static</li>
<li>类成员定义顺序=初始化顺序（即使变量散布于类方法之间）</li>
<li>某个成员先定义，然后再在构造器中初始化，其值的就先被编译器赋空值（null和0），然后再被赋上具体值，这个是有个先后关系的！</li>
</ul>
<hr>
<h3 id="关于this"><a href="#关于this" class="headerlink" title="关于this"></a>关于this</h3><blockquote>
<ul>
<li>当以object来调用方法时，编译器会将该对象的引用作为第一个参数来传给方法：<code>object.func(1) = Class.func(object,1)</code></li>
<li>注意类的static方法无this，且static方法内部不可调用非static方法，反过来ok</li>
<li>this可以用来在constructor中调用constructor，举例：</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 利用this实现constructor中调用constructor</span><br><span class="line">public class Example &#123;</span><br><span class="line">  int _i = 0;</span><br><span class="line">  String s = &quot;&quot;;</span><br><span class="line">  Example( int i ) &#123; this._i = i; &#125;</span><br><span class="line">  Example( String s, int i ) &#123;</span><br><span class="line">    this(i); // 该句必须在最开始，且this()这种只能使用一次</span><br><span class="line">    this._s = s;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="关于重载"><a href="#关于重载" class="headerlink" title="关于重载"></a>关于重载</h3><blockquote>
<ul>
<li>java重载唯一规则：独一无二的参数列表</li>
<li>永远不要幻想以返回值区分重载</li>
</ul>
</blockquote>
<hr>
<h3 id="关于清理（finalize终结处理-和-jvm垃圾回收）"><a href="#关于清理（finalize终结处理-和-jvm垃圾回收）" class="headerlink" title="关于清理（finalize终结处理 和 jvm垃圾回收）"></a>关于清理（finalize<strong>终结处理</strong> 和 jvm<strong>垃圾回收</strong>）</h3><p>关于jvm的垃圾回收，有几点必须记住的：</p>
<ul>
<li>对象可能不被垃圾回收</li>
<li>垃圾回收并不等于C++中的destructor</li>
<li>垃圾回收只与内存有关</li>
</ul>
<p>java允许在类中创建一个名为finalize()的方法做终结处理，但该函数一般不是来给你做内存释放这类动作的！</p>
<blockquote>
<p>建议： 如果是进行除释放存储空间之外的清理工作（如关闭文件句柄等），还是由程序员来明确地调用某个恰当的方法</p>
</blockquote>
<hr>
<h3 id="关于枚举类型"><a href="#关于枚举类型" class="headerlink" title="关于枚举类型"></a>关于枚举类型</h3><ul>
<li>java中enum也是一个类，拥有自己的方法<br>举例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个枚举类型</span><br><span class="line">public enum Spiciness &#123;</span><br><span class="line">  NOT, MILD, MEDIUM</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用枚举类型</span><br><span class="line">Spiciness howHot = Spiciness.MEDIUM;</span><br><span class="line">System.out.println(howHot); // ① 打印 MEDIUM</span><br><span class="line"></span><br><span class="line">for( Spiciness s : Spiciness.values() ) &#123;</span><br><span class="line">  System.out.println( s + &quot;, ordinal &quot; + s.ordinal() );</span><br><span class="line">&#125;</span><br><span class="line">// output:</span><br><span class="line">// NOT, ordinal 0</span><br><span class="line">// MILD, ordinal 1</span><br><span class="line">// MEDIUM, ordinal 2</span><br><span class="line"></span><br><span class="line">Spiciness exam = Spiciness.MILD;</span><br><span class="line">switch( exam ) &#123;</span><br><span class="line">  case NOT:</span><br><span class="line">    ...</span><br><span class="line">  case MILD: // 所以这个case一定会走到这个分支！</span><br><span class="line">    ...</span><br><span class="line">  case MEDIUM:</span><br><span class="line">    ...</span><br><span class="line">  default:</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上面的例子可以看出：</p>
<ul>
<li>编译器自动在enum中添加了tostring()方法，所以上面的①处可以打印出MEDIUM</li>
<li>编译器自动在enum中创建了ordinal()方法用来表示某个enum常量的声明顺序</li>
<li>编译器自动在enum中创建了static的values()方法，用来按照enum常量的声明顺序来生成由这些常量值所构成的数组</li>
<li>switch和enum是绝配啊！</li>
</ul>
<hr>
<p>最后附上个人联系方式，欢迎大家交流学习：<br>个人博客：www.hansonwang99.com.cn<br>个人网站：<a href="http://113.209.119.170/（捂脸的表情，很慢，1G" target="_blank" rel="noopener">http://113.209.119.170/（捂脸的表情，很慢，1G</a> 1M 1核的云主机上）<br>简    书：<a href="https://www.jianshu.com/u/d19536b0189b" target="_blank" rel="noopener">https://www.jianshu.com/u/d19536b0189b</a></p>
<p><img src="https://hansonwang99.github.io/img/wechat_qrcode.jpg" title="欢迎扫描我的二维码！"></p>
]]></content>
      
        <categories>
            
            <category> Java沉思录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java编程思想学习录（连载之：一切都是对象）]]></title>
      <url>/2018/01/01/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E5%BD%95%EF%BC%88%E8%BF%9E%E8%BD%BD%E4%B9%8B%EF%BC%9A%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>Java编程思想学习录连载文章</p>
<a id="more"></a>
<h1 id="还是有必要学习一下关于·一切都是对象"><a href="#还是有必要学习一下关于·一切都是对象" class="headerlink" title="还是有必要学习一下关于·一切都是对象"></a>还是有必要学习一下关于·一切都是对象</h1><p>说Java是一种<strong>纯粹的</strong>面向对象的语言，可能这话主要是针对和C++的比较而言，毕竟C++提供了向C的后向兼容的能力，致使C++好像面向对象得不那么纯粹，这话我大概同意吧。</p>
<h3 id="Java均是在用reference来操作对象"><a href="#Java均是在用reference来操作对象" class="headerlink" title="Java均是在用reference来操作对象"></a>Java均是在用reference来操作对象</h3><blockquote>
<p>比较安全的做法是：创建引用的同时对其进行初始化</p>
</blockquote>
<h3 id="对象由我们来创建但却不需要我们来销毁"><a href="#对象由我们来创建但却不需要我们来销毁" class="headerlink" title="对象由我们来创建但却不需要我们来销毁"></a>对象由我们来创建但却不需要我们来销毁</h3><ul>
<li><p>对于基本类型</p>
<blockquote>
<ul>
<li>无需用new，java视其为非引用的自动变量，并置于stack之中</li>
<li>基本类型有其包装器类，这才允许将其创建于heap之中，当然包装完之后也不能叫基本类型对象了</li>
<li>java所有数值都有正负，不支持无符号</li>
<li>BigInteger和BigDecimal是Java支持的两大高精类型</li>
</ul>
</blockquote>
</li>
<li><p>对于数组</p>
<blockquote>
<ul>
<li>java在每个数组上用了一点内存开销以及运行时的下标检查为代价，带来了收益是：java确保数组会被初始化（对象数组元素初始化为null，基本类型数组元素初始化为0），且不会越界访问 </li>
</ul>
</blockquote>
</li>
<li><p>对于class</p>
<blockquote>
<ul>
<li>基本数据类型成员会确保有默认值（但该条款不适用与局部变量）</li>
<li>称呼上惯用方法来取代函数；方法名和参数列表成为方法签名；调用方法的行为称为发消息给对象</li>
</ul>
</blockquote>
</li>
<li><p>关于作用域</p>
<blockquote>
<ul>
<li>java不允许覆盖一个较大作用域的变量，如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  int x = 12;</span><br><span class="line">  &#123;</span><br><span class="line">    int x = 96； // 这在Java里是不合法的</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
</li>
<li><p>关于Static对象</p>
<blockquote>
<ul>
<li>一份存储空间</li>
<li>直接使用类名来引用static成员更常见</li>
</ul>
</blockquote>
</li>
<li>关于一个java程序<blockquote>
<ul>
<li>java.lang肯定会被自动导入到每一个java文件中</li>
<li>一个java源码文件 = 一个编译单元</li>
<li>java源文件名 = 源文件中<strong>仅有的一个public</strong>类名，且该类必须包含一个main()方法（当然一个java文件中无public类也是ok的！）</li>
<li>每个java类都有一个main()方法是OK的，这样还便于单元测试！</li>
</ul>
</blockquote>
</li>
</ul>
<hr>
<p>最后附上个人联系方式，欢迎大家交流学习：<br>个人博客：www.hansonwang99.com.cn<br>个人网站：<a href="http://113.209.119.170/（捂脸的表情，很慢，1G" target="_blank" rel="noopener">http://113.209.119.170/（捂脸的表情，很慢，1G</a> 1M 1核的云主机上）<br>简    书：<a href="https://www.jianshu.com/u/d19536b0189b" target="_blank" rel="noopener">https://www.jianshu.com/u/d19536b0189b</a></p>
<p><img src="https://hansonwang99.github.io/img/wechat_qrcode.jpg" title="欢迎扫描我的二维码！"></p>
]]></content>
      
        <categories>
            
            <category> Java沉思录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hello]]></title>
      <url>/2017/12/29/hello/</url>
      <content type="html"></content>
      
        
    </entry>
    
  
  
</search>
